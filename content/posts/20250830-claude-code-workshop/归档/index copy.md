---
title: "20250830 Claude Code Workshop"
date: 2025-08-30T11:52:13+08:00
draft: true
tags: []
categories: []
description: ""
cover:
    image: ""
    alt: ""
    caption: ""
    relative: true
---

# 从副驾驶到架构师：我的AI编程协作方法论

在过去几年里，我更换AI编程工具的频率，几乎赶上了前端框架的迭代速度。

一开始，我像许多人一样，让GPT帮我写一个孤立的函数，感觉很神奇。后来，GitHub Copilot成了我的标配，它总能猜到我接下来要写的几行代码，尤其是在写那些重复的样板文件时。再之后，Cursor出现了，它将对话和编码更紧密地集成在编辑器里，我开始尝试让它帮我完成更复杂的任务。

我一度认为，找到那个“最强”的工具，就能一劳永逸。

然而，真正的改变，发生在我停止寻找“更好”的工具，转而开始思考如何“更好”地与它协作的那一刻。契机很偶然，只是因为Cursor的定价策略调整，我切换到了Claude Code。但我发现，尽管工具换了，我遇到的核心挑战没变，而我之前摸索出的有效工作模式，依然有效。

这让我意识到一个更根本性的问题：我们中的许多人，包括过去的我，都可能用错了力气。我们痴迷于比较不同AI的编码能力，就像在争论锤子A和锤子B哪个敲钉子更快，却忽略了我们真正要做的，是建造一座房子。

关键不在于单次挥锤的力量，而在于你是否有一张清晰的蓝图和一套高效的施工流程。

这篇文章的目的，就是分享我提炼出的这套“施工流程”——一套通用的、结构化的AI编程协作方法论。它无关乎你用的是Claude Code、Cursor，还是未来任何可能出现的新工具。它的核心是改变你与AI的协作模式：从一个偶尔寻求帮助的“使用者”，转变为一个能系统性地引导AI、共同交付高质量工作的“架构师”。

让我们从一个几乎所有开发者都会遇到的场景开始：接手一个陌生的代码库。

## 第一幕：AI，迷宫中的导航员

任何一个有经验的开发者都熟悉那种感觉：你被空降到一个陌生的代码库，像被扔进了一座没有地图的迷宫。文档要么不存在，要么早已过时。你只能靠着零星的注释和直觉，在成千上万行代码中摸索，试图在脑中重建一个脆弱的模型。这个过程不仅痛苦，而且极其低效，它消耗的是我们最宝贵的资源：认知带宽。

过去，这是无法避免的“功课”。但现在，我认为这是一种时间的浪费。

在与AI协作的初期，我发现它的第一个、也是最被低估的能力，不是写代码，而是读代码。与其把它看成一个初级程序员，不如把它看成一个顶级的代码分析师，一个能帮你快速绘制出迷宫地图的导航员。

让我用一个例子来说明。最近，我需要理解一个名为`eino`的Go语言AI框架中的ReAct机制。这是一个架构复杂的项目，如果按照传统方式，我预估需要一到两天的时间，才能理清它的核心脉络。

这一次，我没有直接一头扎进代码里。我做的第一件事，是为我的AI导航员写一份清晰的“任务简报”。我发现，一个结构化的指令远比一句模糊的“帮我看看这个项目”要有效得多。我把这个指令框架总结为四个要素：

1.  **角色 (Role):** 你是谁？我告诉它：“你是一位精通Go和AI Agent的资深软件架构师。” 这为我们的对话设定了专业的基调和视角。
2.  **任务 (Task):** 你要做什么？我明确指出：“你的任务是分析ReAct Agent的核心实现逻辑，并生成一份技术梳理文档。” 这定义了成功的标准。
3.  **背景 (Context):** 你为什么要做这件事？我补充道：“这份文档将作为内部知识库的核心内容，帮助团队快速上手。” 这让AI理解了最终的价值。
4.  **约束 (Constraints):** 你要如何交付？我给出了具体的格式要求：“文档必须包含流程梳理、接口文档和Mermaid流程图三个部分。” 这确保了输出结果是我想要的，而不是一堆无用的闲聊。

![siyaosu](https://raw.githubusercontent.com/Miss-you/img/master/painting-tutorials/四要素prompt.png)

我把包含这四个要素的Prompt和项目代码一起交给了AI。结果是惊人的。

不到一个小时，我得到了一份完整的分析报告。它不仅精准地定位了核心入口函数（`NewAgent()`）、剖析了核心循环的每一步（推理、工具调用、观察、再推理），还为我生成了一张清晰的Mermaid流程图，将整个复杂的调用链路可视化。

一天的工作，一小时完成。这已经不是量级的提升，而是工作范式的改变。

这背后是什么原理？我认为关键在于两点。第一，AI拥有近乎无限的“工作记忆”，它可以同时扫描和关联成百上千个文件，在我们的大脑还在费力地跟踪两三个函数跳转时，它已经构建起了完整的调用图。第二，它强大的模式识别能力，使其能迅速识别出代码中隐藏的设计模式和架构意图，就像一个经验丰富的建筑师能从几根柱子的布局看出整栋建筑的风格。

这种导航能力，一旦掌握，可以延伸到许多场景：用它审查代码中潜在的风险，用它快速熟悉一个开源项目并参与贡献，或者用它来评估一个新技术框架的可行性。

至此，我们解决了“读”的问题。AI为我们绘制了地图，指明了方向。但真正的旅程才刚刚开始。接下来，我们需要在这张地图上建造新的东西——也就是“写”代码。

而这，恰恰是最多人掉进陷阱的地方。它引出了我们的第二个话题：如何避免随性而至的“感觉式编程”，并与AI建立一个结构化的协作流程。

## 第二幕：告别感觉，拥抱结构

当我们拥有了一张由AI绘制的清晰地图后，真正的建造工作开始了。也正是在这里，我们最容易走上一条歧路。

这条歧路，我称之为“感觉式编程”（Vibe Coding）。它的诱惑力极大，因为它看起来就像是通往效率的捷径。你只需要向AI许愿：“帮我写个登录功能”，然后复制代码，粘贴，运行。如果出错了，就再许一个愿：“修复这个bug”。

这个过程，就像是雇佣了一个极其聪明但毫无经验的实习生，然后你蒙上眼睛，让他随心所欲地盖房子。你得到的是一连串的忙乱、看似进展神速的假象，以及最终一个摇摇欲坠、没人能维护的烂摊子。更糟糕的是，在这个过程中，你把最重要的思考环节外包了出去，自己的能力没有丝毫长进。

我曾掉进过这个陷阱。一次又一次的失败让我明白，问题不在于AI的能力，而在于我的协作方式。我不是在引导它，而是在放任它。

于是，我开始寻找一种更有序、更可靠的方法。最终，我总结出了一套由四个阶段组成的结构化工作流，它彻底改变了我与AI的协作质量：**勘探 → 规划 → 建造 → 验收**。

这套流程的本质，是将软件开发的经典工程原则，应用到与AI的协作中。你不再是一个简单的“使用者”，而是一个项目的“总建筑师”。

![EPCC](https://raw.githubusercontent.com/Miss-you/img/master/painting-tutorials/ai协作epcc.png)

#### 第一阶段：勘探 (Explore)

在动工之前，建筑师必须勘探地形。同样，在写任何代码之前，我和AI必须就问题和现有环境达成共识。我不会直接下令，而是会提出要求，比如：“阅读这些文件，理解当前用户认证的逻辑，但先不要写任何代码。”

这个阶段的目标，是在我和AI之间建立一个共享的、准确的上下文。这是后续所有工作的基础。

#### 第二阶段：规划 (Plan)

这是整个流程中最关键的一步，也是最能体现开发者价值的一步。当地形勘探清楚后，我们需要一张蓝图。

我会要求AI提出一个详细的实现计划，并鼓励它思考不同方案的优劣。有时，我甚至会把同一个问题抛给不同的AI模型，像是在听取多个技术顾问的建议。最终，我会选择并敲定一个最优方案，让AI把它整理成一份清晰的、步骤化的任务列表。

一个有效的技巧是，让这份计划以技术文档或GitHub Issue的格式输出。它就像一个检查点，如果后续的“建造”阶段偏离了轨道，我们随时可以回到这份蓝图，重新校准方向。

#### 第三阶段：建造 (Code)

有了蓝图，建造工作就变得有条不紊。这里的核心原则是：**小批量、可验证**。

我绝不会让AI一次性生成整个功能。我会按照规划好的任务列表，让它一个函数、一个模块地生成。每生成一小部分，我都会立即审查和验证。这就像一层一层地盖楼，确保每一层的地基都稳固可靠。

在这个过程中，AI负责处理那些繁琐的“胶水代码”，而我则能将全部精力聚焦在核心逻辑的审查上。我们的对话通常是这样的：“好了，先实现计划中的`getUserInfo`函数。”，AI生成后，我检查并提出修改：“这里需要增加一个用户不存在的异常处理。”……这种小步快跑的反馈循环，极大地降低了出错的风险。

#### 第四阶段：验收 (Commit)

当所有模块都按计划建造完毕后，就进入了最后的验收阶段。

我会让AI辅助我完成收尾工作：生成规范的提交信息，更新相关的文档。更重要的是，我会让它扮演一位苛刻的“代码审查员”，对即将提交的修改进行一次预审，检查是否存在潜在的逻辑漏洞或风格问题。这相当于在正式交付前，进行了一次高质量的内部质检。

这套方法论的威力有多大？让我们来看一个真实的重构案例。

我有一个很久以前写的epub翻译工具，代码陈旧，逻辑混乱。我决定用它来检验不同工作方式的优劣。

* **传统方式**：我花了整整一天时间来回忆和理解旧代码，第二天开始动手修改，结果引入了新的bug，第三天在修bug中度过。项目最终磕磕绊绊地完成了，耗时**三天**。
* **感觉式编程**：我直接把整个项目扔给AI，命令它“重构这个项目”。结果可想而知，AI在错误的道路上狂奔，生成了一堆无法运行的代码。在多次失败、耗尽了计算额度后，我只能放弃。耗时**半天**，结果是**失败**。
* **结构化方式**：
    * 勘探 (30分钟)：AI迅速帮我理清了项目的整体结构和核心逻辑。
    * 规划 (30分钟)：我们共同制定了一份详细的重构蓝图。
    * 建造 (60分钟)：我们按照蓝图，逐一替换和重写了核心模块。
    * 验收 (10分钟)：AI辅助完成了代码审查和文档更新。
    * 总耗时：**两小时**。结果稳定可靠。

从三天到两小时，差异是惊人的。但这背后并非魔法，只是因为我们用“规划”的确定性，取代了“感觉”的随机性。这套方法不仅适用于重构，也同样适用于开发新功能、编写数据分析脚本，甚至优化数据库查询。

然而，我知道你可能会有一个疑问：这个过程听起来充满了来回的沟通和确认，虽然看起来很稳妥，但它的效率真的比我自己直接写代码更高吗？

这是一个非常好的问题，值得我们深入探讨。

## 第三幕：重新思考“效率”

我们建立的这套“勘探-规划-建造-验收”的流程，听起来很严谨，但它也引出了一个非常实际的疑问：来回地与AI讨论、确认，真的比我们自己撸起袖子直接写代码更快吗？

这个问题很关键，因为它迫使我们去审视一个更根本的问题：我们到底应该如何衡量“效率”？

如果我们把效率定义为“每分钟敲出的代码行数”，那么这套方法可能毫无优势。但任何一个资深的工程师都知道，这是一种虚荣且危险的指标。真正的效率，是**交付一个健壮、可维护的解决方案的总时长**。这个时长，不仅包括了写代码的时间，更包括了调试、返工、以及未来维护的隐性成本。

一旦我们从这个更宏观的视角出发，就会发现，那些看似“拖慢”节奏的规划与沟通，实际上是对项目后期时间和精力的巨大节省。

我曾仔细复盘过我的工作时间分配，发现了一个有趣的现象。在使用结构化AI协作后，一个任务的总耗时或许没有像传说中那样缩减80%，有时可能只是从13小时减少到11小时。但时间花费的**构成**，发生了根本性的变化。

试想一下传统的开发流程：2小时的快速编码，紧接着是长达8小时的、痛苦的调试和排错，最后可能还有3小时的返工。大部分时间，我们都陷在一种低质量、高挫败感的“找茬”游戏中。

而现在，我的时间分配变成了这样：大约有3小时花在前期与AI的沟通和方案设计上，4小时用于分模块的生成与验证，2小时用来代码审查和完善文档。虽然编码的总时长可能增加了，但那漫长的8小时“痛苦调试”几乎消失了。

**我们实际上是用高质量、高确定性的“设计时间”，替换掉了低质量、充满不确定性的“纠错时间”。**

我们把原本会被浪费在修复bug上的精力，投入到了更有价值的活动上：比如为代码补充更清晰的注释，编写更完备的单元测试。这不仅提升了单次交付的质量，更是在为项目的长期健康投资。

这背后，还有一个关于“认知负荷”的重要洞察。

试想一下，一个新手同事一次性给你提交了一个包含上千行改动的巨大请求。你的第一反应是什么？大概率是头痛。你几乎不可能仔细审查每一行代码的逻辑，只能走马观花地看一遍，这其中必然会遗漏隐患。

让AI一次性生成几百行代码，也是在制造同样的灾难。

而结构化协作的核心——小批量生成，完美地解决了这个问题。当AI每次只为你生成一个独立的、不超过50行的函数时，两个奇妙的好处出现了：

1.  **即时验证**：你的大脑可以轻松地完整“运行”一遍这段代码，或者迅速为它写一个测试。系统的每一块积木，在它被砌上去的那一刻，就是坚固的。
2.  **精力聚焦**：AI处理了所有繁琐的、重复的“胶水代码”，比如数据格式转换、API调用封装等。这让你能把100%的认知资源，聚焦在最核心、最复杂的业务逻辑上。

这才是与AI协作的精髓。你不是在和它比谁打字快，而是在**利用它来外包你的认知负担，让自己能更专注、更深刻地思考**。

当然，这并不意味着所有任务都必须严格遵循这个流程。一个成熟的方法论，必然是灵活的，能够根据不同的场景进行调整。一个紧急的线上bug修复，和一个需要深思熟虑的新功能设计，它们的协作模式必然不同。

这就引出了我们最后一个话题：如何建立一个决策框架，来智能地选择与AI的协作模式。

## 第四幕：协作的艺术：一个决策框架

到目前为止，我们已经建立了一套可靠的结构化协作流程。但这套流程更像是一套精良的工具，而一个真正的工匠，需要知道何时使用锤子，何时使用凿子。

试图用同一种协作模式应对所有编程任务，是新手最常犯的错误，也是挫败感的来源。修复一个万分紧急的线上bug，与设计一个关乎未来的核心系统，这两者的协作方式必然截然不同。

经过不断的实践，我发现，决定我们应该如何与AI协作的，是两个最古老的项目管理维度：**重要性**和**紧急性**。它们构成了一个简单的四象限模型，可以帮助我们在几分钟内，为任何任务选择最合适的协作模式。

![](https://raw.githubusercontent.com/Miss-you/img/master/painting-tutorials/紧急重要.png)

#### 第一象限：重要 × 紧急 → 你是“外科医生”

* **场景**：线上生产故障、严重的安全漏洞。
* **模式**：在这里，风险控制是第一要务。你必须像一个主刀医生，保持绝对的控制。AI不是你的搭档，而是你手中的一把高精度手术刀。你的指令必须极其精准、范围极小。比如：“定位到这个函数，只允许修改这三行，增加一个空值判断，并生成一个能复现此问题的单元测试。” 我们的目标不是优雅，而是用最小的“创口”，最快地解决问题。

#### 第二象限：重要 × 不紧急 → 你是“总建筑师”

* **场景**：设计新功能、核心架构重构、性能优化。
* **模式**：这是最能体现结构化协作价值的地方。时间允许我们深思熟虑，追求高质量的交付。你扮演的是项目的总建筑师，而AI是你的设计合伙人。你们会花大量时间在“规划”阶段，共同探讨设计方案、明确接口、制定验收标准。你们建造的不是一个孤立的函数，而是一个完整的系统。在这里，AI的大局观和模式识别能力能发挥到极致。

#### 第三象限：不重要 × 紧急 → 你是“项目甲方”

* **场景**：一个一次性的数据导出脚本、一个临时的内部工具。
* **模式**：任务的唯一目标是“快”。代码质量、可维护性都不重要，因为它可能只运行一次。此时，你的角色就像一个甲方，向AI这个“外包团队”提出明确的需求。你告诉它输入是什么，想要的输出是什么，然后放手让它去实现。你只关心最终结果，不关心过程。

#### 第四象限：不重要 × 不紧急 → 你是“探索家”

* **场景**：学习一门新技术、验证一个新想法、进行概念验证（PoC）。
* **模式**：这里的目标不是交付一个产品，而是获得一个“结论”。为了避免无休止的探索，关键在于**设定时间盒**。你告诉AI：“我们有一个小时的时间，用这个新技术框架，帮我实现一个最简单的‘Hello World’版本。” 时间一到，探索立刻停止。你评估结果，然后做出决定：这个方向值得继续投入吗？在这里，AI是你的向导，而时间是你唯一的预算。

那么，在实际工作中，如何快速判断一个任务属于哪个象限，并决定协作的“放权”程度呢？

我不会用一个复杂的评分表，而是会在脑中进行一次快速的“风险评估”，问自己几个问题：
* **安全网有多强？**（测试覆盖率高吗？）
* **影响范围有多大？**（改动会波及多少模块？）
* **后悔药好不好吃？**（可以轻松回滚吗？）
* **目标清晰吗？**（需求有没有歧义？）

肯定回答越多，我越倾向于“建筑师”或“甲方”模式，给予AI更大的自主权。否定回答越多，我越会切换到“外科医生”模式，进行微操。

这个框架在实践中效果显著：
* 修复生产故障时，我像**外科医生**，10分钟内精准地修改了一个函数。
* 设计新用户系统时，我像**建筑师**，与AI深度共创，用一周时间交付了极其稳定的系统。
* 迁移历史数据时，我像**甲方**，让AI生成了200行的脚本，30分钟搞定。
* 调研新技术时，我像**探索家**，用一个上午得出结论，避免了团队后续数周的潜在浪费。

这个决策框架的价值在于，它将你从单一、僵化的工作流中解放出来，让你拥有了根据不同战场、选择不同战术的灵活性。

至此，我们已经完整地探讨了AI编程协作的“道”与“术”。我相信你心中可能还有最后一个问题：这一切会走向何方？作为工程师，我们今天的努力，在AI飞速演进的未来，还有价值吗？

## 结语：最后的想法

写下这篇文章时，我诚实地评估，自己依然是那个最终的“责任人”。尽管在我的大部分工作中，AI已经是不可或缺的副驾驶，但我仍然需要坐在主驾驶位上，进行指导、审查和决策。

我认为，本文分享的AI协作方法论的核心瓶颈在于：AI尚不具备一个可靠的“验证闭环”。

它能写代码，可以运行代码，但一个端到端的验证可能AI自己并不能理解或者无从下手。虽然AI可以解析执行结果，读懂图片，但还需要每次我手工将结果贴给它。这意味着，整个工作流中成本最高、也最关键的“验证”环节，仍然强依赖于人。

但我几乎可以确定，这个瓶颈很快就会被突破。个人推测，方向很可能就是测试驱动开发（TDD）与AI的结合。试想一下，未来的工作流是这样的：我们用自然语言定义一个需求和它的验收标准（测试用例），AI则进入一个“编写-测试-修正”的循环，直到所有测试用例通过。

当这个闭环完成时，AI将能真正自主地完成更复杂的任务。到那时，我们的角色也将彻底地从一个代码的“创作者”，转变为一个对AI工作进行规划、指导和验收的“管理者”。

面对这样的未来，焦虑是无用的。关键是想清楚，什么才是我们作为工程师，真正不可替代的价值。经过这几年的探索，我想分享我最终沉淀下来的几个看法。

首先，**方法论永远比工具重要**。今天我们讨论的是Claude Code，明天可能会有更强大的工具出现。但无论工具如何迭代，我们今天讨论的结构化协作流程、风险决策框架，其背后的工程思想是通用的。掌握了如何拆解问题、如何定义目标、如何验证结果，你就能自如地驾驭任何工具。

其次，**系统思维正在取代局部优化**。AI的出现，正在将“写代码”这件事本身商品化。我们的价值，不再体现在能多快地写出一个函数，而是体现在能否设计出一个健壮、可扩展的系统。真正的效率，来自于交付高质量解决方案的全周期速度，而非敲击键盘的速度。

最后，也是最重要的一点，**这无关竞争，而关乎合作**。AI不是一个需要我们去战胜的对手，它是我们思考能力的“放大器”。它能将我们从繁琐的实现细节中解放出来，让我们得以将全部的智力资源，投入到更上游、更有创造性的工作中去——定义问题、权衡取舍、做出决策。

回到最初的起点。从三年前，我让GPT写下第一个函数，到今天，我的大部分工作都深深地烙上了与AI协作的印记。我最大的感悟是：在这个时代，一个工程师最核心的竞争力，正在从“解决问题”的能力，迁移到“定义问题”和“设计解决方案”的能力。

掌握一门特定的语言或框架，其价值的半衰期正在急剧缩短。但那些更本质的能力——如何清晰地描述一个复杂的需求，如何系统性地设计一个稳固的架构，以及如何为最终结果定义一个可验证的衡量标准——无论技术如何变迁，都将是你最宝贵的资产。

这才是AI时代，工程师进化的真正方向。