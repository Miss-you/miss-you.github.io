技术分享
 个人 AI copilot 使用情况
  子主题
   一些AI协作的一些框架
  有什么不一样
   游戏领域，对于BUG容忍度非常低
    子主题
    子主题
 第一幕：PHP泥潭求生指南
  PHP泥潭
   请帮我查看一下这个目录下有多少个php文件，以及统计下总代码行数。不要泄露具体的代码文件和代码信息
   
  workshop demo1：coze查看的prompt
   纵览coze-studio
    本项目是coze-studio，Coze Studio：开源版的“智能体开发平台”，一站式可视化构建/调试/发布 Agent、App、工作流（低/无代码），并提供 OpenAPI 与 Chat SDK   集成；。我的问题是，请你快速纵览一下项目，找到项目中AI Agent最关键的部分，即ReAct的核心代码相关文件有哪几个
   纵览
    eino
     我的目标是，希望你快速找出本项目中AI Agent中的核心机制，即ReAct的核心相关的代码的关键代码文件，以及入口函数这是本项目的介绍：「它是什么来自 CloudWeGo/字节的 Go 语言 LLM/AI 应用开发框架：提供组件化能力 + 编排（Chain / Graph / Workflow），强调强类型、并发与流式处理，Apache-2.0 开源。GitHub能做什么（要点）组件体系：ChatModel、Tool、Retriever、Document Loader、Embedding、Indexer、PromptTemplate、Lambda 等，拿来即用、可拓展。GitHub三种编排 API：Chain（线性）、Graph（有/无环图，最灵活）、Workflow（结构化字段映射）。GitHub内置 ReAct Agent：现成实现（模型自主判断是否调 Tool→观察→再推理），基于 Graph 编排封装好回调/并发/类型检查。GitHubCloudWeGo生态集成：开箱对接 OpenAI、Volcengine ARK、Claude、Gemini、Ollama 等模型；Milvus/ES/Redis/VikingDB 等向量/检索；Bing/HTTP/Browser 等工具；还支持 Langfuse、APMPlus、CozeLoop 可观测回调。CloudWeGo+2CloudWeGo+2可视化 DevOps（IDE 插件）：在 GoLand 里做拖拽式编排并“一键生成为代码”，以及可视化调试任意节点。CloudWeGo+1」
   eino分析
    写prompt
     我的目标是希望你梳理当前项目中ReAct的关键逻辑，我的期望得到的结果是，AI Agent ReAct机制的核心流程的梳理，包括文字版、关键机制的接口文档、图「流程图或时序图」版本。最终期望的结果是markdown格式，图/时序图希望是mermaid结构##重要我希望你根据prompt“四要素框架”,写一个解决我问题的prompt，而不是立即回答我的问题：角色 (Role): 你是谁？—— 设定身份，决定语气和专业度。任务 (Task): 你要做什么？—— 明确的核心指令。背景 (Context): 为什么要做这个？—— 提供“为什么”，让AI理解意图。约束 (Constraints): 你要怎么做？—— 规定输出形式和边界。项目结构是这样：「核心入口函数  主要入口： flow/agent/react/react.go:186 - NewAgent() 函数  func NewAgent(ctx context.Context, config *AgentConfig) (_ *Agent, err error)  使用入口：  - flow/agent/react/react.go:380 - Agent.Generate()  - flow/agent/react/react.go:385 - Agent.Stream()  关键文件清单  核心实现文件  1. flow/agent/react/react.go - ReAct Agent主要实现    - 包含Agent结构体、NewAgent构造函数    - 实现ReAct循环逻辑：Chat → Tool Call → 观察 → 推理  2. flow/agent/react/option.go - 配置和选项    - 包含回调处理、工具配置、消息Future等  3. flow/agent/react/callback.go - 回调机制    - 构建Agent的回调处理器  核心机制  ReAct循环实现位置：  - flow/agent/react/react.go:233-297 - 图构建逻辑  - flow/agent/react/react.go:269-280 - 分支条件判断（决定是否调用工具）  - flow/agent/react/react.go:299-349 - 直接返回机制  关键组件：  - 基于Graph编排（compose.Graph）  - ChatModel节点：模型推理  - Tools节点：工具调用  - 状态管理：state 结构体存储消息历史  核心流程：  1. 用户输入 → ChatModel推理  2. 检查是否有ToolCall → 如有则执行工具  3. 工具结果 → 回到ChatModel继续推理  4. 直到没有ToolCall为止」
    prompt
     **角色 (Role):**你是一位资深的软件架构师，精通 Go 语言和 AI Agent 领域，尤其对 ReAct 模式有深入的理解。你擅长阅读代码结构、梳理复杂逻辑，并能将它们转化为清晰易懂的技术文档和图表。**任务 (Task):**你的任务是深入分析我提供的 Go 项目中 ReAct Agent 的核心实现逻辑，并生成一份清晰、全面的技术梳理文档。这份文档需要准确反映代码的实际工作流程。**背景 (Context):**我正在梳理我们项目中的 AI Agent 模块，需要一份标准的技术文档来帮助团队成员（包括新成员和资深开发者）快速理解其工作原理、关键组件和代码结构。这份文档将作为内部知识库的核心内容，用于新员工入职培训和后续的模块迭代。因此，文档的准确性、清晰度和结构化至关重要。**约束 (Constraints):**你必须严格按照以下要求输出，最终结果需要是一个完整的、格式规范的 Markdown 文件：1.  **整体结构**: 文档必须包含以下三个部分，并严格按照顺序组织：    *   第一部分：ReAct 核心流程梳理（文字版）    *   第二部分：关键机制的接口文档    *   第三部分：ReAct 核心流程图（Mermaid 结构）2.  **内容要求**:    *   **核心流程梳理（文字版）**:        *   从 `NewAgent()` 初始化开始，说明 Agent 是如何被构建的。        *   详细描述 `Generate()` 或 `Stream()` 方法被调用后，ReAct 循环的完整工作流程。        *   重点解释系统如何利用 `compose.Graph` 来编排流程。        *   清晰说明在 `react.go:269-280` 处的条件判断逻辑，即如何决定是直接返回还是调用工具。        *   描述工具调用（Tools 节点）后，其输出（观察结果）如何再次进入 `ChatModel` 节点形成闭环。        *   解释 `state` 结构体在整个流程中是如何传递和管理消息历史的。    *   **关键机制的接口文档**:        *   使用类似 Go doc 的风格，为以下关键组件创建伪代码接口文档：        *   `Agent` 结构体：描述其核心字段。        *   `NewAgent(ctx context.Context, config *AgentConfig)` 函数：描述其输入、输出和主要作用。        *   `Agent.Generate()` / `Agent.Stream()` 方法：描述其功能和调用方式。        *   `state` 结构体：描述其在 ReAct 循环中承载的关键信息（如消息历史）。    *   **ReAct 核心流程图**:        *   必须使用 Mermaid 语法。        *   建议使用流程图（`graph TD`）来清晰地展示各个节点（用户输入、ChatModel、条件分支、工具调用、最终输出）之间的流转关系。        *   图中需要明确标注出 ReAct 的核心循环部分。3.  **信息来源**:    *   所有分析都必须严格依据我提供的文件路径和功能描述，不得引入项目之外的概念或进行不相关的联想。
    梳理结果
     https://www.processon.com/markdown_editor/68b2a65d618f2e05725dda0e?from=pwa
  思考
   为什么ai copilot可以即便不依赖于代码rag技术，也可以对代码解读的比较清晰正确？
    agentic search
    比喻
   prompt为什么这么写？
    prompt最佳实践的基本结构输出图片自己更容易理解
   为什么提高了效率？
    整个任务的耗时被极大缩短了；也减少了对其他同事的打断，两个人都获得了效率提升
   举一反三
    不仅仅是一个存量代码，参与开源项目、做一个新的任务、学习一门新的知识，其门槛都是类似的大大降低
 第二幕：告别 Vibe Coding
  Explore → Plan → Code → Commit
   子主题
  思考
   为什么“Explore → Plan → Code → Commit”靠谱?
    子主题
     本质类似于：减少hallucination
   做个人项目时，为什么这样的结构是必要的？
    就像大家日常工作中也更多的是要与一个巨大的项目打交道，而不是快速完成一个用完即弃的demo以前大家刷题、写代码；现在可能则是练习将软件工程的理念应用到vibe coding中，或者说是如何去管理ai
   提升效率的点
    1. 自己不熟悉的领域，可以借助ai快速达到junior的水平2. 独立的事情，cc几乎可以做到脱手独立完成3. 日常重复的事情，可以再借助ai去自动化和加速4. 随着这样日常练习的积累，会发现做类似的事情越来越快
   举一反三
    不仅仅是存量代码开发功能、修复bug；实现一个小工具「比如翻译书籍的工具」，一个数据的分析的脚本，一个爬取数据的脚本，或者数据分析用的sql，或者是一个简单的ui，都可以借助cc来完成
  workshop demo2：
   review
    /review-fast-go
     ---description: Quick diff hygiene check for Go before commit# 只白名单需要的命令；有的工具可能未安装，命令里都做了 || true 以免报错中断allowed-tools: Bash(git status:*), Bash(git diff:*), Bash(go:*), Bash(gofmt:*), Bash(golangci-lint:*), Bash(staticcheck:*)argument-hint: "[path...]  (可选：仅审查这些路径/包)"---## Context# 工作区、改动文件与 diff（支持可选路径参数；没传参数就全仓）- Working tree: !`git status -sb`- Changed files: !`git diff --name-only --diff-filter=ACMRT HEAD -- $ARGUMENTS 2>/dev/null || git diff --name-only --diff-filter=ACMRT HEAD`- Diff: !`git diff HEAD -- $ARGUMENTS 2>/dev/null || git diff HEAD`# Go 快速体检（都允许失败，不阻断命令执行）- Format (gofmt -l): !`gofmt -l . || true`- Vet: !`go vet ./... || true`- Build (编译校验): !`go build ./... || true`- Lint (可选，若安装了 golangci-lint): !`golangci-lint run ./... || true`- Staticcheck (可选): !`staticcheck ./... || true`## TaskAct as a senior Go reviewer. Based ONLY on the diff and signals above:1) **显眼问题（应秒回）**     - 拼写/风格/明显逻辑错误（越界、空指针、死分支等）     - API surface 变更（导出标识符、方法签名、错误类型变更、兼容性风险）2) **Go 特有易错点**     - **error 处理**：确保不吞错；必要时用 `%w` 包装；建议使用 `errors.Is/As`；不要用 `panic` 替代错误返回     - **context 传递**：入参位置、下传、取消/超时是否被尊重（尤其是 I/O、RPC、DB）     - **并发**：goroutine 泄露、通道关闭/发送/接收顺序、竞态、`time.After` 泄露、锁复制/死锁     - **资源管理**：`defer` 关闭文件/连接/`resp.Body`/`rows`；检查 `rows.Err()`     - **接收者与可变性**：值/指针接收者是否一致；避免复制含 `sync.Mutex` 的结构体     - **性能小雷**：热路径中的多次分配/`fmt.Sprintf`；循环里 `defer`；字符串拼接 vs `strings.Builder`     - **JSON/YAML**：反序列化是否考虑未知字段、零值/必填校验     - **数据库**：一律参数化查询，避免字符串拼接；事务/上下文是否正确管理3) **测试与文档**     - 是否需要/更新表驱动测试；关键边界条件用 fuzz 测试是否更合适     - 公开函数/包的注释与 README 是否需要同步### Output（严格按此格式）- **Checklist**：每条一行 → `[severity][file:line] message`（severity 取 `high|medium|low`）  - **Suggested fix**：必要处给最小补丁（可用 unified diff 片段）  - **Verdict**：`GREEN|YELLOW|RED` + 1–2 行理由（若 RED，指明必须改的条目）### Constraints- 仅基于提供的 diff 和上述信号做判断；**不要**臆测未给出的代码。- 控制在精炼的清单与最小必要说明；优先给“可立即落地”的修改建议。
    /review-deep-go
     ---description: Context-aware deep Go review on changed entrypoints (diff→context→call graph)argument-hint: "[path...]  或  symbol=Pkg.Func（可选）"# 列出会被用到的 Bash 子命令；未安装的工具不会中断（命令里都带了 || true）allowed-tools: Bash(git diff:*), Bash(rg:*), Bash(go:*), Bash(ctags:*), Bash(sort:*), Bash(uniq:*), Bash(dirname:*), Bash(xargs:*), Bash(awk:*), Bash(sed:*), Bash(cat:*), Bash(wc:*)---## Context bootstrap# A. 变更范围- Changed files: !`git diff --name-only --diff-filter=ACMRT HEAD -- $ARGUMENTS 2>/dev/null || git diff --name-only --diff-filter=ACMRT HEAD`- Go changed files: !`git diff --name-only --diff-filter=ACMRT HEAD | rg '\.go$' || true`- Changed dirs: !`git diff --name-only --diff-filter=ACMRT HEAD | rg '\.go$' | xargs -n1 dirname | sort -u || true`# B. 导出符号/入口（从 diff 提取）- Exported decls in diff: !`git diff -U0 HEAD -- $ARGUMENTS 2>/dev/null | rg '^[+]\s*(func|type|const|var)\s+([A-Z]\w*)' -n || true`- main packages touched: !`rg -n '^package main$' $(git diff --name-only --diff-filter=ACMRT HEAD | rg '\.go$' | xargs -n1 dirname | sort -u) 2>/dev/null || true`# C. 典型入口线索（HTTP/gRPC/CLI）- HTTP handlers: !`rg -n '(http\.Handle(Func)?|ServeHTTP|router\.(GET|POST|PUT|DELETE|PATCH)|mux\.Handle)' -g '!**/*_test.go' -g '!**/vendor/**' || true`- gRPC services: !`rg -n 'Register\w+Server\(|grpc\.NewServer\(' -g '!**/*_test.go' -g '!**/vendor/**' || true`- Cobra commands: !`rg -n 'cobra\.Command\s*{\s*Use:' -g '!**/*_test.go' -g '!**/vendor/**' || true`# D. 并发与上下文线索- Concurrency patterns: !`rg -n '(^|[^\w])go\s+|<-|sync\.(Mutex|RWMutex|WaitGroup)|atomic\.' -g '!**/*_test.go' -g '!**/vendor/**' || true`- Context usage: !`rg -n 'context\.With(Timeout|Cancel|Deadline)|\bcontext\.Context\b' -g '!**/*_test.go' -g '!**/vendor/**' || true`# E. 可选：tags/粗粒度调用者检索（若工具可用）- ctags: !`ctags -R --languages=Go . >/dev/null 2>&1 || true`- Approx callers of changed exported funcs: !`git diff -U0 HEAD | rg '^[+]\s*func\s+([A-Z]\w*)' -o -r '$1' | sort -u | xargs -I{} rg -n '\b{}\s*\(' -g '!**/*_test.go' -g '!**/vendor/**' || true`# F. 相关文档（存在则加载）- Root README: !`[ -f README.md ] && cat README.md || true`- Architecture: !`[ -f docs/architecture.md ] && cat docs/architecture.md || true`## TaskYou are a senior Go reviewer. Using ONLY the evidence above:1) 识别**受影响入口点**（HTTP/gRPC/CLI/main/导出 API），给出“入口 → 受影响调用链（≤3 跃点）”的概要（含 file:line）。2) 对每个入口按路径逐项检查：不变量/边界条件、错误处理、context 传递与超时、资源释放、并发安全/竞态、性能热路径。3) 为每条问题标注 **severity: high|medium|low**，并给出**最小修补建议**（必要时附小块 unified diff）。4) 指出需要或缺失的测试（表驱动、并发/超时、fuzz）与文档更新点。5) 若上下文不足，先列出你需要追加的证据（具体文件/函数/命令输出）。## Output- Per-entrypoint:  - Summary（一句话）  - Findings（多条，含 file:line 引用）  - Suggested patch（可选，小补丁）- Global checklist（high/medium/low 计数）- Final verdict: GREEN | YELLOW | RED + 1–2 行理由
  “心法”
   工作流：比如探索、规划、编码、提交工作流
   利用prompt工程最佳实践，提升一次性生成结果的成功率：
    包括few shot、明确的描述、prompt的管理和复用、CLAUDE.md配置
   自动化
    短命令配置，发现日常工作中重复度高的工作，比如代码重构、代码review「编译、lint、语义/语法、调用关系逻辑」
 自己的一个具体的例子
  翻出来自己之前的一个epub翻译工具，很久之前vibe coding的项目了。现在有些忘得差不多
 有用本次未提到的部分
  两种开发模式
   1. 测试驱动开发(TDD)模式
   2. 视觉辅助（截图）开发模式
  四种具体可以明显改进的做法
   /clear 上下文管理
   明确告诉Claude要操作哪些具体文件
   多Claude实例协作
    写文档-写代码-写单测/e2e-代码review
   思考模式使用
    think、think hard、ultrathink
    ## 思考模式偏好  - 对于架构问题，默认使用 think hard 模式  - 对于调试问题，使用标准 think 模式  - 对于系统设计，使用 ultrathink 模式
  拓展阅读/ref
   https://www.anthropic.com/engineering/claude-code-best-practices?utm_source=chatgpt.com
 一些其他的例子
  自动化代码codereview
  思考和举一反三
   子主题
   类似的panic问题，可以交给claude code分析出类似代码
    分析结果
     1. chatsvr/dao/im_lottery_official.go (3处)                                      - 第122、164、211行：直接使用 updateRet.MatchedCount                          2. chatsvr/dao/im_group_update.go (2处)                                         - 第309、348行：直接使用 updateRes.MatchedCount                               3. chatsvr/dao/im_group_forbidden.go (2处)                                      - 第62、171行：直接使用 updateRes.MatchedCount                                4. yoyogo/repo/dao/find_partner.go (3处)                                        - 第208、708、1401行：直接使用 updateRes.MatchedCount 或 result.ModifiedCount 5. yoyogo/repo/dao/find_partner_apply.go (1处)                                  - 第200行：直接使用 update.MatchedCount                                       6. yoyogo/repo/dao/find_partner_reco_cache.go (4处)                             - 第169、266、314、422行：直接使用 updateReq.MatchedCount                     7. gamebroker/repo/dao/dao_impl.go (1处)                                        - 第337行：直接使用 result.ModifiedCount
   挺适合做这种举一反三的检索的。因为人来做的话搜索是比较慢
  现在有一些常用的命令，每次用的时候还需要申请。我希望默认不需要申请权限
   比如git diff/git status我就觉得完全没问题；git add、commit/rm之类的就有些危险
   linux命令中、grep、mkdir就没什么问题， 但是rm就比较有风险
   我应该如何配置呢？
  还有一个配置.
   /model中，可以选择如何让ai工作。我发现效果好的时候，应该是选择/model 4，默认让opus来规划任务。sonnet工作。
    这个也需要配置
     /model 
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                   │
│  Select Model                                                                                                                                                     │
│  Switch between Claude models. Applies to this session and future Claude Code sessions. For custom model names, specify with --model.                             │
│                                                                                                                                                                   │
│     1. Default (recommended)  Opus 4.1 for up to 20% of usage limits, then use Sonnet 4                                                                           │
│     2. Opus                   Opus 4.1 for complex tasks · Reaches usage limits faster                                                                            │
│     3. Sonnet                 Sonnet 4 for daily use                                                                                                              │
│   ❯ 4. Opus Plan Mode         Use Opus 4.1 in plan mode, Sonnet 4 otherwise✔
 FAQ
  子主题
 欢迎交流
  我自己向观众的提问
   除了LLM御三家「GPT、Gemini、Claude」，生图生视频工具「可灵、Midj、Veo3等」，现在还在一直订阅着的AI Agent应用有什么？
  指挥ai写prompt的prompt
   我希望你根据prompt“四要素框架”,写一个解决我问题的prompt：角色 (Role): 你是谁？—— 设定身份，决定语气和专业度。任务 (Task): 你要做什么？—— 明确的核心指令。背景 (Context): 为什么要做这个？—— 提供“为什么”，让AI理解意图。约束 (Constraints): 你要怎么做？—— 规定输出形式和边界。
  拓展阅读
   https://www.anthropic.com/engineering/claude-code-best-practices?utm_source=chatgpt.com
 自动化ai工作流的构建
  prompt积累
   请你生成可维护性好的commit log并提交
  方案探索？
   【大模型训练的“下半场”：基于NPU的Agent SFT+GRPO实战】
 要点
  AI Coding 实践经验  熟练使用Claude Code/Cursor等工具提升研发效能，日常工作的 80%的代码是由AI生成。正在探索使用AI Coding工具进一步提升工作产出的方法 文章与思考  对Anthropic Claude Code使用报告的分析   https://mp.weixin.qq.com/s/zrsVXsmcpg-iwjw4aF0dmw  使用cursor进行代码重构的思考   https://mp.weixin.qq.com/s/PSKuOZW3ijJ098rQzGjWbg个人对于aicoding提升研发效能的实践和思考三点：核心观点解读您思考的精髓在于，您没有停留在“AI 能帮我写什么代码”的表层，而是深入到了“我应该如何管理和驱动 AI 来完成高质量的软件开发工作”的层面。这背后最重要的，就是您反复提及的几个关键点：1. 工作流（Workflow）：为 AI Copilot 设定“章法”这是您思考中最具价值的部分。您提出的 Explore → Plan → Code → Commit 工作流，本质上是将传统软件工程的最佳实践应用到了人机协作中。为什么重要？ 因为大语言模型本身存在“幻觉”（Hallucination），直接“Vibe Coding”很容易写出看似正确但实际有问题的代码。一个结构化的工作流，就像给 AI 加上了“护栏”和“导航”，让它在可控的路径上输出，极大提升了生成结果的准确性和可靠性。如何体现？Explore & Plan：强制自己和 AI 先思考、再动手。这不仅能让 AI 更好地理解需求，也能帮助您理清思路。AI 在这个阶段可以快速调研、提供多种方案，成为您的“技术参谋”。Code & Commit：将编码和提交环节标准化，利用您提到的自动化 Code Review 工具（/review-fast-go, /review-deep-go），确保每一段 AI 生成的代码都经过了质量检查，符合工程规范。2. Prompt 工程：提升与 AI 沟通的“带宽”和“精度”如果说工作流是“章法”，那 Prompt 就是指挥 AI 的“语言”。您对于 Prompt 的思考已经非常深入，特别是“四要素框架”（角色、任务、背景、约束），这是目前业界公认的最佳实践。为什么重要？ 精准的 Prompt 能最大程度地减少沟通偏差，让 AI 一次性生成更符合预期的结果，避免反复修改。这直接关系到效率。如何体现？eino 分析案例：您通过一个具体的例子，展示了如何构造一个高质量的 Prompt 来让 AI 分析复杂的代码库。这个过程本身就是一个极佳的实践案例，说明了好的 Prompt 如何将一个模糊的需求（“帮我看看这个项目”）转化为一个可执行的、能产出高质量结果的任务。减少对他人的打扰：这一点非常关键。过去需要打断资深同事才能获得的知识（例如“这个项目的 ReAct 核心逻辑在哪？”），现在可以通过精准的 Prompt 让 AI 在几分钟内完成。这不仅仅是您个人的效率提升，更是整个团队总效率的提升。3. 自动化（Automation）：将“最佳实践”固化为“生产力工具”您的思考中充满了自动化的思想，从自动化的 Code Review 到各种可以复用的短命令，再到对 .claude.md 文件的配置。为什么重要？ 自动化是将个人零散的、高效的实践，沉淀为团队可复用、可扩展的生产力工具的关键。它能将“高手”的经验，赋能给团队中的每一个人。如何体现？自动化 Code Review：您设计的 /review-fast-go 和 /review-deep-go 命令，就是将一个资深 Go 开发者的 Review 思路和检查点，固化成了一个可执行的工具。这不仅能发现潜在问题，更重要的是，它能反向“教会”初级开发者什么是好的代码。常用命令配置：您思考了哪些命令（如 git diff）应该是默认授权的，哪些（如 rm）需要谨慎。这体现了在追求效率的同时，也考虑到了安全性，这是工程成熟度的体现。模型选择策略：您提出的 /model 4 策略（Opus 规划，Sonnet 执行），是对 AI 工具本身特点的深刻理解。这是更高级的“自动化”，即根据任务的复杂性自动选择最合适的“员工”去完成，实现了成本和效率的最佳平衡。