Claude Code：代理式编程最佳实践

Claude Code 是一款用于代理式编程（agentic coding）的命令行工具。本文将介绍一些经过实践证明行之有效的技巧，适用于在不同代码库、编程语言和环境中使用 Claude Code。

我们最近发布了 Claude Code，这是一款用于代理式编程的命令行工具。Claude Code 最初作为研究项目开发，为 Anthropic 的工程师和研究人员提供了一种将 Claude 模型无缝整合进编码工作流程的原生方式。Claude Code 有意被设计得比较底层且对使用方式不设限，它提供了接近原始模型的访问能力，不强制你遵循固定的工作流程。这种设计理念使 Claude Code 成为一个灵活、可定制、可通过脚本操控且安全的强大工具。然而，尽管功能强大，对于初次接触此类代理式编程工具的工程师来说，这种灵活性可能意味着需要一定的学习适应过程——至少在摸索出适合自己的最佳实践之前会是如此。

本文概述了一些通用模式。这些模式已经被证明对 Anthropic 内部团队以及外部工程师在各种代码库、语言和环境中使用 Claude Code 都卓有成效。当然，这里的建议并非放之四海而皆准；请将它们视作起点，根据自身情况进行调整。我们鼓励你大胆尝试，寻找最适合自己的使用方法！

想了解更详细的信息？可以查阅我们完整的 Claude Code 文档（位于 claude.ai/code），其中涵盖了本文提到的所有功能，并提供更多示例、实现细节和高级技巧。

1. 定制你的设置

Claude Code 是一个代理式编程助手，它会自动将相关上下文信息加入提示中。这种上下文收集虽然强大，但会消耗时间和 token。不过，你可以通过调整环境配置来优化这一过程。

a. 创建 CLAUDE.md 文件

CLAUDE.md 是一个特殊的文件。每当开始新的对话时，Claude 都会自动将该文件内容作为上下文纳入提示。因此，它非常适合用来记录以下信息：

常用的 Bash 命令

核心文件和实用函数

代码风格规范

测试指南

仓库协作约定（例如：分支命名规范、合并或 rebase 的使用策略等）

开发环境的设置说明（例如：Python 版本管理工具的使用、可用的编译器等）

本项目中特有的异常行为或警告

其他你希望 Claude 牢记的重要信息

CLAUDE.md 文件没有固定的格式要求。我们建议将内容保持简洁且易读。例如：

# Bash命令
- npm run build：构建项目  
- npm run typecheck：运行类型检查

# 代码风格
- 使用 ES 模块（import/export）语法，不使用 CommonJS（require）  
- 尽可能使用解构导入（例如：import { foo } from 'bar'）

# 工作流程
- 在完成一系列代码更改后，一定要运行类型检查  
- 为提升性能，尽量只运行单个测试，而非整个测试套件


你可以将 CLAUDE.md 文件放置在多个位置：

代码仓库的根目录（或者你运行 claude 命令的目录，这是最常见的方式）。将文件命名为 CLAUDE.md 并提交到 Git（推荐这样团队成员之间可共享），或者命名为 CLAUDE.local.md 并将其加入 .gitignore（不提交到版本库）。

运行 claude 命令的目录的任意父目录下。这对**单体仓库（monorepo）**很有用。例如，你在 root/foo 目录下运行 claude，而在 root/CLAUDE.md 和 root/foo/CLAUDE.md 都存在配置文件。这两个文件都会被自动纳入上下文。

运行 claude 命令目录的任意子目录下。这与上类似，但方向相反。在这种情况下，当你处理某个子目录中的文件时，Claude 会按需加载该子目录下的 CLAUDE.md 文件作为上下文。

你的主目录下（~/.claude/CLAUDE.md）。这个文件对你所有的 Claude 会话全局生效。

当你运行 /init 命令时，Claude 会自动为你生成一个默认的 CLAUDE.md 文件。

b. 调整你的 CLAUDE.md 文件

CLAUDE.md 文件的内容会成为 Claude 提示的一部分，因此你应该像优化常用提示词那样去打磨它们。一个常见的错误是往里面添加了大量内容，却没有反复实验以验证其效果。请花时间进行试验，找出哪些内容能让模型更好地遵循指令。

你可以手动编辑 CLAUDE.md 文件添加内容，或者在会话中按下 # 键，给 Claude 一条指令让它自动将该指令加入相关的 CLAUDE.md 文件。许多工程师在编程时频繁使用 # 来记录新的命令、文件说明和风格指南，然后将 CLAUDE.md 的更改包含在提交中，这样团队成员也能同步获益。

在 Anthropic，我们有时会使用提示优化工具（prompt improver）来改进 CLAUDE.md 文件的内容，并经常通过调整措辞（例如添加“IMPORTANT”或“YOU MUST”等强调词）来提高模型遵循指令的程度。

c. 管理 Claude 的工具许可清单

默认情况下，Claude Code 在执行任何可能修改系统的操作时都会请求权限，例如写入文件、执行大多数 Bash 命令、调用 MCP 工具等。这种谨慎的设计是为了优先确保安全。你可以根据需要自定义允许清单（allowlist），添加你确信安全的工具，或者允许一些潜在不安全但容易撤销的操作（例如文件编辑、git commit 等）。

管理允许使用的工具有四种方法：

在会话中当出现权限提示时，选择 “Always allow”（始终允许）。

启动 Claude Code 后，使用 /permissions 命令添加或移除允许清单中的工具。例如，添加 Edit 可始终允许文件编辑；添加 Bash(git commit:*) 可允许执行 git commit；或者添加 mcp__puppeteer__puppeteer_navigate 可允许通过 Puppeteer MCP 服务器进行浏览。

手动编辑你的配置文件 .claude/settings.json 或 ~/.claude.json（我们建议将前者纳入版本控制，以便与你的团队共享）。

对于单次会话，使用命令行参数 --allowedTools 为该会话指定允许的工具。

d. 如果使用 GitHub，请安装 GitHub CLI（gh）

Claude 知道如何使用 GitHub CLI 工具 gh 与 GitHub 交互，例如创建 Issue、打开 Pull Request、读取评论等等。如果没有安装 gh，Claude 仍然可以使用 GitHub API 或 MCP 服务器（如果已安装）来完成类似操作，但安装 gh 会使这些操作更加顺畅。

2. 为 Claude 提供更多工具

Claude 可以访问你的 shell 环境，你可以像为自己配置开发环境一样，为它准备各种方便的脚本和函数。Claude 也可以通过 MCP 和 REST API 利用更复杂的外部工具。

a. 将 Claude 与 Bash 工具配合使用

Claude Code 会继承你的 Bash 环境，因此能够使用你系统中的所有命令行工具。需要注意的是，Claude 虽然了解常用的 Unix 工具和 gh 等命令，但对于你自定义的 Bash 工具，如果你不提供说明，Claude 并不知道它们的存在。你可以按以下步骤让 Claude 认识你的自定义工具：

告诉 Claude 工具的名称，并提供其用法示例。

让 Claude 运行该工具的 --help 命令，以查看工具的帮助文档。

将常用工具的说明记录在 CLAUDE.md 文件中供 Claude 参考。

b. 将 Claude 与 MCP 配合使用

Claude Code 既可以作为 MCP 服务器运行，也可以充当 MCP 客户端。作为客户端，它可通过三种方式连接多个 MCP 服务器，以使用那些服务器提供的工具：

项目配置中：在项目的配置文件中指定 MCP 服务器（当你在该目录下运行 Claude Code 时，即可使用）。

全局配置中：在全局配置中指定（使这些工具在你所有项目中都可用）。

提交到仓库的 .mcp.json 文件：将 MCP 服务器信息写入仓库中的 .mcp.json 文件（这样任何在该代码库上工作的人都能直接使用其中配置的工具）。例如，你可以在 .mcp.json 中添加 Puppeteer 和 Sentry 服务器，这样每个在该代码库上协作的工程师都能立即使用这些服务。

使用 MCP 时，建议以 --mcp-debug 参数启动 Claude，以帮助识别任何配置问题。

c. 使用自定义斜杠命令

对于一些需要重复执行的工作流程（例如反复调试、日志分析等），可以将提示模板保存为 Markdown 文件，放在 .claude/commands 文件夹下。这些模板会作为斜杠命令出现在 Claude Code 中：当你在对话中键入/时，它们将出现在命令菜单中。你可以把这些命令文件提交到 git 仓库中，让团队其他成员也能使用。

此外，自定义斜杠命令可以使用特殊占位符 $ARGUMENTS，将命令调用时输入的参数传递给模板。

例如，下面是一个可用于自动获取并修复 GitHub Issue 的斜杠命令模板：

请分析并修复这个 GitHub Issue：$ARGUMENTS。

请按照以下步骤操作：

1. 使用 `gh issue view` 查看 Issue 详情  
2. 理解 Issue 中描述的问题  
3. 在代码库中搜索相关文件  
4. 实现必要的代码更改来修复该问题  
5. 编写并运行测试来验证修复效果  
6. 确保代码通过 lint 检查和类型检查  
7. 撰写有描述性的提交消息  
8. 推送代码并创建一个 PR

请记住，所有 GitHub 相关的操作都要使用 GitHub CLI（`gh`）。


将上述内容保存为 .claude/commands/fix-github-issue.md 之后，它就会作为 /project:fix-github-issue 命令在 Claude Code 中提供。然后，你可以使用诸如 /project:fix-github-issue 1234 这样的命令，让 Claude 修复编号为 1234 的 Issue。类似地，你也可以将自定义命令文件放入 ~/.claude/commands 文件夹下，这样这些命令在你所有的会话中都可用。

3. 尝试常见的工作流程

Claude Code 并不限定你使用它的具体流程，你可以灵活地按自己的方式使用它。在这种灵活性所提供的空间中，我们的用户社区总结出了几种有效使用 Claude Code 的常见模式：

a. 探索、计划、编码、提交

这种通用的工作流程适用于许多问题类型：

探索 (Explore)：让 Claude 阅读相关的文件、图像或 URL。你可以给出笼统的指示（例如：“读取处理日志的文件”），也可以指定具体的文件名（例如：“读取 logging.py 文件”）。但是要明确告诉它暂时不要编写任何代码。

提示： 在这个步骤，你可以考虑充分利用 子代理（subagents），尤其当问题比较复杂时。你可以指示 Claude 使用子代理来核实细节或调查它在思考时产生的特定疑问（尤其在会话或任务的一开始）。这样做可以在不显著降低效率的情况下，帮助 Claude 保留更多上下文供后续使用。

计划 (Plan)：让 Claude 制定解决问题的计划。我们建议使用关键词 “think” 触发扩展思考模式，它会给予 Claude 更多的思考时间，从而更深入地评估各种方案。这些特定短语在系统中对应着递增的思考预算等级：“think” < “think hard” < “think harder” < “ultrathink”。每提升一个等级，Claude 可用于思考的“预算”都会相应增加。

如果这一阶段 Claude 给出的计划看起来合理，你可以让 Claude 将计划记录到一个文档或一个 GitHub Issue 中。这样，如果接下来的实现阶段（步骤 3）的结果不尽如人意，你还能回到这一步的计划重新开始。

编码 (Code)：让 Claude 用代码实现它的解决方案。在这一阶段，你也可以要求它在实现各部分的同时主动检查自己的方案是否合理。

提交 (Commit)：让 Claude 提交代码并创建一个 Pull Request。如果有必要，这是提醒 Claude 更新相关的 README 或变更日志并解释所做改动的好时机。

请特别注意，上述第1步和第2步非常关键——如果跳过它们，Claude 通常会直接跳到编写代码解决问题。尽管有时你希望它立即开始写代码，但对于那些需要深入思考的问题，先让 Claude 调研并规划会显著提升效果。

b. 编写测试并提交；编码、迭代、提交

对于那些可以通过单元测试、集成测试或端到端测试轻松验证的代码改动，这是 Anthropic 内部非常推崇的一种流程。当代理式编程与**测试驱动开发（TDD）**相结合时，效率会大幅提升：

编写测试：让 Claude 根据预期的输入/输出对编写测试用例。一定要明确告知它你正在进行测试驱动开发，这样即使对于代码库中尚不存在的功能，它也会避免提前编写相应的模拟实现。

运行测试：让 Claude 运行测试，并确认测试确实失败。在此阶段，清楚地告诉它不要编写任何实现代码通常会有所帮助。

提交测试：当你对编写的测试用例感到满意后，让 Claude 提交这些测试代码。

实现代码并迭代：让 Claude 编写使测试通过的代码，指示它不要修改测试。告诉 Claude 持续尝试，直到所有测试通过。通常 Claude 需要经过几轮循环（编写代码 -> 运行测试 -> 调整代码 -> 再次运行测试）才能让所有测试通过。

在这个阶段，你可以让一个独立的子代理验证实现是否过度拟合了测试（即检查 Claude 是否只是为了通过测试而编写了特定代码，而不是真正解决问题）。

提交代码：当你对代码改动感到满意时，让 Claude 提交代码。

Claude 在有明确的目标可以迭代时表现最佳——无论这个目标是视觉设计稿、测试用例，还是其他形式的预期输出。通过提供诸如测试这类明确的期望结果，Claude 可以在比较结果的基础上不断调整代码，逐步改进，直到成功满足要求。

c. 编写代码、截图结果、反复迭代

和测试驱动的流程类似，你可以为 Claude 提供视觉目标：

获取截图能力：提供一种方法让 Claude 获取浏览器截图（例如使用 Puppeteer MCP 服务器、iOS 模拟器 MCP 服务器，或者手动将截图复制/粘贴给 Claude）。

提供视觉草稿：提供给 Claude 一份视觉设计稿作为参考，可以通过复制粘贴或拖拽一张图片到 Claude，或者直接提供图像文件路径。

编码并比对：让 Claude 根据设计稿实现代码，截取结果的截图，并不断迭代，直到界面效果与设计稿相匹配。

提交代码：当你对最终结果满意时，让 Claude 提交代码。

和人类一样，Claude 的输出经过多次迭代后会显著改善。首次生成的结果也许不错，但经过两三轮的改进通常会更趋完美。为 Claude 提供查看自身输出结果的途径，有助于它不断优化，达到最佳效果。

d. 安全的 YOLO 模式

如果你不想全过程监督 Claude，可以使用 claude --dangerously-skip-permissions 命令跳过所有权限检查，让 Claude 一路不受干预地运行直到完成。这对于修复 lint 错误或生成样板代码等任务特别有效。

然而，让 Claude 任意执行命令是有风险的，可能导致数据丢失、系统损坏，甚至数据泄露（例如通过提示注入攻击）。为了尽可能降低风险，建议仅在无联网的受控容器中使用 --dangerously-skip-permissions 模式。你可以参考一个 Docker 开发容器的示例实现，来确保在相对安全的环境下运行此模式。

e. 代码库问答（Q&A）

当你开始熟悉一个新的代码库时，可以使用 Claude Code 来辅助学习和探索。你可以问 Claude 一些在结对编程时可能向同事请教的问题。Claude 会以代理的方式搜索代码库，来回答一些常见的广泛问题，例如：

日志功能是如何实现的？

我该如何创建一个新的 API 接口？

在 foo.rs 文件的第134行，async move { ... } 这段代码的作用是什么？

类 CustomerOnboardingFlowImpl 处理了哪些边缘情况？

为什么我们在第333行调用了 foo() 而不是 bar()？

在 Java 里，如何实现与 baz.py 文件第334行等价的功能？

在 Anthropic，使用 Claude Code 以这种方式进行代码库问答已成为我们新员工入职培训的核心环节。这大大缩短了新人熟悉代码的时间，也减轻了其他工程师的指导负担。而且这种用法不需要特殊的提示！你只需直接提出问题，Claude 就会自行搜索代码来找到答案。

f. 利用 Claude 与 Git 交互

Claude 可以高效处理许多 Git 操作。Anthropic 有很多工程师在超过 90% 的情况下都用 Claude 来进行 Git 交互：

查询历史记录：搜索 Git 提交历史，以回答类似“v1.2.3 版本包含了哪些更改？”，“哪个人负责这个功能？”或者“这个 API 当初为什么这样设计？”等问题。在询问此类问题时，明确让 Claude 查阅 Git 历史记录会有所帮助。

撰写提交信息：Claude 会自动查看你的更改和近期的提交记录，并综合相关上下文撰写提交消息。这样可以确保提交说明涵盖所有重要细节。

处理复杂操作：Claude 能处理一些复杂的 Git 操作，比如还原文件、更改、解决 rebase 冲突，以及比较或合并补丁等。

g. 利用 Claude 与 GitHub 交互

Claude Code 能够管理许多 GitHub 上的工作：

创建 Pull Request：Claude 理解 “pr” 这种 Pull Request 的简写，并会根据代码差异（diff）和上下文自动生成合适的提交消息。

一键处理简单的代码审查意见：对于 Pull Request 上简单的代码审查评论，你可以直接让 Claude 修正 PR 中提到的问题（必要时也可以给出更具体的指导）。Claude 修复后会将更新推送回 PR 的分支。

修复构建失败或 linter 报警：当持续集成显示构建未通过或存在代码风格警告时，Claude 可以找出问题并进行修复。

分类和筛选 Issue：你可以让 Claude 循环遍历所有未解决的 GitHub Issue，对它们进行分类、标记优先级等。这可以大大减少手动管理 Issue 的负担。

通过 Claude 来处理上述事务，你不再需要记忆繁琐的 gh 命令行语法，就能够自动化完成许多日常任务。

h. 利用 Claude 操作 Jupyter 笔记本

在 Anthropic，一些研究人员和数据科学家使用 Claude Code 来读取和编辑 Jupyter 笔记本。Claude 能够理解笔记本的输出（包括图表图像），这为快速探索和分析数据提供了一种高效方式。使用 Claude 操作笔记本并没有固定的提示或流程要求，但我们推荐的做法是：在 VS Code 中将 Claude Code 窗口和 .ipynb 笔记本文件并排打开，方便交互。

在将笔记本分享给同事之前，你还可以让 Claude 帮忙整理笔记本内容或美化其中的输出。例如，你可以明确要求它使笔记本或其中的图表“更美观”。这样提示往往能提醒 Claude 优化输出，使其更符合人类审美，便于展示。

4. 优化你的工作流程

以下建议适用于所有使用 Claude Code 的工作场景：

a. 提供明确的指令

指令越具体清晰，Claude Code 第一次就成功完成任务的概率就越高。提前给出清楚的指导，可以减少过程中反复修正的需要。

例如，对同一个任务，不同表达方式的效果差异：

不佳： 为 foo.py 添加测试。
更好： 为 foo.py 编写一个新的测试用例，涵盖用户未登录时的边界情况，并避免使用模拟对象（mock）。

不佳： 为什么 ExecutionFactory 的 API 这么奇怪？
更好： 查看 ExecutionFactory 的 Git 历史记录，整理出它的 API 是如何演变至今的。

不佳： 添加一个日历组件。
更好： 先查看主页上已有组件的实现方式，了解它们遵循的模式，尤其要注意代码与界面是如何分离的（HotDogWidget.php 是一个很好的示例）。然后按照相同的模式实现一个新的日历组件，使用户能够选择月份，并通过前后翻页来选择年份。从头开始编写代码，除项目中已有的库外不使用其他库。

Claude 可以揣测你的意图，但终究无法真正读心。指令越具体，Claude 的输出就越能符合你的期望。

b. 为 Claude 提供图像

Claude 非常善于利用图像和示意图。你可以通过以下几种方式向 Claude 提供视觉信息：

粘贴截图。（小技巧：在 macOS 上，按下 Cmd + Ctrl + Shift + 4 将截图保存到剪贴板，然后按 Ctrl + V 将其粘贴到 Claude 中。注意，这里不要用常规的 Cmd + V 粘贴，该方法无法用于远程连接场景。）

拖放图片。 将图片文件直接拖拽到 Claude 提示的输入框中。

提供文件路径。 告诉 Claude 图像文件的路径。

在进行 UI 开发需要对照设计稿，或者分析调试需要参考可视化图表时，这些方法都特别有用。即使在没有提供视觉资料的情况下，你也可以明确告诉 Claude，你希望结果在视觉上达到怎样的效果或美观程度。

c. 指明你希望 Claude 查看的文件

利用 Tab 键的自动补全功能，可以快速引用仓库中的文件或文件夹路径，从而帮助 Claude 定位并查找或更新正确的资源文件。这能确保 Claude 关注的正是你想要它处理的文件。

d. 提供 URL 给 Claude

在提示中附上特定的网页 URL，Claude 就能获取该网页内容并阅读。若你频繁从同一域名获取网页（例如反复访问某个文档网站 docs.foo.com），可以使用 /permissions 命令将该域名加入允许清单，从而避免每次都弹出权限确认，节省时间。

e. 尽早且频繁地纠偏

虽然自动接受模式（按下 Shift + Tab 切换）允许 Claude 自主连续地执行任务，但通常作为用户你主动参与协作、引导 Claude 的思路，会得到更好的结果。最理想的情况是在一开始就把任务详尽地解释清楚，但过程中你依然可以随时纠正 Claude 的方向。以下四种方法有助于你及时地纠偏：

让 Claude 先制定计划。 在真正编写代码前，要求 Claude 先列出解决思路，并明确告诉它在你认可计划之前不要开始编码。

使用 Escape 中断。 在 Claude 执行过程中的任何阶段（无论它正在“思考”、调用工具，还是编辑文件），按下 Escape 键可以中断它的操作，同时保留当前上下文，以便你可以调整指令或提供进一步指导。

双击 Escape 回滚并重试。 快速按两下 Escape 键可以跳回对话历史中的上一条提示，让你修改之前的指令并尝试不同的方向。你可以多次编辑同一条提示并重新运行，直到得到满意的结果。

让 Claude 撤销更改。 你可以指示 Claude 撤销最近的修改，然后结合上面提到的第二点，再尝试采取不同的方法解决问题。

尽管 Claude Code 偶尔第一次尝试就能完美解决问题，但通常使用以上纠偏手段会更快地获得更优的解决方案。

f. 使用 /clear 保持上下文专注

在长时间的会话过程中，Claude 的上下文窗口可能逐渐堆积许多无关的聊天记录、文件内容和命令历史。这些无关信息不仅会降低 Claude 的运行效率，有时还会让 Claude 偏离主题。因此，建议在完成一个阶段的任务后，经常使用 /clear 命令清空上下文，以确保 Claude 在新的任务中专注于相关内容。

g. 在复杂工作流程中使用清单和草稿本

对于步骤繁多或需要穷尽式解决方案的大型任务——例如框架迁移、修复大量 lint 错误、运行复杂的构建脚本等——你可以让 Claude 使用一个 Markdown 文件（甚至 GitHub Issue）作为待办清单和临时草稿本，来提高执行效率。

举例来说，如果要修复大量的 lint 错误，可以这样做：

收集问题：让 Claude 运行 lint 命令，并将所有出现的错误（包含文件名和行号）汇总写入一个 Markdown 格式的清单中。

逐一解决：指示 Claude 按清单逐条解决问题。每修复并验证完一个错误，就把清单中对应项标记为完成，然后再处理下一个问题。

通过这种方式，Claude 会像在人脑中列出清单一样，有条理地逐步攻克复杂任务。

h. 向 Claude 提供数据

有多种方法可以将数据提供给 Claude：

直接粘贴。 将数据直接复制粘贴到对话提示中（这是最常用的方法）。

通过管道传输。 使用操作系统管道将数据输送给 Claude Code（例如运行 cat foo.txt | claude），这对日志、CSV 或其它大型数据特别有用。

命令提取。 让 Claude 通过 Bash 命令、MCP 工具或自定义斜杠命令来自行提取所需数据。

读取文件或 URL。 直接要求 Claude 打开指定文件或抓取指定 URL（图像文件也支持这种方式）。

在实际使用中，这些方法通常是组合起来用的。比如，你可以先通过管道传入一份日志文件，然后再告诉 Claude 使用某个工具获取额外的上下文信息，以协助诊断日志中的问题。

5. 使用无人交互模式自动化基础设施

Claude Code 提供了无人交互模式（headless mode），适用于 CI、预提交钩子、构建脚本等非交互式场景。通过使用 -p 参数加上提示文本，可以让 Claude Code 在无人值守的情况下执行预定任务；结合 --output-format stream-json 参数，则可以让输出以流式 JSON 格式呈现，方便后续处理。

请注意，无人交互模式在不同会话之间不会保持激活状态——每次新会话你都需要再次触发它。

a. 使用 Claude 自动分类 Issue

无人交互模式可以驱动基于 GitHub 事件的自动化工作流。例如，当你的仓库中新建一个 Issue 时触发自动处理。实际案例：公开的 Claude Code 项目仓库就使用 Claude 来检查新创建的 Issue，并自动为其分配合适的标签。也就是说，Claude 会在后台读取 Issue 内容，根据内容判断应该加上什么标签，从而实现 Issue 的自动分类与归档。

b. 将 Claude 用作代码检查工具

Claude Code 可以进行一些主观的代码审查，发现传统 lint 工具难以检测的问题，例如拼写错误、陈旧过时的注释、有误导性的函数或变量命名等等。相当于让 Claude 充当一个智能的代码审阅者，辅助你提高代码质量。

6. 通过多个 Claude 协同工作提升效率

除了单独使用一个 Claude 实例之外，一些最强大的应用场景涉及并行运行多个 Claude 实例：

a. 一个 Claude 编写代码，另一个 Claude 验证

一种简单但有效的方法是：一个 Claude 编写代码，另一个 Claude 审查或测试。这类似于多位工程师协作，有时让 AI 拥有各自独立的上下文反而更有优势。你可以按以下步骤进行：

使用第一个 Claude来编写代码。

代码编写过程中，打开另一个终端标签页并启动第二个 Claude（或者也可以在第一个会话中使用 /clear 清空上下文后，当作第二个实例）。

让第二个 Claude 审查第一位 Claude 写的代码（阅读代码并进行代码评审或测试）。

视需要再启动第三个 Claude（或者在第二个会话中再次 /clear）来同时查看代码和评审反馈。

让这个 Claude（第三个实例）根据第二个 Claude 的反馈编辑代码。

类似地，你也可以将这一思路应用于测试场景：让一个 Claude 编写测试，然后让另一位 Claude 编写代码使测试通过。甚至，你可以让多个 Claude 实例相互“交流”：为它们提供各自独立的草稿本或中间文档，一个 Claude 将结果写入其中，另一个 Claude 从中读取并接续工作。通过让不同实例各司其职且共享成果，这种分离往往比让单个 Claude 包办所有工作得到的结果更好。

b. 使用多个仓库检出版本并行作业

与其让一个 Claude 顺序完成每个步骤，Anthropic 的许多工程师选择并行地进行工作：

将同一个代码仓库检出（checkout）出 3～4 份副本，放在不同的文件夹路径下。

将每个检出版本分别在不同的终端标签页中打开。

在每个文件夹中分别启动 Claude，并令每个实例处理不同的任务。

轮流查看各个 Claude 实例的进展，并根据需要批准或拒绝它们的权限请求。

通过这种方式，你无需等待单个 Claude 按顺序完成所有事情，而是可以并行推进多个任务，大幅提高整体开发速度。

c. 使用 Git 工作树（worktree）

Git 的工作树功能非常适合同时进行多个彼此独立的任务，它比创建多个仓库副本更加轻量。Git 工作树允许你在单个仓库中同时检出多个分支到不同目录。每个工作树都有自己独立的工作目录和文件，但共享同一套 Git 历史记录和 reflog。

利用 Git 工作树，你可以针对同一个项目开启多个 Claude 会话，每个会话专注于项目的不同部分、执行各自独立的任务。例如，你可以让一个 Claude 重构认证系统，同时让另一个 Claude 构建一个完全不相关的数据可视化模块。由于这些任务互不冲突，每个 Claude 都能全速运转，无需等待彼此的更改，也不必处理合并冲突的问题：

创建工作树：运行 git worktree add ../project-feature-a feature-a（在仓库外的新路径创建名为 feature-a 的分支工作树）。

在每个工作树目录中启动 Claude：例如 cd ../project-feature-a && claude。

按需创建更多工作树（在新的终端标签页重复执行上述步骤 1 和 2）。

一些小提示：

为各个工作树目录使用一致的命名规范，方便区分。

保持“一份工作树对应一个终端标签页”的习惯，避免混淆。

如果你在 Mac 上使用 iTerm2，建议设置通知提醒，这样当某个 Claude 需要你授权或操作时会提示你。

针对不同的工作树，最好在 IDE 中开不同的窗口，便于并行查看。

完成任务后记得清理：使用 git worktree remove ../project-feature-a 来移除相应的工作树目录，避免留下多余的文件夹。

d. 将无人交互模式与自定义脚本结合使用

通过 claude -p 命令（启用无人交互模式），你可以以编程方式将 Claude Code 集成到更大的工作流中，同时利用它内置的工具和系统提示。使用无人交互模式有两种主要模式：

分发执行（Fanning out）：适用于大型迁移或分析任务（例如分析数百份日志的情感，或处理上千个 CSV 文件）。具体步骤：

先让 Claude 编写一个脚本，用于生成任务列表。例如，列出 2000 个需要从框架 A 迁移到框架 B 的文件清单。

然后编写主脚本遍历这些任务，使用编程方式针对每个任务调用一次 Claude，给它提供相应的任务描述和允许使用的工具集合。举例来说：
claude -p "将 foo.py 从 React 迁移到 Vue。完成后，若成功请返回字符串 OK；若失败请返回字符串 FAIL。" --allowedTools Edit Bash(git commit:*)

多次运行该脚本，并根据结果逐步优化提示词，直到获得理想的输出。

流水线（Pipelining）：将 Claude 集成到已有的数据/处理流水线中。具体做法：

使用管道符调用 Claude，例如：claude -p "<你的提示>" --json | your_command，其中 your_command 是管道中下一步要执行的命令。Claude 的输出将作为输入传递给后续命令。

就这样完成了链路！如果使用 JSON 格式输出（通过 --json 参数），可以方便地利用结构化数据，简化后续自动处理。

无论以上哪种用法，在调试阶段都可以加上 --verbose 参数以便查看 Claude 执行过程中的详细日志信息。而在实际生产环境中，我们建议关闭 verbose 模式，以保持输出简洁。

你在使用 Claude Code 时还有哪些技巧和最佳实践？欢迎在社交媒体上 @AnthropicAI 与我们分享，让我们也能了解到你正在构建的精彩项目！