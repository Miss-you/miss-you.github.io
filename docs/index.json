[{"categories":null,"content":"perf 使用教程 ","date":"2020-11-25","objectID":"/perf/:0:0","tags":["profile","perf"],"title":"perf 入门教程（待补充和完善）","uri":"/perf/"},{"categories":null,"content":"perf 简介 Perf 是 Linux kernel 中的系统性能优化工具，perf 基本原理的话是在 CPU 的 PMU register 中 Get/Set performance counters 来获得诸如 instructions executed，cache-missed suffered，branches mispredicted 等信息。 perf 本身的工具有很多，这里主要介绍个人在查询程序性能问题时使用的一些工具 包括 perf list、perf stat、perf record、perf report ","date":"2020-11-25","objectID":"/perf/:1:0","tags":["profile","perf"],"title":"perf 入门教程（待补充和完善）","uri":"/perf/"},{"categories":null,"content":"perf list 使用 perf 之前肯定要知道 perf 能监控哪些性能指标吧？那么就要使用 perf list 进行查看，通常使用的指标是 cpu-clock/task-clock 等，具体要根据需要来判断 $ perf list List of pre-defined events (to be used in -e): cpu-cycles OR cycles [Hardware event] instructions [Hardware event] … cpu-clock [Software event] task-clock [Software event] context-switches OR cs [Software event] … ext4:ext4_allocate_inode [Tracepoint event] kmem:kmalloc [Tracepoint event] module:module_load [Tracepoint event] workqueue:workqueue_execution [Tracepoint event] sched:sched_{wakeup,switch} [Tracepoint event] syscalls:sys_{enter,exit}_epoll_wait [Tracepoint event] … 不同内核版本列出的结果不一样多。.. 不过基本是够用的，但是无论多少，我们可以基本将其分为三类 Hardware Event 是由 PMU 硬件产生的事件，比如 cache 命中，当您需要了解程序对硬件特性的使用情况时，便需要对这些事件进行采样 Software Event 是内核软件产生的事件，比如进程切换，tick 数等 Tracepoint event 是内核中的静态 tracepoint 所触发的事件，这些 tracepoint 用来判断程序运行期间内核的行为细节，比如 slab 分配器的分配次数等 具体监控哪个变量的话，譬如使用后面的 perf report 工具，则加**-e 监控指标**，如 perf report -e cpu-clock ls 监控运行 ls 命令时的 cpu 时钟占用监控 ","date":"2020-11-25","objectID":"/perf/:2:0","tags":["profile","perf"],"title":"perf 入门教程（待补充和完善）","uri":"/perf/"},{"categories":null,"content":"perf stat 刚刚知道了可以监控哪些事件，但是事件这么多，该如何下手呢？ 解决问题的时候有条理才解决的更快，所以面对一个性能问题的时候，最好采用自顶向下的策略。先整体看看该程序运行时各种统计事件的大概，再针对某些方向深入细节。而不要一下子扎进琐碎细节，会一叶障目的。 整体监测代码性能就需要使用 perf stat 这个工具，该工具主要是从全局上监控，可以看到程序导致性能瓶颈主要是什么原因。因为不同的程序导致其性能瓶颈的原因不同，譬如有些程序慢是由于计算量大，而有些程序是由于频繁的 I/O 导致性能瓶颈，他们的优化方式不同。perf stat 通过概括精简的方式提供被调试程序运行的整体情况和汇总数据。 使用方法 perf stats 程序 譬如 perf stat ./gw --gtpu-ip 172.31.24.58 --sgw-s11-ip 172.31.24.250 --zmq-ip 172.31.31.174 --sgi-if eth1 --teid 1 --mysql 172.31.20.157 -cgw 程序运行完之后，然后使用 ctrl+c 来终止程序（若程序自动终止则不用），之后，perf 便会打印出监控事件结果，类似结果如下： Performance counter stats for './gw --gtpu-ip 172.31.24.58 --sgw-s11-ip 172.31.24.250 --zmq-ip 172.31.31.174 --sgi-if eth1 --teid 1 --mysql 172.31.20.157 -cgw': 1773.651816 task-clock (msec) # 0.016 CPUs utilized 79,054 context-switches # 0.045 M/sec 757 cpu-migrations # 0.427 K/sec 16,368 page-faults # 0.009 M/sec \u003cnot supported\u003e cycles \u003cnot supported\u003e stalled-cycles-frontend \u003cnot supported\u003e stalled-cycles-backend \u003cnot supported\u003e instructions \u003cnot supported\u003e branches \u003cnot supported\u003e branch-misses 109.795527410 seconds time elapsed 1773.651816 task-clock 是指程序运行期间占用了 xx 的任务时钟周期，该值高，说明程序的多数时间花费在 CPU 计算上而非 IO 79,054 context-switches 是指程序运行期间发生了 xx 次上下文切换，记录了程序运行过程中发生了多少次进程切换，频繁的进程切换是应该避免的。（有进程进程间频繁切换，或者内核态与用户态频繁切换） 757 cpu-migrations 是指程序运行期间发生了 xx 次 CPU 迁移，即用户程序原本在一个 CPU 上运行，后来迁移到另一个 CPU 16,368 page-faults 是指程序发生了 xx 次页错误 其他可以监控的譬如分支预测、cache 命中等 ","date":"2020-11-25","objectID":"/perf/:3:0","tags":["profile","perf"],"title":"perf 入门教程（待补充和完善）","uri":"/perf/"},{"categories":null,"content":"perf record 前面通过 perf stat 获得了程序性能瓶颈类型，之后，假设你已经知道哪个进程需要优化**（若不知道则需要使用 perf top 进行进一步监控，这里由于个人没有使用过，所以不作介绍）**，那么下一步就是对该进程进行细粒度的分析，分析在长长的程序代码中究竟是哪几段代码、哪几个函数需要修改呢？**这便需要使用 perf record 记录单个函数级别的统计信息，并使用 perf report 来显示统计结果。** 调优应该将注意力集中到百分比高的热点代码片段上，假如一段代码只占用整个程序运行时间的 0.1%，就算将其优化到仅剩一条机器指令，恐怕也只能将整体的程序性能提高 0.1%。 好钢用在刀刃上 仍以之前的 gw 程序为例，假设要监控的指标为 cpu-clock perf record -e cpu-clock -g ./gw --gtpu-ip 172.31.24.58 --sgw-s11-ip 172.31.24.250 --zmq-ip 172.31.31.174 --sgi-if eth1 --teid 1 --mysql 172.31.20.157 -cgw -g 选项是告诉 perf record 额外记录函数的调用关系，因为原本 perf record 记录大都是库函数，直接看库函数，大多数情况下，你的代码肯定没有标准库的性能好对吧？除非是针对产品进行特定优化，所以就需要知道是哪些函数频繁调用这些库函数，通过减少不必要的调用次数来提升性能 -e cpu-clock 指 perf record 监控的指标为 cpu 周期 程序运行完之后，perf record 会生成一个名为 perf.data 的文件（缺省值），如果之前已有，那么之前的 perf.data 文件会变为 perf.data.old 文件 获得这个 perf.data 文件之后，我们其实还不能直接查看，下面就需要 perf report 工具进行查看 ","date":"2020-11-25","objectID":"/perf/:4:0","tags":["profile","perf"],"title":"perf 入门教程（待补充和完善）","uri":"/perf/"},{"categories":null,"content":"perf report 前面通过perf record工具获得了某一进程的指标监控数据 perf.data，下面就需要使用perf report工具查看该文件 使用方法 perf report -i perf-report 生成的文件 譬如 perf report -i perf.data 上面使用perf record获得的数据的结果如下 + 4.93% gw libcurl-gnutls.so.4.3.0 [.] 0x000000000001e1e0 + 4.93% gw [kernel.kallsyms] [k] eventfd_write + 2.96% gw [kernel.kallsyms] [k] ipt_do_table + 2.46% gw [kernel.kallsyms] [k] xen_hypercall_event_channel_op ? 1.97% gw libc-2.19.so [.] _int_malloc + 1.97% gw libc-2.19.so [.] __clock_gettime ? 1.97% gw gw [.] nwGtpv2cHandleInitialReq(NwGtpv2cStack*, unsigned int, MqPackage\u0026) ? 1.97% gw [kernel.kallsyms] [k] pvclock_clocksource_read ? 1.97% gw [kernel.kallsyms] [k] ip_finish_output ? 1.97% gw [kernel.kallsyms] [k] ixgbevf_xmit_frame + 1.48% gw [kernel.kallsyms] [k] kmem_cache_alloc_trace ? 1.48% gw [kernel.kallsyms] [k] sk_run_filter [.] 代表该调用属于用户态，若自己监控的进程为用户态进程，那么这些即主要为用户态的 cpu-clock 占用的数值，[k] 代表属于内核态的调用。 也许有的人会奇怪为什么自己完全是一个用户态的程序为什么还会统计到内核态的指标？一是用户态程序运行时会受到内核态的影响，若内核态对用户态影响较大，统计内核态信息可以了解到是内核中的哪些行为导致对用户态产生影响；二则是有些用户态程序也需要依赖内核的某些操作，譬如 I/O 操作 /+ 4.93% gw libcurl-gnutls.so.4.3.0 [.] 0x000000000001e1e0 ，左边的加号代表 perf 已经记录了该调用关系，按 enter 键可以查看调用关系，不过由于这个是动态库里的函数，基本查看到的都是一些二进制数值：P perf 监控 gw 进程结果记录到很多内核调用，说明 gw 进程在运行过程中，有可能被内核态任务频繁中断，应尽量避免这种情况，对于这个问题我的解决办法是采用绑核，譬如机器有 8 个 CPU，那么我就绑定内核操作、中断等主要在 0-5CPU，GW 由于有两个线程，分别绑定到 6、7CPU 上 ","date":"2020-11-25","objectID":"/perf/:5:0","tags":["profile","perf"],"title":"perf 入门教程（待补充和完善）","uri":"/perf/"},{"categories":null,"content":"实践 这里使用我在实验中程序在某一场景 CPU 占用率飙升的问题作为示例 ","date":"2020-11-25","objectID":"/perf/:6:0","tags":["profile","perf"],"title":"perf 入门教程（待补充和完善）","uri":"/perf/"},{"categories":null,"content":"1.perf stat 整体定位性能瓶颈 CPU 飙升场景与正常场景使用 perf stat 对比差异 执行 perf stat ./gw --gtpu-ip 172.31.24.58 --sgw-s11-ip 172.31.24.250 --zmq-ip 172.31.31.174 --sgi-if eth1 --teid 1 --mysql 172.31.20.157 -cgw CPU 飙升场景 Performance counter stats for './gw --gtpu-ip 172.31.24.58 --sgw-s11-ip 172.31.24.250 --zmq-ip 172.31.31.174 --sgi-if eth1 --teid 1 --mysql 172.31.20.157 -cgw': 1773.651816 task-clock (msec) # 0.016 CPUs utilized 79,054 context-switches # 0.045 M/sec 757 cpu-migrations # 0.427 K/sec 16,368 page-faults # 0.009 M/sec \u003cnot supported\u003e cycles \u003cnot supported\u003e stalled-cycles-frontend \u003cnot supported\u003e stalled-cycles-backend \u003cnot supported\u003e instructions \u003cnot supported\u003e branches \u003cnot supported\u003e branch-misses 109.795527410 seconds time elapsed 正常场景 Performance counter stats for './gw --gtpu-ip 172.31.24.58 --sgw-s11-ip 172.31.24.250 --zmq-ip 172.31.31.174 --sgi-if eth1 --teid 1 --mysql 172.31.20.157 -cgw': 1186.728996 task-clock (msec) # 0.018 CPUs utilized 78,284 context-switches # 0.066 M/sec 69 cpu-migrations # 0.058 K/sec 16,368 page-faults # 0.014 M/sec \u003cnot supported\u003e cycles \u003cnot supported\u003e stalled-cycles-frontend \u003cnot supported\u003e stalled-cycles-backend \u003cnot supported\u003e instructions \u003cnot supported\u003e branches \u003cnot supported\u003e branch-misses 64.456003339 seconds time elapsed 通过对比可以发现： task-clock 异常场景比正常场景占用率高许多，说明程序 CPU 占用率提升 cpu-migrations 异常场景比正常场景占用率高许多，说明进程发生了较频繁的从一个 CPU 迁移到另一个 CPU ","date":"2020-11-25","objectID":"/perf/:6:1","tags":["profile","perf"],"title":"perf 入门教程（待补充和完善）","uri":"/perf/"},{"categories":null,"content":"2.perf record+perf report 单点定位进程本身问题 通过 perf stat 整体上监控进程性能问题之后，使用 perf record 等对进程本身进行监控 执行 perf record -e task-clock -g ./gw --gtpu-ip 172.31.24.58 --sgw-s11-ip 172.31.24.250 --zmq-ip 172.31.31.174 --sgi-if eth1 --teid 1 --mysql 172.31.20.157 -cgw perf report -i perf.data 结果如下 root@ip-172-31-24-250:/home/ubuntu/EPC/gw# + 4.93% gw libcurl-gnutls.so.4.3.0 [.] 0x000000000001e1e0 + 4.93% gw [kernel.kallsyms] [k] eventfd_write + 2.96% gw [kernel.kallsyms] [k] ipt_do_table + 2.46% gw [kernel.kallsyms] [k] xen_hypercall_event_channel_op ? 1.97% gw libc-2.19.so [.] _int_malloc + 1.97% gw libc-2.19.so [.] __clock_gettime ? 1.97% gw gw [.] nwGtpv2cHandleInitialReq(NwGtpv2cStack*, unsigned int, MqPackage\u0026) ? 1.97% gw [kernel.kallsyms] [k] pvclock_clocksource_read ? 1.97% gw [kernel.kallsyms] [k] ip_finish_output ? 1.97% gw [kernel.kallsyms] [k] ixgbevf_xmit_frame + 1.48% gw [kernel.kallsyms] [k] kmem_cache_alloc_trace ? 1.48% gw [kernel.kallsyms] [k] sk_run_filter ? 1.48% gw [kernel.kallsyms] [k] fib_table_lookup ? 1.48% gw [kernel.kallsyms] [k] _raw_spin_unlock_irqrestore ? 0.99% gw libpthread-2.19.so [.] __libc_fcntl + 0.99% gw libc-2.19.so [.] vfprintf ? 0.99% gw libc-2.19.so [.] malloc ? 0.99% gw libc-2.19.so [.] free ? 0.99% gw libc-2.19.so [.] inet_ntop ? 0.99% gw libc-2.19.so [.] inet_pton + 0.99% gw [vdso] [.] 0x0000000000000ca1 ? 0.99% gw [kernel.kallsyms] [k] __do_softirq ? 0.99% gw [kernel.kallsyms] [k] ksize ? 0.99% gw [kernel.kallsyms] [k] kfree + 0.99% gw [kernel.kallsyms] [k] fput ? 0.99% gw [kernel.kallsyms] [k] d_alloc_pseudo ? 0.99% gw [kernel.kallsyms] [k] sys_socket ? 0.99% gw [kernel.kallsyms] [k] datagram_poll ? 0.99% gw [kernel.kallsyms] [k] skb_network_protocol + 0.99% gw [kernel.kallsyms] [k] __dev_queue_xmit libcurl-gnutls.so.4.3.0 它本身功能是一个数据上报，但是占用较高的 CPU，说明调用该库存在问题（代码本身问题），需要对调用该库的代码进行检查 libc-2.19.so [.] _int_malloc 这是常用的 malloc 操作，由于对代码比较熟悉，在这个过程中不应该有这么多次申请内存，说明代码本身有问题，需要对申请动态内存的代码进行检查 __clock_gettime 这个是由于计时需要，需要频繁获取时间，通常是指 gettimeofday() 函数 整个统计显示有很多 task-clock 占用是由于** kernel.kallsyms **导致，同时也验证了对 perf stat 获得的数据的初步判断，即 CPU 飙升也与频繁的 CPU 迁移（内核态中断用户态操作）导致，解决办法是采用 CPU 绑核 perf 工具很好用，要善用这个利器 ","date":"2020-11-25","objectID":"/perf/:6:2","tags":["profile","perf"],"title":"perf 入门教程（待补充和完善）","uri":"/perf/"},{"categories":null,"content":"自我提问 perf 是什么？ perf 能解决什么样的问题？什么样的问题无法解决？为什么？ 如何理解 perf 的探针？在 C++/C/Go/Rust 场景下，这些探针有代表什么含义呢？ perf 是如何统计的？perf 的探测机制是什么？为什么 perf 的探测对性能影响有限？ 使用上，perf 可以衡量哪些指标？针对于什么语言？针对于哪些问题可以评估？可以绘制哪些图？ 后起之秀 bcc/ebpf 与 perf 的取舍？ perf 的哪些机制值得学习？如何使用 perf？能够用 perf 解决什么样的问题？perf 对应指标分别是什么？如何理解这些指标？perf 解决问题的技巧？perf 是如何统计数据的？perf 为什么统计数据可以比较高性能？perf 的局限性有哪些？perf 与后起之秀的 pk？ 一些具体的场景和案例 ","date":"2020-11-25","objectID":"/perf/:7:0","tags":["profile","perf"],"title":"perf 入门教程（待补充和完善）","uri":"/perf/"},{"categories":null,"content":"本文主要分享火焰图使用技巧，介绍 systemtap 的原理机制，如何使用火焰图快速定位性能问题原因，同时加深对 systemtap 的理解。","date":"2020-11-25","objectID":"/flame/","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":" 本文主要分享火焰图使用技巧，介绍 systemtap 的原理机制，如何使用火焰图快速定位性能问题原因，同时加深对 systemtap 的理解。 让我们回想一下，曾经作为编程新手的我们是如何调优程序的？通常是在没有数据的情况下依靠主观臆断来瞎蒙，稍微有些经验的同学则会对差异代码进行二分或者逐段调试。这种定位问题的方式不仅耗时耗力，而且还不具有通用性，当遇到其他类似的性能问题时，需要重复踩坑、填坑，那么如何避免这种情况呢？ 俗语有云：“工欲善其事，必先利其器。”个人认为，程序员定位性能问题也需要一件“利器”。 如同医生给病人看病，需要依靠专业的医学工具（比如 X 光片、听诊器等）进行诊断，最后依据医学工具的检验结果快速精准地定位出病因所在。性能调优工具（比如 perf / gprof 等）之于性能调优就像 X 光之于病人一样，它可以一针见血地指出程序的性能瓶颈。 但是常用的性能调优工具 perf 等，在呈现内容上只能单一地列出调用栈或者非层次化的时间分布，不够直观。这里我推荐大家配合使用火焰图，它将 perf 等工具采集的数据呈现得更为直观。 ","date":"2020-11-25","objectID":"/flame/:0:0","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"初识火焰图 火焰图（Flame Graph）是由 Linux 性能优化大师 Brendan Gregg 发明的，和所有其他的 profiling 方法不同的是，火焰图以一个全局的视野来看待时间分布，它从底部往顶部，列出所有可能导致性能瓶颈的调用栈。 火焰图整个图形看起来就像一个跳动的火焰，这就是它名字的由来。 火焰图有以下特征（这里以 on-cpu 火焰图为例）： 每一列代表一个调用栈，每一个格子代表一个函数； 纵轴展示了栈的深度，按照调用关系从下到上排列，最顶上格子代表采样时，正在占用 cpu 的函数； 横轴的意义是指：火焰图将采集的多个调用栈信息，通过按字母横向排序的方式将众多信息聚合在一起。需要注意的是它并不代表时间； 横轴格子的宽度代表其在采样中出现频率，所以一个格子的宽度越大，说明它是瓶颈原因的可能性就越大； 火焰图格子的颜色是随机的暖色调，方便区分各个调用信息； 其他的采样方式也可以使用火焰图， on-cpu 火焰图横轴是指 cpu 占用时间，off-cpu 火焰图横轴则代表阻塞时间； 采样可以是单线程、多线程、多进程甚至是多 host，进阶用法可以参考附录 进阶阅读； ","date":"2020-11-25","objectID":"/flame/:1:0","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"火焰图类型 常见的火焰图类型有 On-CPU，Off-CPU，还有 Memory，Hot/Cold，Differential 等等。他们分别适合处理什么样的问题呢？ 这里笔者主要使用到的是 On-CPU、Off-CPU 以及 Memory 火焰图，所以这里仅仅对这三种火焰图作比较，也欢迎大家补充和斧正。 ","date":"2020-11-25","objectID":"/flame/:1:1","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"火焰图分析技巧 纵轴代表调用栈的深度（栈桢数），用于表示函数间调用关系：下面的函数是上面函数的父函数； 横轴代表调用频次，一个格子的宽度越大，越说明其可能是瓶颈原因； 不同类型火焰图适合优化的场景不同，比如 on-cpu 火焰图适合分析 cpu 占用高的问题函数，off-cpu 火焰图适合解决阻塞和锁抢占问题； 无意义的事情：横向先后顺序是为了聚合，跟函数间依赖或调用关系无关；火焰图各种颜色是为方便区分，本身不具有特殊含义； 多练习：进行性能优化有意识的使用火焰图的方式进行性能调优（如果时间充裕）； ","date":"2020-11-25","objectID":"/flame/:1:2","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"如何绘制火焰图？ 要生成火焰图，必须要有一个顺手的动态追踪工具，如果操作系统是 Linux 的话，那么通常通常是 perf 或者 systemtap 中的一种。其中 perf 相对更常用，多数 Linux 都包含了 perf 这个工具，可以直接使用；SystemTap 则功能更为强大，监控也更为灵活。网上关于如何使用 perf 绘制火焰图的文章非常多而且丰富，所以本文将以 SystemTap 为例。 SystemTap 是动态追踪工具，它通过探针机制，来采集内核或者应用程序的运行信息，从而可以不用修改内核和应用程序的代码，就获得丰富的信息，帮你分析、定位想要排查的问题。SystemTap 定义了一种类似的 DSL 脚本语言，方便用户根据需要自由扩展。不过，不同于动态追踪的鼻祖 DTrace ，SystemTap 并没有常驻内核的运行时，它需要先把脚本编译为内核模块，然后再插入到内核中执行。这也导致 SystemTap 启动比较缓慢，并且依赖于完整的调试符号表。 使用 SystemTap 绘制火焰图的主要流程如下： 安装 SystemTap 以及 操作系统符号调试表 根据自己所需绘制的火焰图类型以及进程类型选择合适的脚本 生成内核模块 运行 SystemTap 或者运行生成的内核模块统计数据 将统计数据转换成火焰图 本文演示步骤将会基于操作系统 Tlinux 2.2 ( Linux 内核版本 3.10.107) ","date":"2020-11-25","objectID":"/flame/:2:0","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"安装 SystemTap 以及 操作系统符号调试表 使用 yum 工具安装 systemtap: yum install systemtap systemtap-runtime 由于 systemtap 工具依赖于完整的调试符号表，而且生产环境不同机器的内核版本不同（虽然都是 Tlinux 2.2 版本，但是内核版本后面的小版本不一样，可以通过 uname -a 命令查看）所以我们还需要安装 kernel-debuginfo 包、 kernel-devel 包 我这里是安装了这两个依赖包 kernel-devel-3.10.107-1-tlinux2-0046.x86_64 kernel-debuginfo-3.10.107-1-tlinux2-0046.x86_64 ","date":"2020-11-25","objectID":"/flame/:2:1","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"根据自己所需绘制的火焰图类型以及进程类型选择合适的脚本 使用 SystemTap 统计相关数据往往需要自己依照它的语法，编写脚本，具有一定门槛。幸运的是，github 上春哥（agentzh）开源了两组他常用的 SystemTap 脚本：openresty-systemtap-toolkit 和 stapxx，这两个工具集能够覆盖大部分 C 进程、nginx 进程以及 Openresty 进程的性能问题场景。 我们这里需要绘制 off-cpu 火焰图，所以使用 sample-bt-off-cpu 脚本即可 ","date":"2020-11-25","objectID":"/flame/:2:2","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"生成内核模块 现在我们有了统计脚本，也安装好了 systemtap，正常来说就可以使用了，但由于 systemtap 是通过生成内核模块的方式统计相关探针的统计数据，而 tlinux 要求所有运行的内核模块需要先到 tlinux 平台签名才可以运行，所以： 故需要先修改 off-cpu 脚本，让其先生成内核模块；之后对该内核模块作签名；最后使用 systemtap 命令手工运行该脚本，统计监控数据。 Systemtap 执行流程如下： parse：分析脚本语法 elaborate：展开脚本 中定义的探针和连接预定义脚本库，分析内核和内核模块的调试信息 translate：. 将脚本编译成 c 语言内核模块文件放 在$HOME/xxx.c 缓存起来，避免同一脚本多次编译 build：将 c 语言模块文件编译成。ko 的内核模块，也缓存起来。 把模块交给 staprun，staprun 加载内核模块到内核空间，stapio 连接内核模块和用户空间，提供交互 IO 通道，采集数据。 所以我们这里修改下 off-cpu 的 stap 脚本，让其只运行完第四阶段，只生成一个内核模块 // 在 stap 命令后增加 -p4 参数，告诉 systemtap，当前只需要执行到第四阶段 open my $in, \"|stap -p4 --skip-badvars --all-modules -x $pid -d '$exec_path' --ldd $d_so_args $stap_args -\" or die \"Cannot run stap: $!\\n\"; 修改好之后运行脚本，会生成一个内核模块 // -p 8682 是需要监控的进程的进程号 // -t 30 是指会采样 30 秒 ./sample-bt-off-cpu -p 8692 -t 30 生成的内核模块名称形如 stap_xxxxx.ko模块名称 由于读者并不需要关心内核模块签名，故章节略过 ","date":"2020-11-25","objectID":"/flame/:2:3","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"运行内核模块统计数据 内核模块签名完成后，便可以使用 staprun 命令手工运行相关内核模块了 命令： // 注意：签名脚本会将生产的内核模块重命名，需要将名字改回去……（脚本 bug） staprun -x {进程号} {内核模块名} \u003e demo.bt 值得注意的是，监控的进程要有一定负载 systemtap 才可以采集到相关数据，即在采集时，同时需要要有一定请求量（通常是自己构造请求，压测进程） ","date":"2020-11-25","objectID":"/flame/:2:4","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"将统计数据转换成火焰图 获得了统计数据 demo.bt 后，便可以使用火焰图工具绘制火焰图了 下载 FlameGraph，链接：https://github.com/brendangregg/FlameGraph 命令： ./stackcollapse-stap.pl demo.bt \u003e demo.folded ./flamegraph.pl demo.folded \u003e demo.svg 这样便获得了 off-cpu 火焰图： ","date":"2020-11-25","objectID":"/flame/:2:5","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"看图说话 趁热打铁，通过几张火焰图熟悉下如何使用火焰图 图片源于春哥微博或者本人近期绘制的性能火焰图 ","date":"2020-11-25","objectID":"/flame/:3:0","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"on-cpu 火焰图 Apache APISIX QPS 急剧下降问题 Apache APISIX 是一个开源国产的高性能 API 网关，之前在进行选型压测时，发现当 Route 匹配不中场景下， QPS 急剧下降，在其 CPU （四十八核）占用率几乎达到 100%的情况下只有几千 QPS，通过绘制火焰图发现，其主要耗时在一个 table 插入阶段 (lj_cf_table_insert)，分析代码发现是该 table 一直没有释放，每次匹配不中时，路由会向一张用于统计的表中插入一条数据，导致该表越来越大，后续插入耗时过长导致 QPS 下降。 ","date":"2020-11-25","objectID":"/flame/:3:1","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"off-cpu 火焰图 nginx 互斥锁问题 这是一张 nginx 的 off-cpu 火焰图，我们可以很快锁定到 ngx_common_set_cache_fs_size -\u003e ngx_shmtx_lock -\u003e sem_wait 这段逻辑使用到了互斥锁，它让 nginx 进程绝大部分阻塞等待时间花费在获取该锁。 agent 监控上报断点问题 这是一张 agent 的 off-cpu 火焰图，它是一个多线程异步事件模型，主线程处理各个消息，多个线程分别负责配置下发或者监控上报。当前问题出现在监控上报性能差，无法在周期（一分钟）内完成监控数据上报，导致监控断点，通过 off-cpu 火焰图我们可以分析出，该上报线程花费了大量的时间使用 curl_easy_perform 接口收发 http 监控数据消息。 依据火焰图将发送 http 消息的逻辑改为异步非阻塞后，该问题解决。 ","date":"2020-11-25","objectID":"/flame/:3:2","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"附录 ","date":"2020-11-25","objectID":"/flame/:4:0","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"进阶阅读 谷歌搜索演讲：Blazing Performance with Flame Graphs 演讲 ppt：https://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs 《SystemTap 新手指南》：https://spacewander.gitbooks.io/systemtapbeginnersguide_zh/content/index.html 极客时间《Linux 性能优化实战》–倪朋飞 ","date":"2020-11-25","objectID":"/flame/:4:1","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"FAQ 使用 perf 或者 systemtap 的方式采集数据，会对后台服务有性能影响吗？ 有，但是很小，可以基本忽略不计。 它们使用系统的探针或者使用一些自定义的动态探针进行数据采集，第一对代码无侵入性，它既不需要停止服务，也不需要修改应用程序的代码；第二，它们是以内核模块/内核原生的方式跟踪用户态和内核态的所有事件，并通过一系列优化措施，进行采样统计，对目标服务性能影响极小，大概在 5%左右或者更低的性能损耗。相较于将进程运行在沙箱的 valgrind 工具或静态调试工具 gdb 来说，动态追踪 perf 或者 systemtap 或者 ebpf 的性能损耗基本可以忽略不计。 目标进程重启后，systemtap 是否需要重新生成内核模块？ 不需要。甚至同一个 linux 内核版本下的同一个二进制进程（md5 值一致），在安装 kernel 调试符号表后，便可以在生成采集指标的内核模块，并且可以多次使用。 当 linux 内核版本不一致，符号表有变化，需要重新生成内核模块；当目标进程二进制文件重新编译后，也需要重新生成统计用的 systemtap 内核模块。 如何在容器中绘制火焰图？ 如果是 on-cpu 火焰图可以直接使用perf record命令绘制即可 如果是 off-cpu 之类的火焰图，则需要另外分析 若系统/容器支持 ebpf 可以使用 bcc 工具集，使用如下命令绘制 off-cpu 火焰图 /usr/share/bcc/tools/offcputime -df -p `pgrep -nx mysqld` 30 \u003e out.stacks ","date":"2020-11-25","objectID":"/flame/:4:2","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":["Env"],"content":"Github Pages 建站教程 ","date":"2020-10-10","objectID":"/how-to-create-blog/","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"十一假期宅家无事，发现自己过去写了很多文章，却没有一个自己的博客，系统得管理自己的文章，所以准备将自己过去以及未来的文章都放到博客，以饷读者。另一方面，经过对 Serverless 博客、TCB 建站、虚拟机建站等一系列建站方式对比后，个人认为基于 Github Pages 最适合搭建个人技术博客，最重要的当然是免费，其次网上教程众多，可以快速建站，第三则是所有的博客直接托管在 github，也更符合个人习惯，最后则是自建个人博客可玩性和可扩展性好。 当然，这个方案并不是完美无缺，缺点也比较明显，比如需要考虑到安全信息泄漏问题（比如可能会泄露公司内的机密信息或者秘钥到 Github，所以需要准备安全扫描方案，这个我们会在另一篇文章谈）；另一方面，读者需要能够翻墙才可以访问 Github Pages；最后，则是没有 CDN 加速，如果访问者众多或者网站图片众多，加载速度很慢。 ","date":"2020-10-10","objectID":"/how-to-create-blog/:0:0","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"为什么要写技术文章？ 其实，个人写文章最初是兴趣使然以及工作需要。众所周知，IT 是一个技术革新很快的行业，新的概念、新的语言、新的框架层出不穷，程序员需要持续学习，我有对每一个新的知识有做笔记的习惯，笔记攒多了便需要回顾总结整理，便形成了一篇篇的文章。 以前笔记的图找不到了，差不多在习惯使用电子笔记之前有十几本笔记，后来我习惯性使用思维导图 processon 等一系列工具记录笔记，比如这张图便是我做的思维导图笔记的冰山一角： 那么，写技术文章有何价值？个人认为写技术文章的价值主要有三方面：个人价值、企业价值和社会价值、企业价值。从个人角度来说，技术写作是树立个人技术影响力，提升自我价值的最快路径，没有之一；从公司角度，坚持长线的写作，对于公司的技术品牌，技术文化，有着巨大的推动作用；从更高的维度来说，技术写作也是提升整个社会技术水平，推动技术不断进步的源动力。 ","date":"2020-10-10","objectID":"/how-to-create-blog/:1:0","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"hugo 初探 ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:0","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"hugo 是什么？ Hugo 是由 Go 语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 hugo 中文官方文档 hugo 英文官方文档 ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:1","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"安装 hugo 在 windows 下，你可以在此处下载 windows 版本下载链接 如果你是 mac 系统，则可以通过如下命令安装（需要先安装 homebrew） brew install hugo ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:2","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"确认 hugo 安装是否成功 通过检查版本号的方式，确认 hugo 安装是否成功 hugo version Hugo Static Site Generator v0.73.0/extended darwin/amd64 BuildDate: unknown # 输出结果 ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:3","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"初始化网站目录 安装好之后，便可以初始化一个 hugo 项目， hugo new site demosite # 命令格式，hugo new site \u003c项目名称\u003e ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:4","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"下载一个 hugo 主题 hugo 主题可以理解为是一种网站样式，你可以在该页面选择自己心仪的 hugo 主题。我当前使用的是 LoveIt 这个主题，集成了很多插件，很好用很方便的一个中文博客模板。 进入该目录，初始化 git 项目，并下载 hugo 主题 cd demosite git init #初始化 git 项目 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt #下载主题 博客会采用 git 项目方式管理，所以需要初始化 git 项目 采用 submodule 的方式管理主题库 theme，方便及时更新和管理 ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:5","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"配置主题 使用 LoveIt 的标准配置文件模板 cp themes/LoveIt/exampleSite/config.toml . 需要修改一下主题路径 themesDir 配置，将其注释掉 ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:6","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"创建文章 创建一篇空文章 hugo new posts/demo.md 另外，需要将生成文章头部的draft=true修改为draft=false，否则并不会生成草稿页面 ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:7","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"启动 hugo 服务器 启动 hugo 服务器，进入 http://localhost:1313/ 预览页面 hugo server -D 页面预览如下 ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:8","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"构建静态页面 若要将博客托管在 github 上，需要上传静态页面。所以，需要使用 hugo 构建静态页面，构建命令如下： hugo -D ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:9","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"使用 Github Pages 搭建个人博客 ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:0","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"个人博客整体架构 一个静态博客数据有两部分，一部分是静态页面（体积小），另一部分是图片或者大文件（文件体积大），通常来讲一个网站整体结构是静态页面放在服务器上（比如可以使用虚拟机、自己的服务器、github pages 项目），而对于大文件或者图片则通常会使用对象存储服务（比如对象存储或者 github 项目），它们前端使用一个 CDN 进行加速（比如云厂商的 CDN 服务或者 cloudinary），当然，在 HTTPS 已经普及的时代，一个 HTTPS 服务也是必不可少的。 整体架构图如下： 经过综合考量，个人建站选用组件如下： 静态网站服务器：Github Pages 图片上传工具：picgo 图片存储服务：Github 项目 + jsdelivr 加速 域名服务商/域名购买：NameCheap HTTPS/CDN 服务提供商：Cloudfare 腾讯云服务中的 TCB 一键建站也挺好用的。但是因为个人图省钱和喜欢折腾，还是选择自己建站自己选择组件，一方面免费，另一方面可以对网络有更加深刻的理解。 ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:1","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"Github Pages 是什么？ GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 index.html、HTML、CSS 和 JavaScript 文件，也可以通过构建过程运行文件，然后发布网站。 GitHub Pages 可以识别指定分支根目录或者/docs 目录下的静态站点，具体可以在个人站点的 setting 中配置。 Github Pages 建站有两种类型： 个人/组织站点，其域名格式形如https://\u003cUSERNAME|ORGANIZATION\u003e.github.io/ 项目站点，其域名格式形如https://\u003cUSERNAME|ORGANIZATION\u003e.github.io/\u003cPROJECT\u003e/ 你需要看清楚你的 Github Pages 建站类型，不同的建站类型的建站方法也不同，具体可以参考 官方手册 这里我们以个人站点（User Pages）为例 ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:2","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"创建 Github Pages 项目 创建一个新的 github 项目，项目名称需要是\u003cusername.github.io\u003e格式，如下图样例 ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:3","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"配置 pages 项目 点击进入 setting，搜索 github pages 关键字，找到相关配置：当前 github 默认分支已经是 main 分支，需要调整下；配置好之后即可通过用户名。github.io最初的 github 页面。 ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:4","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"hugo 生成静态页面 生成静态页面之前需要修改 config.toml 文件中的 baseURL 配置，将其修改为个人站点，比如我的就是 miss-you.github.io 前面我们知道hugo -D可以生成静态页面，但该命令会默认将静态页面生成到 public 目录下，而 Github Pages 仅支持根目录/或者/docs 目录，所以我们需要将静态页面生成到 docs 目录下 hugo -d docs ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:5","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"上传 github pages 项目 静态页面生成完成后，便可以将整个静态页面以及本项目其他文件上传到 github 项目中。先使用git remote命令添加远端仓库，将文件提交（git add+git commit），最后推送到 Github Pages 项目中 git remote add origin git@github.com:Miss-you/miss-you.github.io.git # 将本地 git 项目与 github 项目相关联 git fetch origin # 拉取 github 项目 git checkout main #切换到主分支 main git add . git commit -m \"init github pages\" git push origin 当然，这里也可以采用git clone \u003cYOUR-PROJECT-URL\u003e \u0026\u0026 cd \u003cYOUR-PROJECT\u003e拉取项目、上传文件（git add/commit/push) 的方式，上传 github 项目，这里不作过多演示 ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:6","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"发布脚本 虽然我们已经打通了基于 Github Pages 搭建个人博客的流程，但每次博客有修改都需要执行多条命令才能将博客发布，重复劳动且浪费时间，而程序员的天性是追求效率，应当用自动化（脚本）解决重复的工作。 如下是一个常用脚本，会自动构建静态页面，然后提交构建出来的 docs 静态页面目录，将其推送到对应 Github Pages 项目中 #!/bin/sh # If a command fails then the deploy stops set -e printf \"\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\" # Build the project. hugo -d docs # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Add changes to git. git add docs # Commit changes. msg=\"rebuilding site $(date)\" if [ -n \"$*\" ]; then msg=\"$*\" fi git commit -m \"$msg\" # Push source and build repos. git push origin main ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:7","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"FAQ ","date":"2020-10-10","objectID":"/how-to-create-blog/:4:0","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"常见操作 TODO 文章插入图片 图片上传问题 图片存储问题 TODO 修改模板 TODO 创建友链 TODO 创建联系方式 TODO ","date":"2020-10-10","objectID":"/how-to-create-blog/:4:1","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"常见问题 Github Pages 项目报错：The submodule registered for ./themes/xxx could not be cloned. 原因是 Github Pages 项目，若要使用 submodule 应用第三方主题，需要使用 https 的地址而不是 git 地址 [TOC] 符号不生效 toc 是 markdown 的一种进阶语法，用于自动生成目录，但是 hugo 并没有支持该语法。目录建议采用主题自带的目录功能，比如本文示例中的 LoveIt 主题。 使用 loveit 或者切换到 loveit 主题入门教程： LoveIt 入门教程 找不到主题，Error: module “LoveIt” not found 原因是由于 LoveIt 示例主题中的 config.toml 文件，其主题路径为”../..\"，该目录下并不会有 LoveIt 主题，将其注释掉即可，或者修改 LoveIt 主题所在的相对路径 github 搜索不到 LoveIt 主题 LoveIt 英文小写是 loveit，不是 lovelt，因为不注意的话 I 和 l 难以区分，容易混淆 jsdelivr latest图片找不到问题 https://cdn.jsdelivr.net/gh/Miss-you/img/how-to-create-blog/20201020132241.png https://cdn.jsdelivr.net/gh/Miss-you/img@1.0/how-to-create-blog/20201020132241.png 必须要带版本号才可以找得到 为什么latest用不了？ github的bug，他们的latest默认会去找master分支的，而不是main分支的图片…… ","date":"2020-10-10","objectID":"/how-to-create-blog/:4:2","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"参考链接 hugo 中文官方文档 hugo 英文官方文档 hugo 主题站 github pages 官方手册 hugo loveit 主题使用教程 cloudfare 配置教程 picgo 官方教程 ","date":"2020-10-10","objectID":"/how-to-create-blog/:5:0","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["GoLang"],"content":"本文主要介绍如何使用 go 语言 database/sql 库从数据库中读取 null 值的问题，以及如何向数据库中插入 null 值。本文在这里使用的是 sql.NullString, sql.NullInt64, sql.NullFloat64 等结构体，为了方便书写，它们的泛指我会使用 sql.Null 来表示. ","date":"2020-10-08","objectID":"/go-mysql-null/","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":" 本文主要介绍如何使用 go 语言 database/sql 库从数据库中读取 null 值的问题，以及如何向数据库中插入 null 值。本文在这里使用的是 sql.NullString, sql.NullInt64, sql.NullFloat64 等结构体，为了方便书写，它们的泛指我会使用 sql.Null 来表示 ","date":"2020-10-08","objectID":"/go-mysql-null/:0:0","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"要点 从数据库读取可能为 null 值得值时，可以选择使用 sql.NULL 来读取；或者使用 IFNULL、COALESCE 等命令让数据库查询值返回不为\"“或者 NULL 若需要往数据库中插入 null 值，则依然可以使用 sql.NULL 存储所需的值，然后进行插入 NULL 值 直接使用 sql.NULL 类型容易出现 valid 遗漏设置等问题，普通 int、string 与其转换时，请写几个简单的 get、set 函数 本 demo 使用的数据库表以及数据如下 mysql\u003e desc person; +------------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +------------+--------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | first_name | varchar(100) | NO | | NULL | | | last_name | varchar(40) | YES | | NULL | | | age | int(11) | YES | | NULL | | +------------+--------------+------+-----+---------+----------------+ mysql\u003e select * from person; +----+------------+-----------+------+ | id | first_name | last_name | age | +----+------------+-----------+------+ | 1 | yousa | NULL | NULL | +----+------------+-----------+------+ mysql\u003e show create table person; +--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | Table | Create Table | +--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | person | CREATE TABLE `person` ( `id` int(11) NOT NULL AUTO_INCREMENT, `first_name` varchar(100) NOT NULL, `last_name` varchar(40) DEFAULT NULL, `age` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 | +--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.00 sec) ","date":"2020-10-08","objectID":"/go-mysql-null/:1:0","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"从数据库中读取 NULL 值 如果不作处理直接从数据库中读取 NULL 值到 string/int，会发生如下错误错误 Scan NULL 值到 string 的报错 sql: Scan error on column index 1: unsupported Scan, storing driver.Value type \u003cnil\u003e into type *string Scan NULL 值到 int 的报错 sql: Scan error on column index 1: converting driver.Value type \u003cnil\u003e (\"\u003cnil\u003e\") to a int: invalid syntax 使用如下的 struct 来读取数据库内容 type Person struct { firstName string lastName string age int } //由于只有一行，直接使用 QueryRow row := db.QueryRow(\"SELECT first_name, last_name FROM person WHERE first_name='yousa'\") err = row.Scan(\u0026hello.firstName, \u0026hello.lastName) if err != nil { fmt.Println(err) } fmt.Println(hello) row1 := db.QueryRow(\"SELECT first_name, age FROM person WHERE first_name='yousa'\") err = row1.Scan(\u0026hello.firstName, \u0026hello.age) if err != nil { fmt.Println(err) } fmt.Println(hello) 运行代码，可以通过日志看出来，错误来自 Scan 将 NULL 值赋值给 int 或者 string 时，报错；解决这个问题可以使用 sql 原生结构体 sql.Null 来解决 ","date":"2020-10-08","objectID":"/go-mysql-null/:2:0","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"使用 sqlNull sql.Null 在 sql 库中声明如下，在读取时，（比如读取的值存储到 NullInt64），假如发现存储的值是 NULL，则会将 NullInt64 的 valid 设置为 false，然后不会将值存储到 Int64 中，Int64 值默认为 0，如果是 NullString 则 String 值时 nil；如果是正常值，则会将 Valid 赋值为 true，将值存储到 Int64 中。 type NullInt64 struct { Int64 int64 Valid bool // Valid is true if Int64 is not NULL } func (n *NullInt64) Scan(value interface{}) error func (n NullInt64) Value() (driver.Value, error) type NullString struct { String string Valid bool // Valid is true if String is not NULL } func (ns *NullString) Scan(value interface{}) error func (ns NullString) Value() (driver.Value, error) 代码修改为如下： type Person struct { firstName string lastNullName sql.NullString nullAge sql.NullInt64 } rowNull := db.QueryRow(\"SELECT first_name, last_name FROM person WHERE first_name='yousa'\") err = rowNull.Scan(\u0026hello.firstName, \u0026hello.lastNullName) if err != nil { fmt.Println(err) } fmt.Println(hello) rowNull1 := db.QueryRow(\"SELECT first_name, age FROM person WHERE first_name='yousa'\") err = rowNull1.Scan(\u0026hello.firstName, \u0026hello.nullAge) if err != nil { fmt.Println(err) } fmt.Println(hello) 输出结果 {yousa 0 { false} {0 false}} ","date":"2020-10-08","objectID":"/go-mysql-null/:2:1","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"使用 IFNULL 或者 COALESCE coalesce() 解释：返回参数中的第一个非空表达式（从左向右依次类推） IFNULL(expr1,expr2): 如果 expr1 不是 NULL，IFNULL() 返回 expr1，否则它返回 expr2。IFNULL() 返回一个数字或字符串值，取决于它被使用的上下文环境。 查询语句使用一个默认值来替换 NULL 即可 SELECT first_name, COALESCE(age, 0) FROM person;// SELECT first_name, IFNULL(age, 0) FROM person;// ","date":"2020-10-08","objectID":"/go-mysql-null/:2:2","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"往数据库中插入 NULL 值 前面我们对 SELECT 语句使用了 sql.Null 类型，同理，INSERT、UPDATE 语句也可以通过使用这种类型来插入 nil 值 代码如下： hello := Person { firstName: \"\", lastName: \"\", age: 0, lastNullName: sql.NullString{String:\"\", Valid:false}, nullAge: sql.NullInt64{Int64:0, Valid:false}} _, err = db.Exec( \"INSERT INTO person (first_name, last_name) VALUES (?, ?)\", \"yousa1\", hello.lastName) if err != nil { fmt.Println(err) } _, err = db.Exec( \"INSERT INTO person (first_name, last_name) VALUES (?, ?)\", \"yousa2\", hello.lastNullName) if err != nil { fmt.Println(err) } //数据库插入结果 mysql\u003e select * from person; +----+------------+-----------+------+ | id | first_name | last_name | age | +----+------------+-----------+------+ | 1 | yousa | NULL | NULL | | 2 | yousa1 | | NULL | | 3 | yousa2 | NULL | NULL | +----+------------+-----------+------+ 解释下 db.Exec 操作 hello.lastNullName 的过程： 首先它会调用 hello.lastNullName 的 Value 方法，获取到 driver.Value，然后检验 Valid 值是 true 还是 false，如果是 false 则会返回一个 nil 值（nil 值传给 sql driver 会被认为是 NULL 值），如果是 true 则会将 hello.lastNullName.String 的值传过去。 PS: 为了保证你所插入的值能如你所期望是 NULL 值，一定记得要将 sql.Null 中 Valid 值置为 false 使用 NULL 还是有很多危害的，再回顾下数据库中使用 NULL 值的危害 ","date":"2020-10-08","objectID":"/go-mysql-null/:3:0","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"为什么不建议使用 NULL 所有使用 NULL 值的情况，都可以通过一个有意义的值的表示，这样有利于代码的可读性和可维护性，并能从约束上增强业务数据的规范性。 NULL 值在 timestamp 类型下容易出问题，特别是没有启用参数 explicit_defaults_for_timestamp NOT IN、!= 等负向条件查询在有 NULL 值的情况下返回永远为空结果，查询容易出错 Null 列需要更多的存储空间：需要一个额外字节作为判断是否为 NULL 的标志位 NULL 值到非 NULL 的更新无法做到原地更新，更容易发生索引分裂，从而影响性能。 PS：但把 NULL 列改为 NOT NULL 带来的性能提示很小，除非确定它带来了问题，否则不要把它当成优先的优化措施，最重要的是使用的列的类型的适当性。 当然有些情况是不得不使用 NULL 值进行存储，或者在查询时由于 left/right join 等导致 NULL 值，但总体来说，能少用就少用。 ","date":"2020-10-08","objectID":"/go-mysql-null/:3:1","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"helper func（提升效率/减少错误） 如果使用 sql.NULL 的话，由于其有两个字段，如果直接手动赋值的话还是很容易遗漏，所以还是需要简单的转换函数，这里给了两个简单的 helper fuc，分别是将 int64 转换成 NullInt64 和将 string 转换成 NullString //ToNullString invalidates a sql.NullString if empty, validates if not empty func ToNullString(s string) sql.NullString { return sql.NullString{String : s, Valid : s != \"\"} } //ToNullInt64 validates a sql.NullInt64 if incoming string evaluates to an integer, invalidates if it does not func ToNullInt64(s string) sql.NullInt64 { i, err := strconv.Atoi(s) return sql.NullInt64{Int64 : int64(i), Valid : err == nil} } ","date":"2020-10-08","objectID":"/go-mysql-null/:4:0","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"参考博客 https://github.com/go-sql-driver/mysql/issues/34 https://github.com/guregu/null https://gocn.io/question/243 https://godoc.org/database/sql http://url.cn/5cFTz4W 一千个不用 Null 的理由 ","date":"2020-10-08","objectID":"/go-mysql-null/:5:0","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"}]