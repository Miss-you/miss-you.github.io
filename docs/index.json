[{"categories":null,"content":"本文主要分享火焰图使用技巧，介绍 systemtap 的原理机制，如何使用火焰图快速定位性能问题原因，同时加深对 systemtap 的理解。","date":"2020-11-25","objectID":"/flame/","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":" 本文主要分享火焰图使用技巧，介绍 systemtap 的原理机制，如何使用火焰图快速定位性能问题原因，同时加深对 systemtap 的理解。 让我们回想一下，曾经作为编程新手的我们是如何调优程序的？通常是在没有数据的情况下依靠主观臆断来瞎蒙，稍微有些经验的同学则会对差异代码进行二分或者逐段调试。这种定位问题的方式不仅耗时耗力，而且还不具有通用性，当遇到其他类似的性能问题时，需要重复踩坑、填坑，那么如何避免这种情况呢？ 俗语有云：“工欲善其事，必先利其器。”个人认为，程序员定位性能问题也需要一件“利器”。 如同医生给病人看病，需要依靠专业的医学工具（比如 X 光片、听诊器等）进行诊断，最后依据医学工具的检验结果快速精准地定位出病因所在。性能调优工具（比如 perf / gprof 等）之于性能调优就像 X 光之于病人一样，它可以一针见血地指出程序的性能瓶颈。 但是常用的性能调优工具 perf 等，在呈现内容上只能单一地列出调用栈或者非层次化的时间分布，不够直观。这里我推荐大家配合使用火焰图，它将 perf 等工具采集的数据呈现得更为直观。 ","date":"2020-11-25","objectID":"/flame/:0:0","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"初识火焰图 火焰图（Flame Graph）是由 Linux 性能优化大师 Brendan Gregg 发明的，和所有其他的 profiling 方法不同的是，火焰图以一个全局的视野来看待时间分布，它从底部往顶部，列出所有可能导致性能瓶颈的调用栈。 火焰图整个图形看起来就像一个跳动的火焰，这就是它名字的由来。 火焰图有以下特征（这里以 on-cpu 火焰图为例）： 每一列代表一个调用栈，每一个格子代表一个函数； 纵轴展示了栈的深度，按照调用关系从下到上排列，最顶上格子代表采样时，正在占用 cpu 的函数； 横轴的意义是指：火焰图将采集的多个调用栈信息，通过按字母横向排序的方式将众多信息聚合在一起。需要注意的是它并不代表时间； 横轴格子的宽度代表其在采样中出现频率，所以一个格子的宽度越大，说明它是瓶颈原因的可能性就越大； 火焰图格子的颜色是随机的暖色调，方便区分各个调用信息； 其他的采样方式也可以使用火焰图， on-cpu 火焰图横轴是指 cpu 占用时间，off-cpu 火焰图横轴则代表阻塞时间； 采样可以是单线程、多线程、多进程甚至是多 host，进阶用法可以参考附录 进阶阅读； ","date":"2020-11-25","objectID":"/flame/:1:0","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"火焰图类型 常见的火焰图类型有 On-CPU，Off-CPU，还有 Memory，Hot/Cold，Differential 等等。他们分别适合处理什么样的问题呢？ 这里笔者主要使用到的是 On-CPU、Off-CPU 以及 Memory 火焰图，所以这里仅仅对这三种火焰图作比较，也欢迎大家补充和斧正。 ","date":"2020-11-25","objectID":"/flame/:1:1","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"火焰图分析技巧 纵轴代表调用栈的深度（栈桢数），用于表示函数间调用关系：下面的函数是上面函数的父函数； 横轴代表调用频次，一个格子的宽度越大，越说明其可能是瓶颈原因； 不同类型火焰图适合优化的场景不同，比如 on-cpu 火焰图适合分析 cpu 占用高的问题函数，off-cpu 火焰图适合解决阻塞和锁抢占问题； 无意义的事情：横向先后顺序是为了聚合，跟函数间依赖或调用关系无关；火焰图各种颜色是为方便区分，本身不具有特殊含义； 多练习：进行性能优化有意识的使用火焰图的方式进行性能调优（如果时间充裕）； ","date":"2020-11-25","objectID":"/flame/:1:2","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"如何绘制火焰图？ 要生成火焰图，必须要有一个顺手的动态追踪工具，如果操作系统是 Linux 的话，那么通常通常是 perf 或者 systemtap 中的一种。其中 perf 相对更常用，多数 Linux 都包含了 perf 这个工具，可以直接使用；SystemTap 则功能更为强大，监控也更为灵活。网上关于如何使用 perf 绘制火焰图的文章非常多而且丰富，所以本文将以 SystemTap 为例。 SystemTap 是动态追踪工具，它通过探针机制，来采集内核或者应用程序的运行信息，从而可以不用修改内核和应用程序的代码，就获得丰富的信息，帮你分析、定位想要排查的问题。SystemTap 定义了一种类似的 DSL 脚本语言，方便用户根据需要自由扩展。不过，不同于动态追踪的鼻祖 DTrace ，SystemTap 并没有常驻内核的运行时，它需要先把脚本编译为内核模块，然后再插入到内核中执行。这也导致 SystemTap 启动比较缓慢，并且依赖于完整的调试符号表。 使用 SystemTap 绘制火焰图的主要流程如下： 安装 SystemTap 以及 操作系统符号调试表 根据自己所需绘制的火焰图类型以及进程类型选择合适的脚本 生成内核模块 运行 SystemTap 或者运行生成的内核模块统计数据 将统计数据转换成火焰图 本文演示步骤将会基于操作系统 Tlinux 2.2 ( Linux 内核版本 3.10.107) ","date":"2020-11-25","objectID":"/flame/:2:0","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"安装 SystemTap 以及 操作系统符号调试表 使用 yum 工具安装 systemtap: yum install systemtap systemtap-runtime 由于 systemtap 工具依赖于完整的调试符号表，而且生产环境不同机器的内核版本不同（虽然都是 Tlinux 2.2 版本，但是内核版本后面的小版本不一样，可以通过 uname -a 命令查看）所以我们还需要安装 kernel-debuginfo 包、 kernel-devel 包 我这里是安装了这两个依赖包 kernel-devel-3.10.107-1-tlinux2-0046.x86_64 kernel-debuginfo-3.10.107-1-tlinux2-0046.x86_64 ","date":"2020-11-25","objectID":"/flame/:2:1","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"根据自己所需绘制的火焰图类型以及进程类型选择合适的脚本 使用 SystemTap 统计相关数据往往需要自己依照它的语法，编写脚本，具有一定门槛。幸运的是，github 上春哥（agentzh）开源了两组他常用的 SystemTap 脚本：openresty-systemtap-toolkit 和 stapxx，这两个工具集能够覆盖大部分 C 进程、nginx 进程以及 Openresty 进程的性能问题场景。 我们这里需要绘制 off-cpu 火焰图，所以使用 sample-bt-off-cpu 脚本即可 ","date":"2020-11-25","objectID":"/flame/:2:2","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"生成内核模块 现在我们有了统计脚本，也安装好了 systemtap，正常来说就可以使用了，但由于 systemtap 是通过生成内核模块的方式统计相关探针的统计数据，而 tlinux 要求所有运行的内核模块需要先到 tlinux 平台签名才可以运行，所以： 故需要先修改 off-cpu 脚本，让其先生成内核模块；之后对该内核模块作签名；最后使用 systemtap 命令手工运行该脚本，统计监控数据。 Systemtap 执行流程如下： parse：分析脚本语法 elaborate：展开脚本 中定义的探针和连接预定义脚本库，分析内核和内核模块的调试信息 translate：. 将脚本编译成 c 语言内核模块文件放 在$HOME/xxx.c 缓存起来，避免同一脚本多次编译 build：将 c 语言模块文件编译成。ko 的内核模块，也缓存起来。 把模块交给 staprun，staprun 加载内核模块到内核空间，stapio 连接内核模块和用户空间，提供交互 IO 通道，采集数据。 所以我们这里修改下 off-cpu 的 stap 脚本，让其只运行完第四阶段，只生成一个内核模块 // 在 stap 命令后增加 -p4 参数，告诉 systemtap，当前只需要执行到第四阶段 open my $in, \"|stap -p4 --skip-badvars --all-modules -x $pid -d '$exec_path' --ldd $d_so_args $stap_args -\" or die \"Cannot run stap: $!\\n\"; 修改好之后运行脚本，会生成一个内核模块 // -p 8682 是需要监控的进程的进程号 // -t 30 是指会采样 30 秒 ./sample-bt-off-cpu -p 8692 -t 30 生成的内核模块名称形如 stap_xxxxx.ko模块名称 由于读者并不需要关心内核模块签名，故章节略过 ","date":"2020-11-25","objectID":"/flame/:2:3","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"运行内核模块统计数据 内核模块签名完成后，便可以使用 staprun 命令手工运行相关内核模块了 命令： // 注意：签名脚本会将生产的内核模块重命名，需要将名字改回去……（脚本 bug） staprun -x {进程号} {内核模块名} \u003e demo.bt 值得注意的是，监控的进程要有一定负载 systemtap 才可以采集到相关数据，即在采集时，同时需要要有一定请求量（通常是自己构造请求，压测进程） ","date":"2020-11-25","objectID":"/flame/:2:4","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"将统计数据转换成火焰图 获得了统计数据 demo.bt 后，便可以使用火焰图工具绘制火焰图了 下载 FlameGraph，链接：https://github.com/brendangregg/FlameGraph 命令： ./stackcollapse-stap.pl demo.bt \u003e demo.folded ./flamegraph.pl demo.folded \u003e demo.svg 这样便获得了 off-cpu 火焰图： ","date":"2020-11-25","objectID":"/flame/:2:5","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"看图说话 趁热打铁，通过几张火焰图熟悉下如何使用火焰图 图片源于春哥微博或者本人近期绘制的性能火焰图 ","date":"2020-11-25","objectID":"/flame/:3:0","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"on-cpu 火焰图 Apache APISIX QPS 急剧下降问题 Apache APISIX 是一个开源国产的高性能 API 网关，之前在进行选型压测时，发现当 Route 匹配不中场景下， QPS 急剧下降，在其 CPU （四十八核）占用率几乎达到 100%的情况下只有几千 QPS，通过绘制火焰图发现，其主要耗时在一个 table 插入阶段 (lj_cf_table_insert)，分析代码发现是该 table 一直没有释放，每次匹配不中时，路由会向一张用于统计的表中插入一条数据，导致该表越来越大，后续插入耗时过长导致 QPS 下降。 ","date":"2020-11-25","objectID":"/flame/:3:1","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"off-cpu 火焰图 nginx 互斥锁问题 这是一张 nginx 的 off-cpu 火焰图，我们可以很快锁定到 ngx_common_set_cache_fs_size -\u003e ngx_shmtx_lock -\u003e sem_wait 这段逻辑使用到了互斥锁，它让 nginx 进程绝大部分阻塞等待时间花费在获取该锁。 agent 监控上报断点问题 这是一张 agent 的 off-cpu 火焰图，它是一个多线程异步事件模型，主线程处理各个消息，多个线程分别负责配置下发或者监控上报。当前问题出现在监控上报性能差，无法在周期（一分钟）内完成监控数据上报，导致监控断点，通过 off-cpu 火焰图我们可以分析出，该上报线程花费了大量的时间使用 curl_easy_perform 接口收发 http 监控数据消息。 依据火焰图将发送 http 消息的逻辑改为异步非阻塞后，该问题解决。 ","date":"2020-11-25","objectID":"/flame/:3:2","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"附录 ","date":"2020-11-25","objectID":"/flame/:4:0","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"进阶阅读 谷歌搜索演讲：Blazing Performance with Flame Graphs 演讲 ppt：https://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs 《SystemTap 新手指南》：https://spacewander.gitbooks.io/systemtapbeginnersguide_zh/content/index.html 极客时间《Linux 性能优化实战》–倪朋飞 ","date":"2020-11-25","objectID":"/flame/:4:1","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":null,"content":"FAQ 使用 perf 或者 systemtap 的方式采集数据，会对后台服务有性能影响吗？ 有，但是很小，可以基本忽略不计。 它们使用系统的探针或者使用一些自定义的动态探针进行数据采集，第一对代码无侵入性，它既不需要停止服务，也不需要修改应用程序的代码；第二，它们是以内核模块/内核原生的方式跟踪用户态和内核态的所有事件，并通过一系列优化措施，进行采样统计，对目标服务性能影响极小，大概在 5%左右或者更低的性能损耗。相较于将进程运行在沙箱的 valgrind 工具或静态调试工具 gdb 来说，动态追踪 perf 或者 systemtap 或者 ebpf 的性能损耗基本可以忽略不计。 目标进程重启后，systemtap 是否需要重新生成内核模块？ 不需要。甚至同一个 linux 内核版本下的同一个二进制进程（md5 值一致），在安装 kernel 调试符号表后，便可以在生成采集指标的内核模块，并且可以多次使用。 当 linux 内核版本不一致，符号表有变化，需要重新生成内核模块；当目标进程二进制文件重新编译后，也需要重新生成统计用的 systemtap 内核模块。 如何在容器中绘制火焰图？ 如果是 on-cpu 火焰图可以直接使用perf record命令绘制即可 如果是 off-cpu 之类的火焰图，则需要另外分析 若系统/容器支持 ebpf 可以使用 bcc 工具集，使用如下命令绘制 off-cpu 火焰图 /usr/share/bcc/tools/offcputime -df -p `pgrep -nx mysqld` 30 \u003e out.stacks ","date":"2020-11-25","objectID":"/flame/:4:2","tags":["profile","flamegraph"],"title":"性能调优利器--火焰图","uri":"/flame/"},{"categories":["Env"],"content":"Github Pages 建站教程 ","date":"2020-10-10","objectID":"/how-to-create-blog/","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"十一假期宅家无事，发现自己过去写了很多文章，却没有一个自己的博客，系统得管理自己的文章，所以准备将自己过去以及未来的文章都放到博客，以饷读者。另一方面，经过对 Serverless 博客、TCB 建站、虚拟机建站等一系列建站方式对比后，个人认为基于 Github Pages 最适合搭建个人技术博客，最重要的当然是免费，其次网上教程众多，可以快速建站，第三则是所有的博客直接托管在 github，也更符合个人习惯，最后则是自建个人博客可玩性和可扩展性好。 当然，这个方案并不是完美无缺，缺点也比较明显，比如需要考虑到安全信息泄漏问题（比如可能会泄露公司内的机密信息或者秘钥到 Github，所以需要准备安全扫描方案，这个我们会在另一篇文章谈）；另一方面，读者需要能够翻墙才可以访问 Github Pages；最后，则是没有 CDN 加速，如果访问者众多或者网站图片众多，加载速度很慢。 ","date":"2020-10-10","objectID":"/how-to-create-blog/:0:0","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"为什么要写技术文章？ 其实，个人写文章最初是兴趣使然以及工作需要。众所周知，IT 是一个技术革新很快的行业，新的概念、新的语言、新的框架层出不穷，程序员需要持续学习，我有对每一个新的知识有做笔记的习惯，笔记攒多了便需要回顾总结整理，便形成了一篇篇的文章。 以前笔记的图找不到了，差不多在习惯使用电子笔记之前有十几本笔记，后来我习惯性使用思维导图 processon 等一系列工具记录笔记，比如这张图便是我做的思维导图笔记的冰山一角： 那么，写技术文章有何价值？个人认为写技术文章的价值主要有三方面：个人价值、企业价值和社会价值、企业价值。从个人角度来说，技术写作是树立个人技术影响力，提升自我价值的最快路径，没有之一；从公司角度，坚持长线的写作，对于公司的技术品牌，技术文化，有着巨大的推动作用；从更高的维度来说，技术写作也是提升整个社会技术水平，推动技术不断进步的源动力。 ","date":"2020-10-10","objectID":"/how-to-create-blog/:1:0","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"hugo 初探 ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:0","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"hugo 是什么？ Hugo 是由 Go 语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 hugo 中文官方文档 hugo 英文官方文档 ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:1","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"安装 hugo 在 windows 下，你可以在此处下载 windows 版本下载链接 如果你是 mac 系统，则可以通过如下命令安装（需要先安装 homebrew） brew install hugo ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:2","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"确认 hugo 安装是否成功 通过检查版本号的方式，确认 hugo 安装是否成功 hugo version Hugo Static Site Generator v0.73.0/extended darwin/amd64 BuildDate: unknown # 输出结果 ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:3","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"初始化网站目录 安装好之后，便可以初始化一个 hugo 项目， hugo new site demosite # 命令格式，hugo new site \u003c项目名称\u003e ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:4","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"下载一个 hugo 主题 hugo 主题可以理解为是一种网站样式，你可以在该页面选择自己心仪的 hugo 主题。我当前使用的是 LoveIt 这个主题，集成了很多插件，很好用很方便的一个中文博客模板。 进入该目录，初始化 git 项目，并下载 hugo 主题 cd demosite git init #初始化 git 项目 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt #下载主题 博客会采用 git 项目方式管理，所以需要初始化 git 项目 采用 submodule 的方式管理主题库 theme，方便及时更新和管理 ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:5","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"配置主题 使用 LoveIt 的标准配置文件模板 cp themes/LoveIt/exampleSite/config.toml . 需要修改一下主题路径 themesDir 配置，将其注释掉 ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:6","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"创建文章 创建一篇空文章 hugo new posts/demo.md 另外，需要将生成文章头部的draft=true修改为draft=false，否则并不会生成草稿页面 ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:7","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"启动 hugo 服务器 启动 hugo 服务器，进入 http://localhost:1313/ 预览页面 hugo server -D 页面预览如下 ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:8","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"构建静态页面 若要将博客托管在 github 上，需要上传静态页面。所以，需要使用 hugo 构建静态页面，构建命令如下： hugo -D ","date":"2020-10-10","objectID":"/how-to-create-blog/:2:9","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"使用 Github Pages 搭建个人博客 ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:0","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"个人博客整体架构 一个静态博客数据有两部分，一部分是静态页面（体积小），另一部分是图片或者大文件（文件体积大），通常来讲一个网站整体结构是静态页面放在服务器上（比如可以使用虚拟机、自己的服务器、github pages 项目），而对于大文件或者图片则通常会使用对象存储服务（比如对象存储或者 github 项目），它们前端使用一个 CDN 进行加速（比如云厂商的 CDN 服务或者 cloudinary），当然，在 HTTPS 已经普及的时代，一个 HTTPS 服务也是必不可少的。 整体架构图如下： 经过综合考量，个人建站选用组件如下： 静态网站服务器：Github Pages 图片上传工具：picgo 图片存储服务：Github 项目 + jsdelivr 加速 域名服务商/域名购买：NameCheap HTTPS/CDN 服务提供商：Cloudfare 腾讯云服务中的 TCB 一键建站也挺好用的。但是因为个人图省钱和喜欢折腾，还是选择自己建站自己选择组件，一方面免费，另一方面可以对网络有更加深刻的理解。 ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:1","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"Github Pages 是什么？ GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 index.html、HTML、CSS 和 JavaScript 文件，也可以通过构建过程运行文件，然后发布网站。 GitHub Pages 可以识别指定分支根目录或者/docs 目录下的静态站点，具体可以在个人站点的 setting 中配置。 Github Pages 建站有两种类型： 个人/组织站点，其域名格式形如https://\u003cUSERNAME|ORGANIZATION\u003e.github.io/ 项目站点，其域名格式形如https://\u003cUSERNAME|ORGANIZATION\u003e.github.io/\u003cPROJECT\u003e/ 你需要看清楚你的 Github Pages 建站类型，不同的建站类型的建站方法也不同，具体可以参考 官方手册 这里我们以个人站点（User Pages）为例 ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:2","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"创建 Github Pages 项目 创建一个新的 github 项目，项目名称需要是\u003cusername.github.io\u003e格式，如下图样例 ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:3","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"配置 pages 项目 点击进入 setting，搜索 github pages 关键字，找到相关配置：当前 github 默认分支已经是 main 分支，需要调整下；配置好之后即可通过用户名。github.io最初的 github 页面。 ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:4","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"hugo 生成静态页面 生成静态页面之前需要修改 config.toml 文件中的 baseURL 配置，将其修改为个人站点，比如我的就是 miss-you.github.io 前面我们知道hugo -D可以生成静态页面，但该命令会默认将静态页面生成到 public 目录下，而 Github Pages 仅支持根目录/或者/docs 目录，所以我们需要将静态页面生成到 docs 目录下 hugo -d docs ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:5","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"上传 github pages 项目 静态页面生成完成后，便可以将整个静态页面以及本项目其他文件上传到 github 项目中。先使用git remote命令添加远端仓库，将文件提交（git add+git commit），最后推送到 Github Pages 项目中 git remote add origin git@github.com:Miss-you/miss-you.github.io.git # 将本地 git 项目与 github 项目相关联 git fetch origin # 拉取 github 项目 git checkout main #切换到主分支 main git add . git commit -m \"init github pages\" git push origin 当然，这里也可以采用git clone \u003cYOUR-PROJECT-URL\u003e \u0026\u0026 cd \u003cYOUR-PROJECT\u003e拉取项目、上传文件（git add/commit/push) 的方式，上传 github 项目，这里不作过多演示 ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:6","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"发布脚本 虽然我们已经打通了基于 Github Pages 搭建个人博客的流程，但每次博客有修改都需要执行多条命令才能将博客发布，重复劳动且浪费时间，而程序员的天性是追求效率，应当用自动化（脚本）解决重复的工作。 如下是一个常用脚本，会自动构建静态页面，然后提交构建出来的 docs 静态页面目录，将其推送到对应 Github Pages 项目中 #!/bin/sh # If a command fails then the deploy stops set -e printf \"\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\" # Build the project. hugo -d docs # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Add changes to git. git add docs # Commit changes. msg=\"rebuilding site $(date)\" if [ -n \"$*\" ]; then msg=\"$*\" fi git commit -m \"$msg\" # Push source and build repos. git push origin main ","date":"2020-10-10","objectID":"/how-to-create-blog/:3:7","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"FAQ ","date":"2020-10-10","objectID":"/how-to-create-blog/:4:0","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"常见操作 TODO 文章插入图片 图片上传问题 图片存储问题 TODO 修改模板 TODO 创建友链 TODO 创建联系方式 TODO ","date":"2020-10-10","objectID":"/how-to-create-blog/:4:1","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"常见问题 Github Pages 项目报错：The submodule registered for ./themes/xxx could not be cloned. 原因是 Github Pages 项目，若要使用 submodule 应用第三方主题，需要使用 https 的地址而不是 git 地址 [TOC] 符号不生效 toc 是 markdown 的一种进阶语法，用于自动生成目录，但是 hugo 并没有支持该语法。目录建议采用主题自带的目录功能，比如本文示例中的 LoveIt 主题。 使用 loveit 或者切换到 loveit 主题入门教程： LoveIt 入门教程 找不到主题，Error: module “LoveIt” not found 原因是由于 LoveIt 示例主题中的 config.toml 文件，其主题路径为”../..\"，该目录下并不会有 LoveIt 主题，将其注释掉即可，或者修改 LoveIt 主题所在的相对路径 github 搜索不到 LoveIt 主题 LoveIt 英文小写是 loveit，不是 lovelt，因为不注意的话 I 和 l 难以区分，容易混淆 jsdelivr latest图片找不到问题 https://cdn.jsdelivr.net/gh/Miss-you/img/how-to-create-blog/20201020132241.png https://cdn.jsdelivr.net/gh/Miss-you/img@1.0/how-to-create-blog/20201020132241.png 必须要带版本号才可以找得到 为什么latest用不了？ github的bug，他们的latest默认会去找master分支的，而不是main分支的图片…… ","date":"2020-10-10","objectID":"/how-to-create-blog/:4:2","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["Env"],"content":"参考链接 hugo 中文官方文档 hugo 英文官方文档 hugo 主题站 github pages 官方手册 hugo loveit 主题使用教程 cloudfare 配置教程 picgo 官方教程 ","date":"2020-10-10","objectID":"/how-to-create-blog/:5:0","tags":["blog","github pages"],"title":"使用 Github Pages 和 Hugo 搭建个人博客教程","uri":"/how-to-create-blog/"},{"categories":["GoLang"],"content":"本文主要介绍如何使用 go 语言 database/sql 库从数据库中读取 null 值的问题，以及如何向数据库中插入 null 值。本文在这里使用的是 sql.NullString, sql.NullInt64, sql.NullFloat64 等结构体，为了方便书写，它们的泛指我会使用 sql.Null 来表示. ","date":"2020-10-08","objectID":"/go-mysql-null/","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":" 本文主要介绍如何使用 go 语言 database/sql 库从数据库中读取 null 值的问题，以及如何向数据库中插入 null 值。本文在这里使用的是 sql.NullString, sql.NullInt64, sql.NullFloat64 等结构体，为了方便书写，它们的泛指我会使用 sql.Null 来表示 ","date":"2020-10-08","objectID":"/go-mysql-null/:0:0","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"要点 从数据库读取可能为 null 值得值时，可以选择使用 sql.NULL 来读取；或者使用 IFNULL、COALESCE 等命令让数据库查询值返回不为\"“或者 NULL 若需要往数据库中插入 null 值，则依然可以使用 sql.NULL 存储所需的值，然后进行插入 NULL 值 直接使用 sql.NULL 类型容易出现 valid 遗漏设置等问题，普通 int、string 与其转换时，请写几个简单的 get、set 函数 本 demo 使用的数据库表以及数据如下 mysql\u003e desc person; +------------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +------------+--------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | first_name | varchar(100) | NO | | NULL | | | last_name | varchar(40) | YES | | NULL | | | age | int(11) | YES | | NULL | | +------------+--------------+------+-----+---------+----------------+ mysql\u003e select * from person; +----+------------+-----------+------+ | id | first_name | last_name | age | +----+------------+-----------+------+ | 1 | yousa | NULL | NULL | +----+------------+-----------+------+ mysql\u003e show create table person; +--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | Table | Create Table | +--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | person | CREATE TABLE `person` ( `id` int(11) NOT NULL AUTO_INCREMENT, `first_name` varchar(100) NOT NULL, `last_name` varchar(40) DEFAULT NULL, `age` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 | +--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.00 sec) ","date":"2020-10-08","objectID":"/go-mysql-null/:1:0","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"从数据库中读取 NULL 值 如果不作处理直接从数据库中读取 NULL 值到 string/int，会发生如下错误错误 Scan NULL 值到 string 的报错 sql: Scan error on column index 1: unsupported Scan, storing driver.Value type \u003cnil\u003e into type *string Scan NULL 值到 int 的报错 sql: Scan error on column index 1: converting driver.Value type \u003cnil\u003e (\"\u003cnil\u003e\") to a int: invalid syntax 使用如下的 struct 来读取数据库内容 type Person struct { firstName string lastName string age int } //由于只有一行，直接使用 QueryRow row := db.QueryRow(\"SELECT first_name, last_name FROM person WHERE first_name='yousa'\") err = row.Scan(\u0026hello.firstName, \u0026hello.lastName) if err != nil { fmt.Println(err) } fmt.Println(hello) row1 := db.QueryRow(\"SELECT first_name, age FROM person WHERE first_name='yousa'\") err = row1.Scan(\u0026hello.firstName, \u0026hello.age) if err != nil { fmt.Println(err) } fmt.Println(hello) 运行代码，可以通过日志看出来，错误来自 Scan 将 NULL 值赋值给 int 或者 string 时，报错；解决这个问题可以使用 sql 原生结构体 sql.Null 来解决 ","date":"2020-10-08","objectID":"/go-mysql-null/:2:0","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"使用 sqlNull sql.Null 在 sql 库中声明如下，在读取时，（比如读取的值存储到 NullInt64），假如发现存储的值是 NULL，则会将 NullInt64 的 valid 设置为 false，然后不会将值存储到 Int64 中，Int64 值默认为 0，如果是 NullString 则 String 值时 nil；如果是正常值，则会将 Valid 赋值为 true，将值存储到 Int64 中。 type NullInt64 struct { Int64 int64 Valid bool // Valid is true if Int64 is not NULL } func (n *NullInt64) Scan(value interface{}) error func (n NullInt64) Value() (driver.Value, error) type NullString struct { String string Valid bool // Valid is true if String is not NULL } func (ns *NullString) Scan(value interface{}) error func (ns NullString) Value() (driver.Value, error) 代码修改为如下： type Person struct { firstName string lastNullName sql.NullString nullAge sql.NullInt64 } rowNull := db.QueryRow(\"SELECT first_name, last_name FROM person WHERE first_name='yousa'\") err = rowNull.Scan(\u0026hello.firstName, \u0026hello.lastNullName) if err != nil { fmt.Println(err) } fmt.Println(hello) rowNull1 := db.QueryRow(\"SELECT first_name, age FROM person WHERE first_name='yousa'\") err = rowNull1.Scan(\u0026hello.firstName, \u0026hello.nullAge) if err != nil { fmt.Println(err) } fmt.Println(hello) 输出结果 {yousa 0 { false} {0 false}} ","date":"2020-10-08","objectID":"/go-mysql-null/:2:1","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"使用 IFNULL 或者 COALESCE coalesce() 解释：返回参数中的第一个非空表达式（从左向右依次类推） IFNULL(expr1,expr2): 如果 expr1 不是 NULL，IFNULL() 返回 expr1，否则它返回 expr2。IFNULL() 返回一个数字或字符串值，取决于它被使用的上下文环境。 查询语句使用一个默认值来替换 NULL 即可 SELECT first_name, COALESCE(age, 0) FROM person;// SELECT first_name, IFNULL(age, 0) FROM person;// ","date":"2020-10-08","objectID":"/go-mysql-null/:2:2","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"往数据库中插入 NULL 值 前面我们对 SELECT 语句使用了 sql.Null 类型，同理，INSERT、UPDATE 语句也可以通过使用这种类型来插入 nil 值 代码如下： hello := Person { firstName: \"\", lastName: \"\", age: 0, lastNullName: sql.NullString{String:\"\", Valid:false}, nullAge: sql.NullInt64{Int64:0, Valid:false}} _, err = db.Exec( \"INSERT INTO person (first_name, last_name) VALUES (?, ?)\", \"yousa1\", hello.lastName) if err != nil { fmt.Println(err) } _, err = db.Exec( \"INSERT INTO person (first_name, last_name) VALUES (?, ?)\", \"yousa2\", hello.lastNullName) if err != nil { fmt.Println(err) } //数据库插入结果 mysql\u003e select * from person; +----+------------+-----------+------+ | id | first_name | last_name | age | +----+------------+-----------+------+ | 1 | yousa | NULL | NULL | | 2 | yousa1 | | NULL | | 3 | yousa2 | NULL | NULL | +----+------------+-----------+------+ 解释下 db.Exec 操作 hello.lastNullName 的过程： 首先它会调用 hello.lastNullName 的 Value 方法，获取到 driver.Value，然后检验 Valid 值是 true 还是 false，如果是 false 则会返回一个 nil 值（nil 值传给 sql driver 会被认为是 NULL 值），如果是 true 则会将 hello.lastNullName.String 的值传过去。 PS: 为了保证你所插入的值能如你所期望是 NULL 值，一定记得要将 sql.Null 中 Valid 值置为 false 使用 NULL 还是有很多危害的，再回顾下数据库中使用 NULL 值的危害 ","date":"2020-10-08","objectID":"/go-mysql-null/:3:0","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"为什么不建议使用 NULL 所有使用 NULL 值的情况，都可以通过一个有意义的值的表示，这样有利于代码的可读性和可维护性，并能从约束上增强业务数据的规范性。 NULL 值在 timestamp 类型下容易出问题，特别是没有启用参数 explicit_defaults_for_timestamp NOT IN、!= 等负向条件查询在有 NULL 值的情况下返回永远为空结果，查询容易出错 Null 列需要更多的存储空间：需要一个额外字节作为判断是否为 NULL 的标志位 NULL 值到非 NULL 的更新无法做到原地更新，更容易发生索引分裂，从而影响性能。 PS：但把 NULL 列改为 NOT NULL 带来的性能提示很小，除非确定它带来了问题，否则不要把它当成优先的优化措施，最重要的是使用的列的类型的适当性。 当然有些情况是不得不使用 NULL 值进行存储，或者在查询时由于 left/right join 等导致 NULL 值，但总体来说，能少用就少用。 ","date":"2020-10-08","objectID":"/go-mysql-null/:3:1","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"helper func（提升效率/减少错误） 如果使用 sql.NULL 的话，由于其有两个字段，如果直接手动赋值的话还是很容易遗漏，所以还是需要简单的转换函数，这里给了两个简单的 helper fuc，分别是将 int64 转换成 NullInt64 和将 string 转换成 NullString //ToNullString invalidates a sql.NullString if empty, validates if not empty func ToNullString(s string) sql.NullString { return sql.NullString{String : s, Valid : s != \"\"} } //ToNullInt64 validates a sql.NullInt64 if incoming string evaluates to an integer, invalidates if it does not func ToNullInt64(s string) sql.NullInt64 { i, err := strconv.Atoi(s) return sql.NullInt64{Int64 : int64(i), Valid : err == nil} } ","date":"2020-10-08","objectID":"/go-mysql-null/:4:0","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"},{"categories":["GoLang"],"content":"参考博客 https://github.com/go-sql-driver/mysql/issues/34 https://github.com/guregu/null https://gocn.io/question/243 https://godoc.org/database/sql http://url.cn/5cFTz4W 一千个不用 Null 的理由 ","date":"2020-10-08","objectID":"/go-mysql-null/:5:0","tags":["mysql","golang"],"title":"Go 语言：解决数据库中 null 值的问题","uri":"/go-mysql-null/"}]