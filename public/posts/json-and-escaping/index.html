<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>为什么 JSON 需要转义 | yousa Blog</title>
<meta name="keywords" content="code">
<meta name="description" content="为什么 JSON 需要转义？
[TOC]

适合人群：入门级
JSON 和 JSON 转义
21 世纪初，Douglas Crockford 寻找一种简便的数据交换格式，能够在服务器之间交换数据。当时通用的数据交换语言是 XML，但是 Douglas Crockford 觉得 XML 的生成和解析都太麻烦，所以他提出了一种简化格式，也就是 JSON。
JSON 其结构形如 {&quot;云原生&quot;:&quot;Kubernetes&quot;}，可以很直观的使用字符串表示对象或数据结构。对象或数据结构使用序列化接口转换成 JSON 字符串，比如 Golang 中的json.Marshal接口。
你可能会有这样的疑问：既然 JSON 字符串结构简单，为什么不直接使用字符串拼接的方式，而是要使用 JSON 序列化接口呢？
结果显而易见：JSON 序列化接口会一并将数据中的特殊字符进行转义，防止其破坏 JSON 原有结构。比如数据中含有双引号&quot;特殊字符，序列化接口便会对双引号进行转义，最终结果类似于{&quot;云原生&quot;:&quot;\&quot;Kubernetes\&quot;&quot;}，否则，该场景下直接拼接的字符串会非法。
JSON 转义
许多程序设计语言把双引号字符（&quot;）用作字符串的分界符。反斜线（\）转义字符提供了两种方式来把双引号字符置入字符串中，或者是使用转义序列\&quot;表示单个的&quot;字符本身，而不是作为字符串分界符；或者是直接开始字符&quot;的 16 进制编码值的转义序列\x22来表示&quot;，也可以使用 8 进制编码值的转义序列，如\042。
在 Python 中，下面的代码将会产生语法错误


1


print &#34;Cloud Navite &#34;Hello World!&#34;.&#34;;


而另一段 Python 代码则会产生符合预期的结果


1


print &#34;Cloud Navite \&#34;Hello World!\&#34;.&#34;;


在 JSON 中，也是如此：当使用 json 接口解析字符串{&quot;云原生&quot;:&quot;&quot;Kubernetes&quot;&quot;}时会报错，而解析经过转义的 JSON 字符串{&quot;云原生&quot;:&quot;\&quot;Kubernetes\&quot;&quot;}则会解析成功。">
<meta name="author" content="[厉辉（Yousa）](https://github.com/Miss-you)">
<link rel="canonical" href="http://localhost:1313/posts/json-and-escaping/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/json-and-escaping/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/posts/json-and-escaping/">
  <meta property="og:site_name" content="yousa Blog">
  <meta property="og:title" content="为什么 JSON 需要转义">
  <meta property="og:description" content="为什么 JSON 需要转义？ [TOC]
适合人群：入门级
JSON 和 JSON 转义 21 世纪初，Douglas Crockford 寻找一种简便的数据交换格式，能够在服务器之间交换数据。当时通用的数据交换语言是 XML，但是 Douglas Crockford 觉得 XML 的生成和解析都太麻烦，所以他提出了一种简化格式，也就是 JSON。
JSON 其结构形如 {&#34;云原生&#34;:&#34;Kubernetes&#34;}，可以很直观的使用字符串表示对象或数据结构。对象或数据结构使用序列化接口转换成 JSON 字符串，比如 Golang 中的json.Marshal接口。
你可能会有这样的疑问：既然 JSON 字符串结构简单，为什么不直接使用字符串拼接的方式，而是要使用 JSON 序列化接口呢？
结果显而易见：JSON 序列化接口会一并将数据中的特殊字符进行转义，防止其破坏 JSON 原有结构。比如数据中含有双引号&#34;特殊字符，序列化接口便会对双引号进行转义，最终结果类似于{&#34;云原生&#34;:&#34;\&#34;Kubernetes\&#34;&#34;}，否则，该场景下直接拼接的字符串会非法。
JSON 转义 许多程序设计语言把双引号字符（&#34;）用作字符串的分界符。反斜线（\）转义字符提供了两种方式来把双引号字符置入字符串中，或者是使用转义序列\&#34;表示单个的&#34;字符本身，而不是作为字符串分界符；或者是直接开始字符&#34;的 16 进制编码值的转义序列\x22来表示&#34;，也可以使用 8 进制编码值的转义序列，如\042。
在 Python 中，下面的代码将会产生语法错误
1 print &#34;Cloud Navite &#34;Hello World!&#34;.&#34;; 而另一段 Python 代码则会产生符合预期的结果
1 print &#34;Cloud Navite \&#34;Hello World!\&#34;.&#34;; 在 JSON 中，也是如此：当使用 json 接口解析字符串{&#34;云原生&#34;:&#34;&#34;Kubernetes&#34;&#34;}时会报错，而解析经过转义的 JSON 字符串{&#34;云原生&#34;:&#34;\&#34;Kubernetes\&#34;&#34;}则会解析成功。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-01-05T01:21:26+08:00">
    <meta property="article:modified_time" content="2021-03-02T16:50:28+08:00">
    <meta property="article:tag" content="Code">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="为什么 JSON 需要转义">
<meta name="twitter:description" content="为什么 JSON 需要转义？
[TOC]

适合人群：入门级
JSON 和 JSON 转义
21 世纪初，Douglas Crockford 寻找一种简便的数据交换格式，能够在服务器之间交换数据。当时通用的数据交换语言是 XML，但是 Douglas Crockford 觉得 XML 的生成和解析都太麻烦，所以他提出了一种简化格式，也就是 JSON。
JSON 其结构形如 {&quot;云原生&quot;:&quot;Kubernetes&quot;}，可以很直观的使用字符串表示对象或数据结构。对象或数据结构使用序列化接口转换成 JSON 字符串，比如 Golang 中的json.Marshal接口。
你可能会有这样的疑问：既然 JSON 字符串结构简单，为什么不直接使用字符串拼接的方式，而是要使用 JSON 序列化接口呢？
结果显而易见：JSON 序列化接口会一并将数据中的特殊字符进行转义，防止其破坏 JSON 原有结构。比如数据中含有双引号&quot;特殊字符，序列化接口便会对双引号进行转义，最终结果类似于{&quot;云原生&quot;:&quot;\&quot;Kubernetes\&quot;&quot;}，否则，该场景下直接拼接的字符串会非法。
JSON 转义
许多程序设计语言把双引号字符（&quot;）用作字符串的分界符。反斜线（\）转义字符提供了两种方式来把双引号字符置入字符串中，或者是使用转义序列\&quot;表示单个的&quot;字符本身，而不是作为字符串分界符；或者是直接开始字符&quot;的 16 进制编码值的转义序列\x22来表示&quot;，也可以使用 8 进制编码值的转义序列，如\042。
在 Python 中，下面的代码将会产生语法错误


1


print &#34;Cloud Navite &#34;Hello World!&#34;.&#34;;


而另一段 Python 代码则会产生符合预期的结果


1


print &#34;Cloud Navite \&#34;Hello World!\&#34;.&#34;;


在 JSON 中，也是如此：当使用 json 接口解析字符串{&quot;云原生&quot;:&quot;&quot;Kubernetes&quot;&quot;}时会报错，而解析经过转义的 JSON 字符串{&quot;云原生&quot;:&quot;\&quot;Kubernetes\&quot;&quot;}则会解析成功。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "为什么 JSON 需要转义",
      "item": "http://localhost:1313/posts/json-and-escaping/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "为什么 JSON 需要转义",
  "name": "为什么 JSON 需要转义",
  "description": "为什么 JSON 需要转义？ [TOC]\n适合人群：入门级\nJSON 和 JSON 转义 21 世纪初，Douglas Crockford 寻找一种简便的数据交换格式，能够在服务器之间交换数据。当时通用的数据交换语言是 XML，但是 Douglas Crockford 觉得 XML 的生成和解析都太麻烦，所以他提出了一种简化格式，也就是 JSON。\nJSON 其结构形如 {\u0026quot;云原生\u0026quot;:\u0026quot;Kubernetes\u0026quot;}，可以很直观的使用字符串表示对象或数据结构。对象或数据结构使用序列化接口转换成 JSON 字符串，比如 Golang 中的json.Marshal接口。\n你可能会有这样的疑问：既然 JSON 字符串结构简单，为什么不直接使用字符串拼接的方式，而是要使用 JSON 序列化接口呢？\n结果显而易见：JSON 序列化接口会一并将数据中的特殊字符进行转义，防止其破坏 JSON 原有结构。比如数据中含有双引号\u0026quot;特殊字符，序列化接口便会对双引号进行转义，最终结果类似于{\u0026quot;云原生\u0026quot;:\u0026quot;\\\u0026quot;Kubernetes\\\u0026quot;\u0026quot;}，否则，该场景下直接拼接的字符串会非法。\nJSON 转义 许多程序设计语言把双引号字符（\u0026quot;）用作字符串的分界符。反斜线（\\）转义字符提供了两种方式来把双引号字符置入字符串中，或者是使用转义序列\\\u0026quot;表示单个的\u0026quot;字符本身，而不是作为字符串分界符；或者是直接开始字符\u0026quot;的 16 进制编码值的转义序列\\x22来表示\u0026quot;，也可以使用 8 进制编码值的转义序列，如\\042。\n在 Python 中，下面的代码将会产生语法错误\n1 print \u0026#34;Cloud Navite \u0026#34;Hello World!\u0026#34;.\u0026#34;; 而另一段 Python 代码则会产生符合预期的结果\n1 print \u0026#34;Cloud Navite \\\u0026#34;Hello World!\\\u0026#34;.\u0026#34;; 在 JSON 中，也是如此：当使用 json 接口解析字符串{\u0026quot;云原生\u0026quot;:\u0026quot;\u0026quot;Kubernetes\u0026quot;\u0026quot;}时会报错，而解析经过转义的 JSON 字符串{\u0026quot;云原生\u0026quot;:\u0026quot;\\\u0026quot;Kubernetes\\\u0026quot;\u0026quot;}则会解析成功。\n",
  "keywords": [
    "code"
  ],
  "articleBody": "为什么 JSON 需要转义？ [TOC]\n适合人群：入门级\nJSON 和 JSON 转义 21 世纪初，Douglas Crockford 寻找一种简便的数据交换格式，能够在服务器之间交换数据。当时通用的数据交换语言是 XML，但是 Douglas Crockford 觉得 XML 的生成和解析都太麻烦，所以他提出了一种简化格式，也就是 JSON。\nJSON 其结构形如 {\"云原生\":\"Kubernetes\"}，可以很直观的使用字符串表示对象或数据结构。对象或数据结构使用序列化接口转换成 JSON 字符串，比如 Golang 中的json.Marshal接口。\n你可能会有这样的疑问：既然 JSON 字符串结构简单，为什么不直接使用字符串拼接的方式，而是要使用 JSON 序列化接口呢？\n结果显而易见：JSON 序列化接口会一并将数据中的特殊字符进行转义，防止其破坏 JSON 原有结构。比如数据中含有双引号\"特殊字符，序列化接口便会对双引号进行转义，最终结果类似于{\"云原生\":\"\\\"Kubernetes\\\"\"}，否则，该场景下直接拼接的字符串会非法。\nJSON 转义 许多程序设计语言把双引号字符（\"）用作字符串的分界符。反斜线（\\）转义字符提供了两种方式来把双引号字符置入字符串中，或者是使用转义序列\\\"表示单个的\"字符本身，而不是作为字符串分界符；或者是直接开始字符\"的 16 进制编码值的转义序列\\x22来表示\"，也可以使用 8 进制编码值的转义序列，如\\042。\n在 Python 中，下面的代码将会产生语法错误\n1 print \"Cloud Navite \"Hello World!\".\"; 而另一段 Python 代码则会产生符合预期的结果\n1 print \"Cloud Navite \\\"Hello World!\\\".\"; 在 JSON 中，也是如此：当使用 json 接口解析字符串{\"云原生\":\"\"Kubernetes\"\"}时会报错，而解析经过转义的 JSON 字符串{\"云原生\":\"\\\"Kubernetes\\\"\"}则会解析成功。\nJSON 转义机制如下图：\nJSON 中字符串针对于特殊字符需要 JSON 转义，它使用反斜杠\\进行转义 JSON 序列包括“\\\\、\\\"、\\/、\\b、\\f、\\n、\\r、\\t，或者 Unicode16 进制转义字符（比如\\uD83D\\uDE02) JSON 字符串默认为 UTF-8 编码。可以通过观察前四个八位字节中的空值模式来确定一个八位字节流是 UTF-8、UTF-16（BE 或 LE）还是 UTF-32（BE 或 LE） JSON 语法 在讲具体案例之前，复习一下 JSON 语法，忘记的可以翻阅该章节。\nJSON 语法简单来说就是四条：\n数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组 声明：以下使用的对象均来自于以下内容\n1 2 3 4 5 6 7 8 9 10 { \"virtualeNB\":[ {\"virteNBName\":\"virt1\", \"virteNBNum\":5, \"begineNBID\":0, \"beginCtlPort\":6000, \"beginDataPort\":7000, \"virtIPNum\":5}, {\"virteNBName\":\"virt2\", \"virteNBNum\":10, \"begineNBID\":10, \"beginCtlPort\":6000, \"beginDataPort\":7000, \"virtIPNum\":10} ], \"eRAN\":[ {\"eRANName\":\"eNB1\", \"eRANID\":3002, \"ctlPort\":36412, \"dataPort\":2152}, {\"eRANName\":\"eNB2\", \"eRANID\":10000, \"ctlPort\":36412, \"dataPort\":2152} ] } 1. JSON 名称/值对 JSON 数据的书写格式是：名称：值，这样的一对。即名称在前，该名称的值在冒号后面。例如：\n1 \"virteNBName\":\"virt1\" 这里的名称是\"virteNBName\"，值是\"virt1\"，他们均是字符串\n名称和值得类型可以有以下几种：\n数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null 2. JSON 数据由逗号分隔 譬如：\n\"virteNBName\":\"virt1\", \"virteNBNum\":5, \"begineNBID\":0这几个对象之间就是使用逗号分隔。\n数组内的对象之间当然也是要用逗号分隔。只要是对象之间，分隔就是用逗号,。但是，要注意，对象结束的时候，不要加逗号。数组内也是，例如：\n1 2 3 4 [ {\"eRANName\":\"eNB1\", \"eRANID\":3002, \"ctlPort\":36412, \"dataPort\":2152}, {\"eRANName\":\"eNB2\", \"eRANID\":10000, \"ctlPort\":36412, \"dataPort\":2152}, ] 上面这个就是错误的，因为在数组中，两个对象之间需要逗号，但是到这个数组末尾了，不需要加逗号了。\n3. JSON 花括号保存对象 对象可以包含多个名称/值对，如：\n1 {\"eRANName\":\"eNB1\", \"eRANID\":3002, \"ctlPort\":36412, \"dataPort\":2152} 这一点也容易理解，与这条 JavaScript 语句等价：\n1 2 3 4 \"eRANName\" = \"eNB1\" \"eRANID\" = 3002 \"ctlPort\" = 36412 \"dataPort\" = 2152 4. JSON 方括号保存数组 数组可包含多个对象：\n1 2 3 4 \"eRAN\":[ {\"eRANName\":\"eNB1\", \"eRANID\":3002, \"ctlPort\":36412, \"dataPort\":2152}, {\"eRANName\":\"eNB2\", \"eRANID\":10000, \"ctlPort\":36412, \"dataPort\":2152} ] 在上面的例子中，对象 “eRAN” 是包含 2 个对象的数组。每个对象代表一条基站的记录。\n上面四条规则，就是 JSON 格式的所有内容。\n案例 一个由特殊字符导致 JSON 格式的 Nginx 访问日志/日志系统的 BUG 访问日志 access_log：Nginx 会将每个客户端访问其本身的请求以日志的形式记录到指定的日志文件里，以供分析用户的浏览或请求行为，或者可以用于快速分析故障所在。此功能由 ngx_http_log_module 模块负责。\n在 Nginx 文件中，访问日志 access.log 配置形如下文的格式：\n1 2 3 4 log_format main '$remote_addr [$time_local] \"$request\" ' '$status $bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log logs/access.log main buffer=32k; logs/access.log 指定访问日志路径 log_format 定义访问日志格式 buffer=32k 是日志缓冲区大小 访问日志 access_log 其通过格式化输出 nginx 变量以及拼接字符串的方式打印日志。\n在云原生时代，Nginx 运维的最佳实践之一就是将 Nginx 访问日志采用 EFK 架构 (Elasticsearch+Filebeat+Kibana)，通过收集和管理访问日志，提供统一的检索功能，这样做不仅可以提高诊断效率，而且可以全面了解系统情况，避免被动事后救火。\n通常，为了方便分析，会将 Nginx 访问日志输出为 JSON 字符串，其配置如下：\n1 2 3 4 log_format main '{\"remote_addr\":\"$remote_addr\",\"time_local\":\"$time_local\",\"request\":\"$request\",' '\"status\":\"$status\",\"bytes_sent\":\"$bytes_sent\",\"http_referer\":\"$http_referer\",' '\"http_user_agent\":\"$http_user_agent\",\"http_x_forwarded_for\":\"$http_x_forwarded_for\"}'; access_log logs/access.log main buffer=32k; 乍一看，这样的配置没什么问题。但再深入思考，生成 JSON 字符串的标准做法是调用 JSON 序列化接口，而 Nginx 访问日志是直接格式化拼接字符串，故一旦访问日志中出现特殊字符（比如双引号\"），就会导致整行访问日志解析出错，影响接下来的日志分析系统对访问日志的数据查找、服务诊断和数据分析。\n为了解决 JSON 转义的问题，Nginx 在 1.11.8 版本中给日志格式 log_format 新增了序列化配置 escape=json，其格式为：\n1 2 3 4 Syntax:\tlog_format name [escape=default|json|none] string ...; Default:\tlog_format combined \"...\"; Context:\thttp 当配置为 escape=json 时，JSON 字符串中所有不允许的字符都将被转义：\n\"和/字符被转义为/\"和// 值小于 32 的字符被转义“\\n”, “\\r”, “\\t”, “\\b”, “\\f”, or “\\u00XX” 所以，正确的 log_format 配置为\n1 2 3 log_format main escape=json '{\"remote_addr\":\"$remote_addr\",\"time_local\":\"$time_local\",\"request\":\"$request\",' '\"status\":\"$status\",\"bytes_sent\":\"$bytes_sent\",\"http_referer\":\"$http_referer\",' '\"http_user_agent\":\"$http_user_agent\",\"http_x_forwarded_for\":\"$http_x_forwarded_for\"}'; 当然，因为 JSON 转义导致的 BUG 不止这一个，近期遇到的另一个 BUG 也是因为前人实现的代码实现不规范，其逻辑是将收到的请求以字符串拼接的方式构造 JSON 串，导致一旦请求中带有双引号\"或其他特殊字符，就必定出现 BUG。\nJSON 与其他格式的比较 JSON vs XML JSON 与 XML 最大的不同在于 XML 是一个完整的标记语言，而 JSON 不是。这使得 XML 在程序判读上需要比较多的功夫。主要的原因在于 XML 的设计理念与 JSON 不同。XML 利用标记语言的特性提供了绝佳的延展性（如 XPath），在数据存储，扩展及高级检索方面具备对 JSON 的优势，而 JSON 则由于比 XML 更加小巧，以及浏览器的内建快速解析支持，使得其更适用于网络数据传输领域。\n从转义角度来看，XML 标签名不能包含任何字符!\"#$%\u0026'()*+,/;\u003c=\u003e?@[\\]^{|}~，也不能包含空格字符，不能以-、.或数字数字开头，而 JSON 键可以（引号和反斜杠必须转义）。\nJSON vs YAML JSON 格式简单易上手，但没有了 YAML 的一目了然，尤其是 JSON 数据很长的时候，会让人陷入繁琐复杂的数据节点查找中。通常我会使用在线 JSON 格式化工具，来更方便的对 JSON 数据进行节点查找和解析。\n个人认为，YAML 几乎将 JSON 秒成渣渣，这里直接引用 YAML 官方文档 关于 YAML 的总结：\nYAML 的可读性好 YAML 和脚本语言的交互性好 YAML 使用实现语言的数据类型 YAML 有一个一致的信息模型 YAML 易于实现 YAML 可以基于流来处理 YAML 表达能力强，扩展性好 YAML 可以写注释 There Is One More Thing 从结构上看，不仅仅是 JSON、YAML、XML，大部分或者所有的数据（data）最终都可以分解成三种类型：\n第一种类型是标量（scalar），也就是一个单独的字符串（string）或数字（numbers），比如\"云原生\"这个单独的词。\n第二种类型是序列（sequence），也就是若干个相关的数据按照一定顺序并列在一起，又叫做数组（array）或列表（List），比如[\"Kubernetes\", \"Istio\"]。\n第三种类型是映射（mapping），也就是一个名/值对（Name/value），即数据有一个名称，还有一个与之相对应的值，这又称作散列（hash）或字典（dictionary），比如\"CloudNative\": \"Kubernetes\"。\n参考 JSON 官网 JSON 维基百科 数据类型和 Json 格式–阮一峰 YAML Ain’t Markup Language (YAML™) Version 1.1 World Wide Web Consortium 自己最初了解 JSON 时总结的一篇文章 ",
  "wordCount" : "474",
  "inLanguage": "en",
  "datePublished": "2021-01-05T01:21:26+08:00",
  "dateModified": "2021-03-02T16:50:28+08:00",
  "author":{
    "@type": "Person",
    "name": "[厉辉（Yousa）](https://github.com/Miss-you)"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/json-and-escaping/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "yousa Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="yousa Blog (Alt + H)">yousa Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:1313/zh/" title="中文"
                            aria-label="中文">Zh</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/Miss-you" title="GitHub">
                    <span>GitHub</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      为什么 JSON 需要转义
    </h1>
    <div class="post-meta"><span title='2021-01-05 01:21:26 +0800 CST'>January 5, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;474 words&nbsp;·&nbsp;[厉辉（Yousa）](https://github.com/Miss-you)&nbsp;|&nbsp;<a href="https://github.com/Miss-you/miss-you.github.io/tree/main/content/posts/json-and-escaping.md" rel="noopener noreferrer edit" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#json-和-json-转义">JSON 和 JSON 转义</a>
      <ul>
        <li><a href="#json-转义">JSON 转义</a></li>
        <li><a href="#json-语法">JSON 语法</a></li>
      </ul>
    </li>
    <li><a href="#案例">案例</a>
      <ul>
        <li><a href="#一个由特殊字符导致-json-格式的-nginx-访问日志日志系统的-bug">一个由特殊字符导致 JSON 格式的 Nginx 访问日志/日志系统的 BUG</a></li>
      </ul>
    </li>
    <li><a href="#json-与其他格式的比较">JSON 与其他格式的比较</a>
      <ul>
        <li><a href="#json-vs-xml">JSON vs XML</a></li>
        <li><a href="#json-vs-yaml">JSON vs YAML</a></li>
      </ul>
    </li>
    <li><a href="#there-is-one-more-thing">There Is One More Thing</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="为什么-json-需要转义">为什么 JSON 需要转义？<a hidden class="anchor" aria-hidden="true" href="#为什么-json-需要转义">#</a></h1>
<p>[TOC]</p>
<blockquote>
<p>适合人群：入门级</p></blockquote>
<h2 id="json-和-json-转义">JSON 和 JSON 转义<a hidden class="anchor" aria-hidden="true" href="#json-和-json-转义">#</a></h2>
<p>21 世纪初，Douglas Crockford 寻找一种简便的数据交换格式，能够在服务器之间交换数据。当时通用的数据交换语言是 XML，但是 Douglas Crockford 觉得 XML 的生成和解析都太麻烦，所以他提出了一种简化格式，也就是 JSON。</p>
<p>JSON 其结构形如 <code>{&quot;云原生&quot;:&quot;Kubernetes&quot;}</code>，可以很直观的使用字符串表示对象或数据结构。对象或数据结构使用序列化接口转换成 JSON 字符串，比如 Golang 中的<code>json.Marshal</code>接口。</p>
<p>你可能会有这样的疑问：既然 JSON 字符串结构简单，为什么不直接使用字符串拼接的方式，而是要使用 JSON 序列化接口呢？</p>
<p>结果显而易见：JSON 序列化接口会一并将数据中的特殊字符进行转义，防止其破坏 JSON 原有结构。比如数据中含有双引号<code>&quot;</code>特殊字符，序列化接口便会对双引号进行转义，最终结果类似于<code>{&quot;云原生&quot;:&quot;\&quot;Kubernetes\&quot;&quot;}</code>，否则，该场景下直接拼接的字符串会非法。</p>
<h3 id="json-转义">JSON 转义<a hidden class="anchor" aria-hidden="true" href="#json-转义">#</a></h3>
<p>许多程序设计语言把双引号字符<code>（&quot;）</code>用作字符串的分界符。反斜线<code>（\）</code>转义字符提供了两种方式来把双引号字符置入字符串中，或者是使用转义序列<code>\&quot;</code>表示单个的<code>&quot;</code>字符本身，而不是作为字符串分界符；或者是直接开始字符<code>&quot;</code>的 16 进制编码值的转义序列<code>\x22</code>来表示<code>&quot;</code>，也可以使用 8 进制编码值的转义序列，如<code>\042</code>。</p>
<p>在 Python 中，下面的代码将会产生语法错误</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-0-1"><a class="lnlinks" href="#hl-0-1">1</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">print &#34;Cloud Navite &#34;Hello World!&#34;.&#34;;
</span></span></code></pre></td></tr></table>
</div>
</div><p>而另一段 Python 代码则会产生符合预期的结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-1-1"><a class="lnlinks" href="#hl-1-1">1</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">print &#34;Cloud Navite \&#34;Hello World!\&#34;.&#34;;
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 JSON 中，也是如此：当使用 json 接口解析字符串<code>{&quot;云原生&quot;:&quot;&quot;Kubernetes&quot;&quot;}</code>时会报错，而解析经过转义的 JSON 字符串<code>{&quot;云原生&quot;:&quot;\&quot;Kubernetes\&quot;&quot;}</code>则会解析成功。</p>
<p>JSON 转义机制如下图：</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/Miss-you/img/picgo/20201228022357.png"></p>
<ol>
<li>JSON 中字符串针对于特殊字符需要 JSON 转义，它使用反斜杠<code>\</code>进行转义</li>
<li>JSON 序列包括<code>“\\、\&quot;、\/、\b、\f、\n、\r、\t</code>，或者 Unicode16 进制转义字符（比如<code>\uD83D\uDE02</code>)</li>
<li>JSON 字符串默认为 UTF-8 编码。可以通过观察前四个八位字节中的空值模式来确定一个八位字节流是 UTF-8、UTF-16（BE 或 LE）还是 UTF-32（BE 或 LE）</li>
</ol>
<h3 id="json-语法">JSON 语法<a hidden class="anchor" aria-hidden="true" href="#json-语法">#</a></h3>
<blockquote>
<p>在讲具体案例之前，复习一下 JSON 语法，忘记的可以翻阅该章节。</p></blockquote>
<p>JSON 语法简单来说就是四条：</p>
<ul>
<li>数据在名称/值对中</li>
<li>数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<blockquote>
<p>声明：以下使用的对象均来自于以下内容</p></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-2-1"><a class="lnlinks" href="#hl-2-1"> 1</a>
</span><span class="lnt" id="hl-2-2"><a class="lnlinks" href="#hl-2-2"> 2</a>
</span><span class="lnt" id="hl-2-3"><a class="lnlinks" href="#hl-2-3"> 3</a>
</span><span class="lnt" id="hl-2-4"><a class="lnlinks" href="#hl-2-4"> 4</a>
</span><span class="lnt" id="hl-2-5"><a class="lnlinks" href="#hl-2-5"> 5</a>
</span><span class="lnt" id="hl-2-6"><a class="lnlinks" href="#hl-2-6"> 6</a>
</span><span class="lnt" id="hl-2-7"><a class="lnlinks" href="#hl-2-7"> 7</a>
</span><span class="lnt" id="hl-2-8"><a class="lnlinks" href="#hl-2-8"> 8</a>
</span><span class="lnt" id="hl-2-9"><a class="lnlinks" href="#hl-2-9"> 9</a>
</span><span class="lnt" id="hl-2-10"><a class="lnlinks" href="#hl-2-10">10</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    &#34;virtualeNB&#34;:[
</span></span><span class="line"><span class="cl">        {&#34;virteNBName&#34;:&#34;virt1&#34;, &#34;virteNBNum&#34;:5, &#34;begineNBID&#34;:0, &#34;beginCtlPort&#34;:6000, &#34;beginDataPort&#34;:7000, &#34;virtIPNum&#34;:5},
</span></span><span class="line"><span class="cl">        {&#34;virteNBName&#34;:&#34;virt2&#34;, &#34;virteNBNum&#34;:10, &#34;begineNBID&#34;:10, &#34;beginCtlPort&#34;:6000, &#34;beginDataPort&#34;:7000, &#34;virtIPNum&#34;:10}
</span></span><span class="line"><span class="cl">    ],
</span></span><span class="line"><span class="cl">    &#34;eRAN&#34;:[
</span></span><span class="line"><span class="cl">        {&#34;eRANName&#34;:&#34;eNB1&#34;, &#34;eRANID&#34;:3002, &#34;ctlPort&#34;:36412, &#34;dataPort&#34;:2152},
</span></span><span class="line"><span class="cl">        {&#34;eRANName&#34;:&#34;eNB2&#34;, &#34;eRANID&#34;:10000, &#34;ctlPort&#34;:36412, &#34;dataPort&#34;:2152}
</span></span><span class="line"><span class="cl">    ]
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="1-json-名称值对">1. JSON 名称/值对<a hidden class="anchor" aria-hidden="true" href="#1-json-名称值对">#</a></h4>
<p>JSON 数据的书写格式是：名称：值，这样的一对。即名称在前，该名称的值在冒号后面。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-3-1"><a class="lnlinks" href="#hl-3-1">1</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34;virteNBName&#34;:&#34;virt1&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的名称是<code>&quot;virteNBName&quot;</code>，值是<code>&quot;virt1&quot;</code>，他们均是字符串</p>
<p>名称和值得类型可以有以下几种：</p>
<ul>
<li>数字（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li>数组（在方括号中）</li>
<li>对象（在花括号中）</li>
<li>null</li>
</ul>
<h4 id="2-json-数据由逗号分隔">2. JSON 数据由逗号分隔<a hidden class="anchor" aria-hidden="true" href="#2-json-数据由逗号分隔">#</a></h4>
<p>譬如：</p>
<p><code>&quot;virteNBName&quot;:&quot;virt1&quot;, &quot;virteNBNum&quot;:5, &quot;begineNBID&quot;:0</code>这几个对象之间就是使用逗号分隔。</p>
<p>数组内的对象之间当然也是要用逗号分隔。只要是对象之间，分隔就是用逗号<code>,</code>。但是，要注意，对象结束的时候，不要加逗号。数组内也是，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-4-1"><a class="lnlinks" href="#hl-4-1">1</a>
</span><span class="lnt" id="hl-4-2"><a class="lnlinks" href="#hl-4-2">2</a>
</span><span class="lnt" id="hl-4-3"><a class="lnlinks" href="#hl-4-3">3</a>
</span><span class="lnt" id="hl-4-4"><a class="lnlinks" href="#hl-4-4">4</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[
</span></span><span class="line"><span class="cl">    {&#34;eRANName&#34;:&#34;eNB1&#34;, &#34;eRANID&#34;:3002, &#34;ctlPort&#34;:36412, &#34;dataPort&#34;:2152},
</span></span><span class="line"><span class="cl">    {&#34;eRANName&#34;:&#34;eNB2&#34;, &#34;eRANID&#34;:10000, &#34;ctlPort&#34;:36412, &#34;dataPort&#34;:2152},
</span></span><span class="line"><span class="cl">]
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面这个就是错误的，因为在数组中，两个对象之间需要逗号，但是到这个数组末尾了，不需要加逗号了。</p>
<h4 id="3-json-花括号保存对象">3. JSON 花括号保存对象<a hidden class="anchor" aria-hidden="true" href="#3-json-花括号保存对象">#</a></h4>
<p>对象可以包含多个名称/值对，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-5-1"><a class="lnlinks" href="#hl-5-1">1</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">{&#34;eRANName&#34;:&#34;eNB1&#34;, &#34;eRANID&#34;:3002, &#34;ctlPort&#34;:36412, &#34;dataPort&#34;:2152}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这一点也容易理解，与这条 JavaScript 语句等价：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-6-1"><a class="lnlinks" href="#hl-6-1">1</a>
</span><span class="lnt" id="hl-6-2"><a class="lnlinks" href="#hl-6-2">2</a>
</span><span class="lnt" id="hl-6-3"><a class="lnlinks" href="#hl-6-3">3</a>
</span><span class="lnt" id="hl-6-4"><a class="lnlinks" href="#hl-6-4">4</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34;eRANName&#34; = &#34;eNB1&#34;
</span></span><span class="line"><span class="cl">&#34;eRANID&#34; = 3002
</span></span><span class="line"><span class="cl">&#34;ctlPort&#34; = 36412
</span></span><span class="line"><span class="cl">&#34;dataPort&#34; = 2152
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="4-json-方括号保存数组">4. JSON 方括号保存数组<a hidden class="anchor" aria-hidden="true" href="#4-json-方括号保存数组">#</a></h4>
<p>数组可包含多个对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-7-1"><a class="lnlinks" href="#hl-7-1">1</a>
</span><span class="lnt" id="hl-7-2"><a class="lnlinks" href="#hl-7-2">2</a>
</span><span class="lnt" id="hl-7-3"><a class="lnlinks" href="#hl-7-3">3</a>
</span><span class="lnt" id="hl-7-4"><a class="lnlinks" href="#hl-7-4">4</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34;eRAN&#34;:[
</span></span><span class="line"><span class="cl">    {&#34;eRANName&#34;:&#34;eNB1&#34;, &#34;eRANID&#34;:3002, &#34;ctlPort&#34;:36412, &#34;dataPort&#34;:2152},
</span></span><span class="line"><span class="cl">    {&#34;eRANName&#34;:&#34;eNB2&#34;, &#34;eRANID&#34;:10000, &#34;ctlPort&#34;:36412, &#34;dataPort&#34;:2152}
</span></span><span class="line"><span class="cl">]
</span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的例子中，对象 &ldquo;eRAN&rdquo; 是包含 2 个对象的数组。每个对象代表一条基站的记录。</p>
<p>上面四条规则，就是 JSON 格式的所有内容。</p>
<h2 id="案例">案例<a hidden class="anchor" aria-hidden="true" href="#案例">#</a></h2>
<h3 id="一个由特殊字符导致-json-格式的-nginx-访问日志日志系统的-bug">一个由特殊字符导致 JSON 格式的 Nginx 访问日志/日志系统的 BUG<a hidden class="anchor" aria-hidden="true" href="#一个由特殊字符导致-json-格式的-nginx-访问日志日志系统的-bug">#</a></h3>
<p>访问日志 <code>access_log</code>：Nginx 会将每个客户端访问其本身的请求以日志的形式记录到指定的日志文件里，以供分析用户的浏览或请求行为，或者可以用于快速分析故障所在。此功能由 <code>ngx_http_log_module</code> 模块负责。</p>
<p>在 Nginx 文件中，访问日志 <code>access.log</code> 配置形如下文的格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-8-1"><a class="lnlinks" href="#hl-8-1">1</a>
</span><span class="lnt" id="hl-8-2"><a class="lnlinks" href="#hl-8-2">2</a>
</span><span class="lnt" id="hl-8-3"><a class="lnlinks" href="#hl-8-3">3</a>
</span><span class="lnt" id="hl-8-4"><a class="lnlinks" href="#hl-8-4">4</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">log_format  main  &#39;$remote_addr [$time_local] &#34;$request&#34; &#39;
</span></span><span class="line"><span class="cl">                    &#39;$status $bytes_sent &#34;$http_referer&#34; &#39;
</span></span><span class="line"><span class="cl">                    &#39;&#34;$http_user_agent&#34; &#34;$http_x_forwarded_for&#34;&#39;;
</span></span><span class="line"><span class="cl">access_log  logs/access.log  main buffer=32k;
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>logs/access.log</code> 指定访问日志路径</li>
<li><code>log_format</code> 定义访问日志格式</li>
<li><code>buffer=32k</code> 是日志缓冲区大小</li>
</ul>
<p>访问日志 <code>access_log</code> 其通过格式化输出 <code>nginx</code> 变量以及拼接字符串的方式打印日志。</p>
<p>在云原生时代，Nginx 运维的最佳实践之一就是将 Nginx 访问日志采用 EFK 架构 <code>(Elasticsearch+Filebeat+Kibana)</code>，通过收集和管理访问日志，提供统一的检索功能，这样做不仅可以提高诊断效率，而且可以全面了解系统情况，避免被动事后救火。</p>
<p>通常，为了方便分析，会将 Nginx 访问日志输出为 JSON 字符串，其配置如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-9-1"><a class="lnlinks" href="#hl-9-1">1</a>
</span><span class="lnt" id="hl-9-2"><a class="lnlinks" href="#hl-9-2">2</a>
</span><span class="lnt" id="hl-9-3"><a class="lnlinks" href="#hl-9-3">3</a>
</span><span class="lnt" id="hl-9-4"><a class="lnlinks" href="#hl-9-4">4</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">log_format  main  &#39;{&#34;remote_addr&#34;:&#34;$remote_addr&#34;,&#34;time_local&#34;:&#34;$time_local&#34;,&#34;request&#34;:&#34;$request&#34;,&#39;
</span></span><span class="line"><span class="cl">                    &#39;&#34;status&#34;:&#34;$status&#34;,&#34;bytes_sent&#34;:&#34;$bytes_sent&#34;,&#34;http_referer&#34;:&#34;$http_referer&#34;,&#39;
</span></span><span class="line"><span class="cl">                    &#39;&#34;http_user_agent&#34;:&#34;$http_user_agent&#34;,&#34;http_x_forwarded_for&#34;:&#34;$http_x_forwarded_for&#34;}&#39;;
</span></span><span class="line"><span class="cl">access_log  logs/access.log  main buffer=32k;
</span></span></code></pre></td></tr></table>
</div>
</div><p>乍一看，这样的配置没什么问题。但再深入思考，生成 JSON 字符串的标准做法是调用 JSON 序列化接口，而 Nginx 访问日志是直接格式化拼接字符串，故一旦访问日志中出现特殊字符（比如双引号<code>&quot;</code>），就会导致整行访问日志解析出错，影响接下来的日志分析系统对访问日志的数据查找、服务诊断和数据分析。</p>
<p>为了解决 JSON 转义的问题，Nginx 在 1.11.8 版本中给日志格式 <code>log_format</code> 新增了序列化配置 <code>escape=json</code>，其格式为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-10-1"><a class="lnlinks" href="#hl-10-1">1</a>
</span><span class="lnt" id="hl-10-2"><a class="lnlinks" href="#hl-10-2">2</a>
</span><span class="lnt" id="hl-10-3"><a class="lnlinks" href="#hl-10-3">3</a>
</span><span class="lnt" id="hl-10-4"><a class="lnlinks" href="#hl-10-4">4</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Syntax:	log_format name [escape=default|json|none] string ...;
</span></span><span class="line"><span class="cl">Default:	
</span></span><span class="line"><span class="cl">log_format combined &#34;...&#34;;
</span></span><span class="line"><span class="cl">Context:	http
</span></span></code></pre></td></tr></table>
</div>
</div><p>当配置为 <code>escape=json</code> 时，JSON 字符串中所有不允许的字符都将被转义：</p>
<ul>
<li><code>&quot;</code>和<code>/</code>字符被转义为<code>/&quot;</code>和<code>//</code></li>
<li>值小于 32 的字符被转义<code>“\n”, “\r”, “\t”, “\b”, “\f”, or “\u00XX”</code></li>
</ul>
<p>所以，正确的 <code>log_format</code> 配置为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt" id="hl-11-1"><a class="lnlinks" href="#hl-11-1">1</a>
</span><span class="lnt" id="hl-11-2"><a class="lnlinks" href="#hl-11-2">2</a>
</span><span class="lnt" id="hl-11-3"><a class="lnlinks" href="#hl-11-3">3</a>
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">log_format  main  escape=json &#39;{&#34;remote_addr&#34;:&#34;$remote_addr&#34;,&#34;time_local&#34;:&#34;$time_local&#34;,&#34;request&#34;:&#34;$request&#34;,&#39;
</span></span><span class="line"><span class="cl">                    &#39;&#34;status&#34;:&#34;$status&#34;,&#34;bytes_sent&#34;:&#34;$bytes_sent&#34;,&#34;http_referer&#34;:&#34;$http_referer&#34;,&#39;
</span></span><span class="line"><span class="cl">                    &#39;&#34;http_user_agent&#34;:&#34;$http_user_agent&#34;,&#34;http_x_forwarded_for&#34;:&#34;$http_x_forwarded_for&#34;}&#39;;
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然，因为 JSON 转义导致的 BUG 不止这一个，近期遇到的另一个 BUG 也是因为前人实现的代码实现不规范，其逻辑是将收到的请求以字符串拼接的方式构造 JSON 串，导致一旦请求中带有双引号<code>&quot;</code>或其他特殊字符，就必定出现 BUG。</p>
<h2 id="json-与其他格式的比较">JSON 与其他格式的比较<a hidden class="anchor" aria-hidden="true" href="#json-与其他格式的比较">#</a></h2>
<h3 id="json-vs-xml">JSON vs XML<a hidden class="anchor" aria-hidden="true" href="#json-vs-xml">#</a></h3>
<p>JSON 与 XML 最大的不同在于 XML 是一个完整的标记语言，而 JSON 不是。这使得 XML 在程序判读上需要比较多的功夫。主要的原因在于 XML 的设计理念与 JSON 不同。XML 利用标记语言的特性提供了绝佳的延展性（如 XPath），在数据存储，扩展及高级检索方面具备对 JSON 的优势，而 JSON 则由于比 XML 更加小巧，以及浏览器的内建快速解析支持，使得其更适用于网络数据传输领域。</p>
<p>从转义角度来看，XML 标签名不能包含任何字符<code>!&quot;#$%&amp;'()*+,/;&lt;=&gt;?@[\]^{|}~</code>，也不能包含空格字符，不能以<code>-</code>、<code>.</code>或数字数字开头，而 JSON 键可以（引号和反斜杠必须转义）。</p>
<h3 id="json-vs-yaml">JSON vs YAML<a hidden class="anchor" aria-hidden="true" href="#json-vs-yaml">#</a></h3>
<p>JSON 格式简单易上手，但没有了 YAML 的一目了然，尤其是 JSON 数据很长的时候，会让人陷入繁琐复杂的数据节点查找中。通常我会使用在线 JSON 格式化工具，来更方便的对 JSON 数据进行节点查找和解析。</p>
<p>个人认为，YAML 几乎将 JSON 秒成渣渣，这里直接引用 <a href="https://yaml.org/spec/1.1/index.html">YAML 官方文档</a> 关于 YAML 的总结：</p>
<ul>
<li>YAML 的可读性好</li>
<li>YAML 和脚本语言的交互性好</li>
<li>YAML 使用实现语言的数据类型</li>
<li>YAML 有一个一致的信息模型</li>
<li>YAML 易于实现</li>
<li>YAML 可以基于流来处理</li>
<li>YAML 表达能力强，扩展性好</li>
<li>YAML 可以写注释</li>
</ul>
<h2 id="there-is-one-more-thing">There Is One More Thing<a hidden class="anchor" aria-hidden="true" href="#there-is-one-more-thing">#</a></h2>
<p>从结构上看，不仅仅是 JSON、YAML、XML，大部分或者所有的数据（data）最终都可以分解成三种类型：</p>
<p>第一种类型是标量（scalar），也就是一个单独的字符串（string）或数字（numbers），比如<code>&quot;云原生&quot;</code>这个单独的词。</p>
<p>第二种类型是序列（sequence），也就是若干个相关的数据按照一定顺序并列在一起，又叫做数组（array）或列表（List），比如<code>[&quot;Kubernetes&quot;, &quot;Istio&quot;]</code>。</p>
<p>第三种类型是映射（mapping），也就是一个名/值对（Name/value），即数据有一个名称，还有一个与之相对应的值，这又称作散列（hash）或字典（dictionary），比如<code>&quot;CloudNative&quot;: &quot;Kubernetes&quot;</code>。</p>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<ul>
<li><a href="https://www.json.org/json-en.html">JSON 官网</a></li>
<li><a href="https://en.wikipedia.org/wiki/JSON">JSON 维基百科</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2009/05/data_types_and_json.html">数据类型和 Json 格式&ndash;阮一峰</a></li>
<li><a href="https://yaml.org/spec/1.1/index.html">YAML Ain’t Markup Language (YAML™) Version 1.1</a></li>
<li><a href="https://www.w3.org/TR/xml11/">World Wide Web Consortium</a></li>
<li><a href="https://blog.csdn.net/qq_15437667/article/details/50957996">自己最初了解 JSON 时总结的一篇文章</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/code/">Code</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/20230421-7-ways-to-stay-focused/">
    <span class="title">« Prev</span>
    <br>
    <span>提升专注力的七种方法</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/history-of-western-painting/">
    <span class="title">Next »</span>
    <br>
    <span>《欧洲绘画五百年》参观有感</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 为什么 JSON 需要转义 on x"
            href="https://x.com/intent/tweet/?text=%e4%b8%ba%e4%bb%80%e4%b9%88%20JSON%20%e9%9c%80%e8%a6%81%e8%bd%ac%e4%b9%89&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjson-and-escaping%2f&amp;hashtags=code">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 为什么 JSON 需要转义 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjson-and-escaping%2f&amp;title=%e4%b8%ba%e4%bb%80%e4%b9%88%20JSON%20%e9%9c%80%e8%a6%81%e8%bd%ac%e4%b9%89&amp;summary=%e4%b8%ba%e4%bb%80%e4%b9%88%20JSON%20%e9%9c%80%e8%a6%81%e8%bd%ac%e4%b9%89&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fjson-and-escaping%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 为什么 JSON 需要转义 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjson-and-escaping%2f&title=%e4%b8%ba%e4%bb%80%e4%b9%88%20JSON%20%e9%9c%80%e8%a6%81%e8%bd%ac%e4%b9%89">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 为什么 JSON 需要转义 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjson-and-escaping%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 为什么 JSON 需要转义 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e4%b8%ba%e4%bb%80%e4%b9%88%20JSON%20%e9%9c%80%e8%a6%81%e8%bd%ac%e4%b9%89%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fjson-and-escaping%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 为什么 JSON 需要转义 on telegram"
            href="https://telegram.me/share/url?text=%e4%b8%ba%e4%bb%80%e4%b9%88%20JSON%20%e9%9c%80%e8%a6%81%e8%bd%ac%e4%b9%89&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fjson-and-escaping%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 为什么 JSON 需要转义 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e4%b8%ba%e4%bb%80%e4%b9%88%20JSON%20%e9%9c%80%e8%a6%81%e8%bd%ac%e4%b9%89&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fjson-and-escaping%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">yousa Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
