<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>为什么 JSON 需要转义 | Yousa Driven Development | YDD</title><meta name=keywords content="code"><meta name=description content='为什么 JSON 需要转义？
[TOC]

适合人群：入门级
JSON 和 JSON 转义
21 世纪初，Douglas Crockford 寻找一种简便的数据交换格式，能够在服务器之间交换数据。当时通用的数据交换语言是 XML，但是 Douglas Crockford 觉得 XML 的生成和解析都太麻烦，所以他提出了一种简化格式，也就是 JSON。
JSON 其结构形如 {"云原生":"Kubernetes"}，可以很直观的使用字符串表示对象或数据结构。对象或数据结构使用序列化接口转换成 JSON 字符串，比如 Golang 中的json.Marshal接口。
你可能会有这样的疑问：既然 JSON 字符串结构简单，为什么不直接使用字符串拼接的方式，而是要使用 JSON 序列化接口呢？
结果显而易见：JSON 序列化接口会一并将数据中的特殊字符进行转义，防止其破坏 JSON 原有结构。比如数据中含有双引号"特殊字符，序列化接口便会对双引号进行转义，最终结果类似于{"云原生":"\"Kubernetes\""}，否则，该场景下直接拼接的字符串会非法。
JSON 转义
许多程序设计语言把双引号字符（"）用作字符串的分界符。反斜线（\）转义字符提供了两种方式来把双引号字符置入字符串中，或者是使用转义序列\"表示单个的"字符本身，而不是作为字符串分界符；或者是直接开始字符"的 16 进制编码值的转义序列\x22来表示"，也可以使用 8 进制编码值的转义序列，如\042。
在 Python 中，下面的代码将会产生语法错误


1


print "Cloud Navite "Hello World!".";


而另一段 Python 代码则会产生符合预期的结果


1


print "Cloud Navite \"Hello World!\".";


在 JSON 中，也是如此：当使用 json 接口解析字符串{"云原生":""Kubernetes""}时会报错，而解析经过转义的 JSON 字符串{"云原生":"\"Kubernetes\""}则会解析成功。'><meta name=author content="[厉辉（Yousa）](https://github.com/Miss-you)"><link rel=canonical href=https://miss-you.github.io/posts/json-and-escaping/><link crossorigin=anonymous href=/assets/css/stylesheet.00bbad06c55ebcb0750c3a80a86961a705c6911fcf30e50076e9a900dc81e46b.css integrity="sha256-ALutBsVevLB1DDqAqGlhpwXGkR/PMOUAdumpANyB5Gs=" rel="preload stylesheet" as=style><link rel=icon href=https://miss-you.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://miss-you.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://miss-you.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://miss-you.github.io/apple-touch-icon.png><link rel=mask-icon href=https://miss-you.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://miss-you.github.io/posts/json-and-escaping/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://miss-you.github.io/posts/json-and-escaping/"><meta property="og:site_name" content="Yousa Driven Development | YDD"><meta property="og:title" content="为什么 JSON 需要转义"><meta property="og:description" content='为什么 JSON 需要转义？ [TOC]
适合人群：入门级
JSON 和 JSON 转义 21 世纪初，Douglas Crockford 寻找一种简便的数据交换格式，能够在服务器之间交换数据。当时通用的数据交换语言是 XML，但是 Douglas Crockford 觉得 XML 的生成和解析都太麻烦，所以他提出了一种简化格式，也就是 JSON。
JSON 其结构形如 {"云原生":"Kubernetes"}，可以很直观的使用字符串表示对象或数据结构。对象或数据结构使用序列化接口转换成 JSON 字符串，比如 Golang 中的json.Marshal接口。
你可能会有这样的疑问：既然 JSON 字符串结构简单，为什么不直接使用字符串拼接的方式，而是要使用 JSON 序列化接口呢？
结果显而易见：JSON 序列化接口会一并将数据中的特殊字符进行转义，防止其破坏 JSON 原有结构。比如数据中含有双引号"特殊字符，序列化接口便会对双引号进行转义，最终结果类似于{"云原生":"\"Kubernetes\""}，否则，该场景下直接拼接的字符串会非法。
JSON 转义 许多程序设计语言把双引号字符（"）用作字符串的分界符。反斜线（\）转义字符提供了两种方式来把双引号字符置入字符串中，或者是使用转义序列\"表示单个的"字符本身，而不是作为字符串分界符；或者是直接开始字符"的 16 进制编码值的转义序列\x22来表示"，也可以使用 8 进制编码值的转义序列，如\042。
在 Python 中，下面的代码将会产生语法错误
1 print "Cloud Navite "Hello World!"."; 而另一段 Python 代码则会产生符合预期的结果
1 print "Cloud Navite \"Hello World!\"."; 在 JSON 中，也是如此：当使用 json 接口解析字符串{"云原生":""Kubernetes""}时会报错，而解析经过转义的 JSON 字符串{"云原生":"\"Kubernetes\""}则会解析成功。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-05T01:21:26+08:00"><meta property="article:modified_time" content="2021-03-02T16:50:28+08:00"><meta property="article:tag" content="Code"><meta name=twitter:card content="summary"><meta name=twitter:title content="为什么 JSON 需要转义"><meta name=twitter:description content='为什么 JSON 需要转义？
[TOC]

适合人群：入门级
JSON 和 JSON 转义
21 世纪初，Douglas Crockford 寻找一种简便的数据交换格式，能够在服务器之间交换数据。当时通用的数据交换语言是 XML，但是 Douglas Crockford 觉得 XML 的生成和解析都太麻烦，所以他提出了一种简化格式，也就是 JSON。
JSON 其结构形如 {"云原生":"Kubernetes"}，可以很直观的使用字符串表示对象或数据结构。对象或数据结构使用序列化接口转换成 JSON 字符串，比如 Golang 中的json.Marshal接口。
你可能会有这样的疑问：既然 JSON 字符串结构简单，为什么不直接使用字符串拼接的方式，而是要使用 JSON 序列化接口呢？
结果显而易见：JSON 序列化接口会一并将数据中的特殊字符进行转义，防止其破坏 JSON 原有结构。比如数据中含有双引号"特殊字符，序列化接口便会对双引号进行转义，最终结果类似于{"云原生":"\"Kubernetes\""}，否则，该场景下直接拼接的字符串会非法。
JSON 转义
许多程序设计语言把双引号字符（"）用作字符串的分界符。反斜线（\）转义字符提供了两种方式来把双引号字符置入字符串中，或者是使用转义序列\"表示单个的"字符本身，而不是作为字符串分界符；或者是直接开始字符"的 16 进制编码值的转义序列\x22来表示"，也可以使用 8 进制编码值的转义序列，如\042。
在 Python 中，下面的代码将会产生语法错误


1


print "Cloud Navite "Hello World!".";


而另一段 Python 代码则会产生符合预期的结果


1


print "Cloud Navite \"Hello World!\".";


在 JSON 中，也是如此：当使用 json 接口解析字符串{"云原生":""Kubernetes""}时会报错，而解析经过转义的 JSON 字符串{"云原生":"\"Kubernetes\""}则会解析成功。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://miss-you.github.io/posts/"},{"@type":"ListItem","position":2,"name":"为什么 JSON 需要转义","item":"https://miss-you.github.io/posts/json-and-escaping/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"为什么 JSON 需要转义","name":"为什么 JSON 需要转义","description":"为什么 JSON 需要转义？ [TOC]\n适合人群：入门级\nJSON 和 JSON 转义 21 世纪初，Douglas Crockford 寻找一种简便的数据交换格式，能够在服务器之间交换数据。当时通用的数据交换语言是 XML，但是 Douglas Crockford 觉得 XML 的生成和解析都太麻烦，所以他提出了一种简化格式，也就是 JSON。\nJSON 其结构形如 {\u0026quot;云原生\u0026quot;:\u0026quot;Kubernetes\u0026quot;}，可以很直观的使用字符串表示对象或数据结构。对象或数据结构使用序列化接口转换成 JSON 字符串，比如 Golang 中的json.Marshal接口。\n你可能会有这样的疑问：既然 JSON 字符串结构简单，为什么不直接使用字符串拼接的方式，而是要使用 JSON 序列化接口呢？\n结果显而易见：JSON 序列化接口会一并将数据中的特殊字符进行转义，防止其破坏 JSON 原有结构。比如数据中含有双引号\u0026quot;特殊字符，序列化接口便会对双引号进行转义，最终结果类似于{\u0026quot;云原生\u0026quot;:\u0026quot;\\\u0026quot;Kubernetes\\\u0026quot;\u0026quot;}，否则，该场景下直接拼接的字符串会非法。\nJSON 转义 许多程序设计语言把双引号字符（\u0026quot;）用作字符串的分界符。反斜线（\\）转义字符提供了两种方式来把双引号字符置入字符串中，或者是使用转义序列\\\u0026quot;表示单个的\u0026quot;字符本身，而不是作为字符串分界符；或者是直接开始字符\u0026quot;的 16 进制编码值的转义序列\\x22来表示\u0026quot;，也可以使用 8 进制编码值的转义序列，如\\042。\n在 Python 中，下面的代码将会产生语法错误\n1 print \u0026#34;Cloud Navite \u0026#34;Hello World!\u0026#34;.\u0026#34;; 而另一段 Python 代码则会产生符合预期的结果\n1 print \u0026#34;Cloud Navite \\\u0026#34;Hello World!\\\u0026#34;.\u0026#34;; 在 JSON 中，也是如此：当使用 json 接口解析字符串{\u0026quot;云原生\u0026quot;:\u0026quot;\u0026quot;Kubernetes\u0026quot;\u0026quot;}时会报错，而解析经过转义的 JSON 字符串{\u0026quot;云原生\u0026quot;:\u0026quot;\\\u0026quot;Kubernetes\\\u0026quot;\u0026quot;}则会解析成功。\n","keywords":["code"],"articleBody":"为什么 JSON 需要转义？ [TOC]\n适合人群：入门级\nJSON 和 JSON 转义 21 世纪初，Douglas Crockford 寻找一种简便的数据交换格式，能够在服务器之间交换数据。当时通用的数据交换语言是 XML，但是 Douglas Crockford 觉得 XML 的生成和解析都太麻烦，所以他提出了一种简化格式，也就是 JSON。\nJSON 其结构形如 {\"云原生\":\"Kubernetes\"}，可以很直观的使用字符串表示对象或数据结构。对象或数据结构使用序列化接口转换成 JSON 字符串，比如 Golang 中的json.Marshal接口。\n你可能会有这样的疑问：既然 JSON 字符串结构简单，为什么不直接使用字符串拼接的方式，而是要使用 JSON 序列化接口呢？\n结果显而易见：JSON 序列化接口会一并将数据中的特殊字符进行转义，防止其破坏 JSON 原有结构。比如数据中含有双引号\"特殊字符，序列化接口便会对双引号进行转义，最终结果类似于{\"云原生\":\"\\\"Kubernetes\\\"\"}，否则，该场景下直接拼接的字符串会非法。\nJSON 转义 许多程序设计语言把双引号字符（\"）用作字符串的分界符。反斜线（\\）转义字符提供了两种方式来把双引号字符置入字符串中，或者是使用转义序列\\\"表示单个的\"字符本身，而不是作为字符串分界符；或者是直接开始字符\"的 16 进制编码值的转义序列\\x22来表示\"，也可以使用 8 进制编码值的转义序列，如\\042。\n在 Python 中，下面的代码将会产生语法错误\n1 print \"Cloud Navite \"Hello World!\".\"; 而另一段 Python 代码则会产生符合预期的结果\n1 print \"Cloud Navite \\\"Hello World!\\\".\"; 在 JSON 中，也是如此：当使用 json 接口解析字符串{\"云原生\":\"\"Kubernetes\"\"}时会报错，而解析经过转义的 JSON 字符串{\"云原生\":\"\\\"Kubernetes\\\"\"}则会解析成功。\nJSON 转义机制如下图：\nJSON 中字符串针对于特殊字符需要 JSON 转义，它使用反斜杠\\进行转义 JSON 序列包括“\\\\、\\\"、\\/、\\b、\\f、\\n、\\r、\\t，或者 Unicode16 进制转义字符（比如\\uD83D\\uDE02) JSON 字符串默认为 UTF-8 编码。可以通过观察前四个八位字节中的空值模式来确定一个八位字节流是 UTF-8、UTF-16（BE 或 LE）还是 UTF-32（BE 或 LE） JSON 语法 在讲具体案例之前，复习一下 JSON 语法，忘记的可以翻阅该章节。\nJSON 语法简单来说就是四条：\n数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组 声明：以下使用的对象均来自于以下内容\n1 2 3 4 5 6 7 8 9 10 { \"virtualeNB\":[ {\"virteNBName\":\"virt1\", \"virteNBNum\":5, \"begineNBID\":0, \"beginCtlPort\":6000, \"beginDataPort\":7000, \"virtIPNum\":5}, {\"virteNBName\":\"virt2\", \"virteNBNum\":10, \"begineNBID\":10, \"beginCtlPort\":6000, \"beginDataPort\":7000, \"virtIPNum\":10} ], \"eRAN\":[ {\"eRANName\":\"eNB1\", \"eRANID\":3002, \"ctlPort\":36412, \"dataPort\":2152}, {\"eRANName\":\"eNB2\", \"eRANID\":10000, \"ctlPort\":36412, \"dataPort\":2152} ] } 1. JSON 名称/值对 JSON 数据的书写格式是：名称：值，这样的一对。即名称在前，该名称的值在冒号后面。例如：\n1 \"virteNBName\":\"virt1\" 这里的名称是\"virteNBName\"，值是\"virt1\"，他们均是字符串\n名称和值得类型可以有以下几种：\n数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） 对象（在花括号中） null 2. JSON 数据由逗号分隔 譬如：\n\"virteNBName\":\"virt1\", \"virteNBNum\":5, \"begineNBID\":0这几个对象之间就是使用逗号分隔。\n数组内的对象之间当然也是要用逗号分隔。只要是对象之间，分隔就是用逗号,。但是，要注意，对象结束的时候，不要加逗号。数组内也是，例如：\n1 2 3 4 [ {\"eRANName\":\"eNB1\", \"eRANID\":3002, \"ctlPort\":36412, \"dataPort\":2152}, {\"eRANName\":\"eNB2\", \"eRANID\":10000, \"ctlPort\":36412, \"dataPort\":2152}, ] 上面这个就是错误的，因为在数组中，两个对象之间需要逗号，但是到这个数组末尾了，不需要加逗号了。\n3. JSON 花括号保存对象 对象可以包含多个名称/值对，如：\n1 {\"eRANName\":\"eNB1\", \"eRANID\":3002, \"ctlPort\":36412, \"dataPort\":2152} 这一点也容易理解，与这条 JavaScript 语句等价：\n1 2 3 4 \"eRANName\" = \"eNB1\" \"eRANID\" = 3002 \"ctlPort\" = 36412 \"dataPort\" = 2152 4. JSON 方括号保存数组 数组可包含多个对象：\n1 2 3 4 \"eRAN\":[ {\"eRANName\":\"eNB1\", \"eRANID\":3002, \"ctlPort\":36412, \"dataPort\":2152}, {\"eRANName\":\"eNB2\", \"eRANID\":10000, \"ctlPort\":36412, \"dataPort\":2152} ] 在上面的例子中，对象 “eRAN” 是包含 2 个对象的数组。每个对象代表一条基站的记录。\n上面四条规则，就是 JSON 格式的所有内容。\n案例 一个由特殊字符导致 JSON 格式的 Nginx 访问日志/日志系统的 BUG 访问日志 access_log：Nginx 会将每个客户端访问其本身的请求以日志的形式记录到指定的日志文件里，以供分析用户的浏览或请求行为，或者可以用于快速分析故障所在。此功能由 ngx_http_log_module 模块负责。\n在 Nginx 文件中，访问日志 access.log 配置形如下文的格式：\n1 2 3 4 log_format main '$remote_addr [$time_local] \"$request\" ' '$status $bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log logs/access.log main buffer=32k; logs/access.log 指定访问日志路径 log_format 定义访问日志格式 buffer=32k 是日志缓冲区大小 访问日志 access_log 其通过格式化输出 nginx 变量以及拼接字符串的方式打印日志。\n在云原生时代，Nginx 运维的最佳实践之一就是将 Nginx 访问日志采用 EFK 架构 (Elasticsearch+Filebeat+Kibana)，通过收集和管理访问日志，提供统一的检索功能，这样做不仅可以提高诊断效率，而且可以全面了解系统情况，避免被动事后救火。\n通常，为了方便分析，会将 Nginx 访问日志输出为 JSON 字符串，其配置如下：\n1 2 3 4 log_format main '{\"remote_addr\":\"$remote_addr\",\"time_local\":\"$time_local\",\"request\":\"$request\",' '\"status\":\"$status\",\"bytes_sent\":\"$bytes_sent\",\"http_referer\":\"$http_referer\",' '\"http_user_agent\":\"$http_user_agent\",\"http_x_forwarded_for\":\"$http_x_forwarded_for\"}'; access_log logs/access.log main buffer=32k; 乍一看，这样的配置没什么问题。但再深入思考，生成 JSON 字符串的标准做法是调用 JSON 序列化接口，而 Nginx 访问日志是直接格式化拼接字符串，故一旦访问日志中出现特殊字符（比如双引号\"），就会导致整行访问日志解析出错，影响接下来的日志分析系统对访问日志的数据查找、服务诊断和数据分析。\n为了解决 JSON 转义的问题，Nginx 在 1.11.8 版本中给日志格式 log_format 新增了序列化配置 escape=json，其格式为：\n1 2 3 4 Syntax:\tlog_format name [escape=default|json|none] string ...; Default:\tlog_format combined \"...\"; Context:\thttp 当配置为 escape=json 时，JSON 字符串中所有不允许的字符都将被转义：\n\"和/字符被转义为/\"和// 值小于 32 的字符被转义“\\n”, “\\r”, “\\t”, “\\b”, “\\f”, or “\\u00XX” 所以，正确的 log_format 配置为\n1 2 3 log_format main escape=json '{\"remote_addr\":\"$remote_addr\",\"time_local\":\"$time_local\",\"request\":\"$request\",' '\"status\":\"$status\",\"bytes_sent\":\"$bytes_sent\",\"http_referer\":\"$http_referer\",' '\"http_user_agent\":\"$http_user_agent\",\"http_x_forwarded_for\":\"$http_x_forwarded_for\"}'; 当然，因为 JSON 转义导致的 BUG 不止这一个，近期遇到的另一个 BUG 也是因为前人实现的代码实现不规范，其逻辑是将收到的请求以字符串拼接的方式构造 JSON 串，导致一旦请求中带有双引号\"或其他特殊字符，就必定出现 BUG。\nJSON 与其他格式的比较 JSON vs XML JSON 与 XML 最大的不同在于 XML 是一个完整的标记语言，而 JSON 不是。这使得 XML 在程序判读上需要比较多的功夫。主要的原因在于 XML 的设计理念与 JSON 不同。XML 利用标记语言的特性提供了绝佳的延展性（如 XPath），在数据存储，扩展及高级检索方面具备对 JSON 的优势，而 JSON 则由于比 XML 更加小巧，以及浏览器的内建快速解析支持，使得其更适用于网络数据传输领域。\n从转义角度来看，XML 标签名不能包含任何字符!\"#$%\u0026'()*+,/;\u003c=\u003e?@[\\]^{|}~，也不能包含空格字符，不能以-、.或数字数字开头，而 JSON 键可以（引号和反斜杠必须转义）。\nJSON vs YAML JSON 格式简单易上手，但没有了 YAML 的一目了然，尤其是 JSON 数据很长的时候，会让人陷入繁琐复杂的数据节点查找中。通常我会使用在线 JSON 格式化工具，来更方便的对 JSON 数据进行节点查找和解析。\n个人认为，YAML 几乎将 JSON 秒成渣渣，这里直接引用 YAML 官方文档 关于 YAML 的总结：\nYAML 的可读性好 YAML 和脚本语言的交互性好 YAML 使用实现语言的数据类型 YAML 有一个一致的信息模型 YAML 易于实现 YAML 可以基于流来处理 YAML 表达能力强，扩展性好 YAML 可以写注释 There Is One More Thing 从结构上看，不仅仅是 JSON、YAML、XML，大部分或者所有的数据（data）最终都可以分解成三种类型：\n第一种类型是标量（scalar），也就是一个单独的字符串（string）或数字（numbers），比如\"云原生\"这个单独的词。\n第二种类型是序列（sequence），也就是若干个相关的数据按照一定顺序并列在一起，又叫做数组（array）或列表（List），比如[\"Kubernetes\", \"Istio\"]。\n第三种类型是映射（mapping），也就是一个名/值对（Name/value），即数据有一个名称，还有一个与之相对应的值，这又称作散列（hash）或字典（dictionary），比如\"CloudNative\": \"Kubernetes\"。\n参考 JSON 官网 JSON 维基百科 数据类型和 Json 格式–阮一峰 YAML Ain’t Markup Language (YAML™) Version 1.1 World Wide Web Consortium 自己最初了解 JSON 时总结的一篇文章 ","wordCount":"474","inLanguage":"en","datePublished":"2021-01-05T01:21:26+08:00","dateModified":"2021-03-02T16:50:28+08:00","author":{"@type":"Person","name":"[厉辉（Yousa）](https://github.com/Miss-you)"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://miss-you.github.io/posts/json-and-escaping/"},"publisher":{"@type":"Organization","name":"Yousa Driven Development | YDD","logo":{"@type":"ImageObject","url":"https://miss-you.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://miss-you.github.io/ accesskey=h title="Yousa Driven Development | YDD (Alt + H)">Yousa Driven Development | YDD</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://miss-you.github.io/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://miss-you.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://miss-you.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://miss-you.github.io/tools/ title=Tools><span>Tools</span></a></li><li><a href=https://miss-you.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://github.com/Miss-you title=GitHub><span>GitHub</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://miss-you.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://miss-you.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">为什么 JSON 需要转义</h1><div class=post-meta><span title='2021-01-05 01:21:26 +0800 +0800'>January 5, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;474 words&nbsp;·&nbsp;[厉辉（Yousa）](https://github.com/Miss-you)&nbsp;|&nbsp;<a href=https://github.com/Miss-you/miss-you.github.io/tree/main/content/posts/json-and-escaping.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#json-和-json-转义>JSON 和 JSON 转义</a><ul><li><a href=#json-转义>JSON 转义</a></li><li><a href=#json-语法>JSON 语法</a></li></ul></li><li><a href=#案例>案例</a><ul><li><a href=#一个由特殊字符导致-json-格式的-nginx-访问日志日志系统的-bug>一个由特殊字符导致 JSON 格式的 Nginx 访问日志/日志系统的 BUG</a></li></ul></li><li><a href=#json-与其他格式的比较>JSON 与其他格式的比较</a><ul><li><a href=#json-vs-xml>JSON vs XML</a></li><li><a href=#json-vs-yaml>JSON vs YAML</a></li></ul></li><li><a href=#there-is-one-more-thing>There Is One More Thing</a></li><li><a href=#参考>参考</a></li></ul></nav></div></details></div><div class=post-content><h1 id=为什么-json-需要转义>为什么 JSON 需要转义？<a hidden class=anchor aria-hidden=true href=#为什么-json-需要转义>#</a></h1><p>[TOC]</p><blockquote><p>适合人群：入门级</p></blockquote><h2 id=json-和-json-转义>JSON 和 JSON 转义<a hidden class=anchor aria-hidden=true href=#json-和-json-转义>#</a></h2><p>21 世纪初，Douglas Crockford 寻找一种简便的数据交换格式，能够在服务器之间交换数据。当时通用的数据交换语言是 XML，但是 Douglas Crockford 觉得 XML 的生成和解析都太麻烦，所以他提出了一种简化格式，也就是 JSON。</p><p>JSON 其结构形如 <code>{"云原生":"Kubernetes"}</code>，可以很直观的使用字符串表示对象或数据结构。对象或数据结构使用序列化接口转换成 JSON 字符串，比如 Golang 中的<code>json.Marshal</code>接口。</p><p>你可能会有这样的疑问：既然 JSON 字符串结构简单，为什么不直接使用字符串拼接的方式，而是要使用 JSON 序列化接口呢？</p><p>结果显而易见：JSON 序列化接口会一并将数据中的特殊字符进行转义，防止其破坏 JSON 原有结构。比如数据中含有双引号<code>"</code>特殊字符，序列化接口便会对双引号进行转义，最终结果类似于<code>{"云原生":"\"Kubernetes\""}</code>，否则，该场景下直接拼接的字符串会非法。</p><h3 id=json-转义>JSON 转义<a hidden class=anchor aria-hidden=true href=#json-转义>#</a></h3><p>许多程序设计语言把双引号字符<code>（"）</code>用作字符串的分界符。反斜线<code>（\）</code>转义字符提供了两种方式来把双引号字符置入字符串中，或者是使用转义序列<code>\"</code>表示单个的<code>"</code>字符本身，而不是作为字符串分界符；或者是直接开始字符<code>"</code>的 16 进制编码值的转义序列<code>\x22</code>来表示<code>"</code>，也可以使用 8 进制编码值的转义序列，如<code>\042</code>。</p><p>在 Python 中，下面的代码将会产生语法错误</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>print &#34;Cloud Navite &#34;Hello World!&#34;.&#34;;
</span></span></code></pre></td></tr></table></div></div><p>而另一段 Python 代码则会产生符合预期的结果</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>print &#34;Cloud Navite \&#34;Hello World!\&#34;.&#34;;
</span></span></code></pre></td></tr></table></div></div><p>在 JSON 中，也是如此：当使用 json 接口解析字符串<code>{"云原生":""Kubernetes""}</code>时会报错，而解析经过转义的 JSON 字符串<code>{"云原生":"\"Kubernetes\""}</code>则会解析成功。</p><p>JSON 转义机制如下图：</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/Miss-you/img/picgo/20201228022357.png></p><ol><li>JSON 中字符串针对于特殊字符需要 JSON 转义，它使用反斜杠<code>\</code>进行转义</li><li>JSON 序列包括<code>“\\、\"、\/、\b、\f、\n、\r、\t</code>，或者 Unicode16 进制转义字符（比如<code>\uD83D\uDE02</code>)</li><li>JSON 字符串默认为 UTF-8 编码。可以通过观察前四个八位字节中的空值模式来确定一个八位字节流是 UTF-8、UTF-16（BE 或 LE）还是 UTF-32（BE 或 LE）</li></ol><h3 id=json-语法>JSON 语法<a hidden class=anchor aria-hidden=true href=#json-语法>#</a></h3><blockquote><p>在讲具体案例之前，复习一下 JSON 语法，忘记的可以翻阅该章节。</p></blockquote><p>JSON 语法简单来说就是四条：</p><ul><li>数据在名称/值对中</li><li>数据由逗号分隔</li><li>花括号保存对象</li><li>方括号保存数组</li></ul><blockquote><p>声明：以下使用的对象均来自于以下内容</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    &#34;virtualeNB&#34;:[
</span></span><span class=line><span class=cl>        {&#34;virteNBName&#34;:&#34;virt1&#34;, &#34;virteNBNum&#34;:5, &#34;begineNBID&#34;:0, &#34;beginCtlPort&#34;:6000, &#34;beginDataPort&#34;:7000, &#34;virtIPNum&#34;:5},
</span></span><span class=line><span class=cl>        {&#34;virteNBName&#34;:&#34;virt2&#34;, &#34;virteNBNum&#34;:10, &#34;begineNBID&#34;:10, &#34;beginCtlPort&#34;:6000, &#34;beginDataPort&#34;:7000, &#34;virtIPNum&#34;:10}
</span></span><span class=line><span class=cl>    ],
</span></span><span class=line><span class=cl>    &#34;eRAN&#34;:[
</span></span><span class=line><span class=cl>        {&#34;eRANName&#34;:&#34;eNB1&#34;, &#34;eRANID&#34;:3002, &#34;ctlPort&#34;:36412, &#34;dataPort&#34;:2152},
</span></span><span class=line><span class=cl>        {&#34;eRANName&#34;:&#34;eNB2&#34;, &#34;eRANID&#34;:10000, &#34;ctlPort&#34;:36412, &#34;dataPort&#34;:2152}
</span></span><span class=line><span class=cl>    ]
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><h4 id=1-json-名称值对>1. JSON 名称/值对<a hidden class=anchor aria-hidden=true href=#1-json-名称值对>#</a></h4><p>JSON 数据的书写格式是：名称：值，这样的一对。即名称在前，该名称的值在冒号后面。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&#34;virteNBName&#34;:&#34;virt1&#34;
</span></span></code></pre></td></tr></table></div></div><p>这里的名称是<code>"virteNBName"</code>，值是<code>"virt1"</code>，他们均是字符串</p><p>名称和值得类型可以有以下几种：</p><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在方括号中）</li><li>对象（在花括号中）</li><li>null</li></ul><h4 id=2-json-数据由逗号分隔>2. JSON 数据由逗号分隔<a hidden class=anchor aria-hidden=true href=#2-json-数据由逗号分隔>#</a></h4><p>譬如：</p><p><code>"virteNBName":"virt1", "virteNBNum":5, "begineNBID":0</code>这几个对象之间就是使用逗号分隔。</p><p>数组内的对象之间当然也是要用逗号分隔。只要是对象之间，分隔就是用逗号<code>,</code>。但是，要注意，对象结束的时候，不要加逗号。数组内也是，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[
</span></span><span class=line><span class=cl>    {&#34;eRANName&#34;:&#34;eNB1&#34;, &#34;eRANID&#34;:3002, &#34;ctlPort&#34;:36412, &#34;dataPort&#34;:2152},
</span></span><span class=line><span class=cl>    {&#34;eRANName&#34;:&#34;eNB2&#34;, &#34;eRANID&#34;:10000, &#34;ctlPort&#34;:36412, &#34;dataPort&#34;:2152},
</span></span><span class=line><span class=cl>]
</span></span></code></pre></td></tr></table></div></div><p>上面这个就是错误的，因为在数组中，两个对象之间需要逗号，但是到这个数组末尾了，不需要加逗号了。</p><h4 id=3-json-花括号保存对象>3. JSON 花括号保存对象<a hidden class=anchor aria-hidden=true href=#3-json-花括号保存对象>#</a></h4><p>对象可以包含多个名称/值对，如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>{&#34;eRANName&#34;:&#34;eNB1&#34;, &#34;eRANID&#34;:3002, &#34;ctlPort&#34;:36412, &#34;dataPort&#34;:2152}
</span></span></code></pre></td></tr></table></div></div><p>这一点也容易理解，与这条 JavaScript 语句等价：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&#34;eRANName&#34; = &#34;eNB1&#34;
</span></span><span class=line><span class=cl>&#34;eRANID&#34; = 3002
</span></span><span class=line><span class=cl>&#34;ctlPort&#34; = 36412
</span></span><span class=line><span class=cl>&#34;dataPort&#34; = 2152
</span></span></code></pre></td></tr></table></div></div><h4 id=4-json-方括号保存数组>4. JSON 方括号保存数组<a hidden class=anchor aria-hidden=true href=#4-json-方括号保存数组>#</a></h4><p>数组可包含多个对象：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&#34;eRAN&#34;:[
</span></span><span class=line><span class=cl>    {&#34;eRANName&#34;:&#34;eNB1&#34;, &#34;eRANID&#34;:3002, &#34;ctlPort&#34;:36412, &#34;dataPort&#34;:2152},
</span></span><span class=line><span class=cl>    {&#34;eRANName&#34;:&#34;eNB2&#34;, &#34;eRANID&#34;:10000, &#34;ctlPort&#34;:36412, &#34;dataPort&#34;:2152}
</span></span><span class=line><span class=cl>]
</span></span></code></pre></td></tr></table></div></div><p>在上面的例子中，对象 &ldquo;eRAN&rdquo; 是包含 2 个对象的数组。每个对象代表一条基站的记录。</p><p>上面四条规则，就是 JSON 格式的所有内容。</p><h2 id=案例>案例<a hidden class=anchor aria-hidden=true href=#案例>#</a></h2><h3 id=一个由特殊字符导致-json-格式的-nginx-访问日志日志系统的-bug>一个由特殊字符导致 JSON 格式的 Nginx 访问日志/日志系统的 BUG<a hidden class=anchor aria-hidden=true href=#一个由特殊字符导致-json-格式的-nginx-访问日志日志系统的-bug>#</a></h3><p>访问日志 <code>access_log</code>：Nginx 会将每个客户端访问其本身的请求以日志的形式记录到指定的日志文件里，以供分析用户的浏览或请求行为，或者可以用于快速分析故障所在。此功能由 <code>ngx_http_log_module</code> 模块负责。</p><p>在 Nginx 文件中，访问日志 <code>access.log</code> 配置形如下文的格式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>log_format  main  &#39;$remote_addr [$time_local] &#34;$request&#34; &#39;
</span></span><span class=line><span class=cl>                    &#39;$status $bytes_sent &#34;$http_referer&#34; &#39;
</span></span><span class=line><span class=cl>                    &#39;&#34;$http_user_agent&#34; &#34;$http_x_forwarded_for&#34;&#39;;
</span></span><span class=line><span class=cl>access_log  logs/access.log  main buffer=32k;
</span></span></code></pre></td></tr></table></div></div><ul><li><code>logs/access.log</code> 指定访问日志路径</li><li><code>log_format</code> 定义访问日志格式</li><li><code>buffer=32k</code> 是日志缓冲区大小</li></ul><p>访问日志 <code>access_log</code> 其通过格式化输出 <code>nginx</code> 变量以及拼接字符串的方式打印日志。</p><p>在云原生时代，Nginx 运维的最佳实践之一就是将 Nginx 访问日志采用 EFK 架构 <code>(Elasticsearch+Filebeat+Kibana)</code>，通过收集和管理访问日志，提供统一的检索功能，这样做不仅可以提高诊断效率，而且可以全面了解系统情况，避免被动事后救火。</p><p>通常，为了方便分析，会将 Nginx 访问日志输出为 JSON 字符串，其配置如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>log_format  main  &#39;{&#34;remote_addr&#34;:&#34;$remote_addr&#34;,&#34;time_local&#34;:&#34;$time_local&#34;,&#34;request&#34;:&#34;$request&#34;,&#39;
</span></span><span class=line><span class=cl>                    &#39;&#34;status&#34;:&#34;$status&#34;,&#34;bytes_sent&#34;:&#34;$bytes_sent&#34;,&#34;http_referer&#34;:&#34;$http_referer&#34;,&#39;
</span></span><span class=line><span class=cl>                    &#39;&#34;http_user_agent&#34;:&#34;$http_user_agent&#34;,&#34;http_x_forwarded_for&#34;:&#34;$http_x_forwarded_for&#34;}&#39;;
</span></span><span class=line><span class=cl>access_log  logs/access.log  main buffer=32k;
</span></span></code></pre></td></tr></table></div></div><p>乍一看，这样的配置没什么问题。但再深入思考，生成 JSON 字符串的标准做法是调用 JSON 序列化接口，而 Nginx 访问日志是直接格式化拼接字符串，故一旦访问日志中出现特殊字符（比如双引号<code>"</code>），就会导致整行访问日志解析出错，影响接下来的日志分析系统对访问日志的数据查找、服务诊断和数据分析。</p><p>为了解决 JSON 转义的问题，Nginx 在 1.11.8 版本中给日志格式 <code>log_format</code> 新增了序列化配置 <code>escape=json</code>，其格式为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Syntax:	log_format name [escape=default|json|none] string ...;
</span></span><span class=line><span class=cl>Default:	
</span></span><span class=line><span class=cl>log_format combined &#34;...&#34;;
</span></span><span class=line><span class=cl>Context:	http
</span></span></code></pre></td></tr></table></div></div><p>当配置为 <code>escape=json</code> 时，JSON 字符串中所有不允许的字符都将被转义：</p><ul><li><code>"</code>和<code>/</code>字符被转义为<code>/"</code>和<code>//</code></li><li>值小于 32 的字符被转义<code>“\n”, “\r”, “\t”, “\b”, “\f”, or “\u00XX”</code></li></ul><p>所以，正确的 <code>log_format</code> 配置为</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>log_format  main  escape=json &#39;{&#34;remote_addr&#34;:&#34;$remote_addr&#34;,&#34;time_local&#34;:&#34;$time_local&#34;,&#34;request&#34;:&#34;$request&#34;,&#39;
</span></span><span class=line><span class=cl>                    &#39;&#34;status&#34;:&#34;$status&#34;,&#34;bytes_sent&#34;:&#34;$bytes_sent&#34;,&#34;http_referer&#34;:&#34;$http_referer&#34;,&#39;
</span></span><span class=line><span class=cl>                    &#39;&#34;http_user_agent&#34;:&#34;$http_user_agent&#34;,&#34;http_x_forwarded_for&#34;:&#34;$http_x_forwarded_for&#34;}&#39;;
</span></span></code></pre></td></tr></table></div></div><p>当然，因为 JSON 转义导致的 BUG 不止这一个，近期遇到的另一个 BUG 也是因为前人实现的代码实现不规范，其逻辑是将收到的请求以字符串拼接的方式构造 JSON 串，导致一旦请求中带有双引号<code>"</code>或其他特殊字符，就必定出现 BUG。</p><h2 id=json-与其他格式的比较>JSON 与其他格式的比较<a hidden class=anchor aria-hidden=true href=#json-与其他格式的比较>#</a></h2><h3 id=json-vs-xml>JSON vs XML<a hidden class=anchor aria-hidden=true href=#json-vs-xml>#</a></h3><p>JSON 与 XML 最大的不同在于 XML 是一个完整的标记语言，而 JSON 不是。这使得 XML 在程序判读上需要比较多的功夫。主要的原因在于 XML 的设计理念与 JSON 不同。XML 利用标记语言的特性提供了绝佳的延展性（如 XPath），在数据存储，扩展及高级检索方面具备对 JSON 的优势，而 JSON 则由于比 XML 更加小巧，以及浏览器的内建快速解析支持，使得其更适用于网络数据传输领域。</p><p>从转义角度来看，XML 标签名不能包含任何字符<code>!"#$%&'()*+,/;&lt;=>?@[\]^{|}~</code>，也不能包含空格字符，不能以<code>-</code>、<code>.</code>或数字数字开头，而 JSON 键可以（引号和反斜杠必须转义）。</p><h3 id=json-vs-yaml>JSON vs YAML<a hidden class=anchor aria-hidden=true href=#json-vs-yaml>#</a></h3><p>JSON 格式简单易上手，但没有了 YAML 的一目了然，尤其是 JSON 数据很长的时候，会让人陷入繁琐复杂的数据节点查找中。通常我会使用在线 JSON 格式化工具，来更方便的对 JSON 数据进行节点查找和解析。</p><p>个人认为，YAML 几乎将 JSON 秒成渣渣，这里直接引用 <a href=https://yaml.org/spec/1.1/index.html>YAML 官方文档</a> 关于 YAML 的总结：</p><ul><li>YAML 的可读性好</li><li>YAML 和脚本语言的交互性好</li><li>YAML 使用实现语言的数据类型</li><li>YAML 有一个一致的信息模型</li><li>YAML 易于实现</li><li>YAML 可以基于流来处理</li><li>YAML 表达能力强，扩展性好</li><li>YAML 可以写注释</li></ul><h2 id=there-is-one-more-thing>There Is One More Thing<a hidden class=anchor aria-hidden=true href=#there-is-one-more-thing>#</a></h2><p>从结构上看，不仅仅是 JSON、YAML、XML，大部分或者所有的数据（data）最终都可以分解成三种类型：</p><p>第一种类型是标量（scalar），也就是一个单独的字符串（string）或数字（numbers），比如<code>"云原生"</code>这个单独的词。</p><p>第二种类型是序列（sequence），也就是若干个相关的数据按照一定顺序并列在一起，又叫做数组（array）或列表（List），比如<code>["Kubernetes", "Istio"]</code>。</p><p>第三种类型是映射（mapping），也就是一个名/值对（Name/value），即数据有一个名称，还有一个与之相对应的值，这又称作散列（hash）或字典（dictionary），比如<code>"CloudNative": "Kubernetes"</code>。</p><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ul><li><a href=https://www.json.org/json-en.html>JSON 官网</a></li><li><a href=https://en.wikipedia.org/wiki/JSON>JSON 维基百科</a></li><li><a href=http://www.ruanyifeng.com/blog/2009/05/data_types_and_json.html>数据类型和 Json 格式&ndash;阮一峰</a></li><li><a href=https://yaml.org/spec/1.1/index.html>YAML Ain’t Markup Language (YAML™) Version 1.1</a></li><li><a href=https://www.w3.org/TR/xml11/>World Wide Web Consortium</a></li><li><a href=https://blog.csdn.net/qq_15437667/article/details/50957996>自己最初了解 JSON 时总结的一篇文章</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://miss-you.github.io/tags/code/>Code</a></li></ul><nav class=paginav><a class=prev href=https://miss-you.github.io/posts/20230421-7-ways-to-stay-focused/><span class=title>« Prev</span><br><span>提升专注力的七种方法</span>
</a><a class=next href=https://miss-you.github.io/posts/history-of-western-painting/><span class=title>Next »</span><br><span>《欧洲绘画五百年》参观有感</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 为什么 JSON 需要转义 on x" href="https://x.com/intent/tweet/?text=%e4%b8%ba%e4%bb%80%e4%b9%88%20JSON%20%e9%9c%80%e8%a6%81%e8%bd%ac%e4%b9%89&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2fjson-and-escaping%2f&amp;hashtags=code"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 为什么 JSON 需要转义 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2fjson-and-escaping%2f&amp;title=%e4%b8%ba%e4%bb%80%e4%b9%88%20JSON%20%e9%9c%80%e8%a6%81%e8%bd%ac%e4%b9%89&amp;summary=%e4%b8%ba%e4%bb%80%e4%b9%88%20JSON%20%e9%9c%80%e8%a6%81%e8%bd%ac%e4%b9%89&amp;source=https%3a%2f%2fmiss-you.github.io%2fposts%2fjson-and-escaping%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 为什么 JSON 需要转义 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmiss-you.github.io%2fposts%2fjson-and-escaping%2f&title=%e4%b8%ba%e4%bb%80%e4%b9%88%20JSON%20%e9%9c%80%e8%a6%81%e8%bd%ac%e4%b9%89"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 为什么 JSON 需要转义 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmiss-you.github.io%2fposts%2fjson-and-escaping%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 为什么 JSON 需要转义 on whatsapp" href="https://api.whatsapp.com/send?text=%e4%b8%ba%e4%bb%80%e4%b9%88%20JSON%20%e9%9c%80%e8%a6%81%e8%bd%ac%e4%b9%89%20-%20https%3a%2f%2fmiss-you.github.io%2fposts%2fjson-and-escaping%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 为什么 JSON 需要转义 on telegram" href="https://telegram.me/share/url?text=%e4%b8%ba%e4%bb%80%e4%b9%88%20JSON%20%e9%9c%80%e8%a6%81%e8%bd%ac%e4%b9%89&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2fjson-and-escaping%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 为什么 JSON 需要转义 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e4%b8%ba%e4%bb%80%e4%b9%88%20JSON%20%e9%9c%80%e8%a6%81%e8%bd%ac%e4%b9%89&u=https%3a%2f%2fmiss-you.github.io%2fposts%2fjson-and-escaping%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://miss-you.github.io/>Yousa Driven Development | YDD</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>