<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台 | Yousa Driven Development | YDD</title><meta name=keywords content="Kimi CLI,Swift,iOS,WebView,AI 工具"><meta name=description content="用约 300 行 Swift 代码，零第三方依赖，把 iPhone 变成功能完备的 Kimi CLI 控制台。详解 Web UI 架构、Wire 协议和 iOS 封装实现。"><meta name=author content="Miss-you"><link rel=canonical href=https://miss-you.github.io/posts/20260216-swift-kimi-cli-console/><link crossorigin=anonymous href=/assets/css/stylesheet.90ccfe940c2ebacfe29cf6c094281c8c148bd718511cde00be68d330109118be.css integrity="sha256-kMz+lAwuus/inPbAlCgcjBSL1xhRHN4AvmjTMBCRGL4=" rel="preload stylesheet" as=style><link rel=icon href=https://miss-you.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://miss-you.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://miss-you.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://miss-you.github.io/apple-touch-icon.png><link rel=mask-icon href=https://miss-you.github.io/safari-pinned-tab.svg><meta name=theme-color content="#f4f3ee"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://miss-you.github.io/posts/20260216-swift-kimi-cli-console/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Noto+Serif+SC:wght@400;600;700;900&family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel=stylesheet><meta property="og:url" content="https://miss-you.github.io/posts/20260216-swift-kimi-cli-console/"><meta property="og:site_name" content="Yousa Driven Development | YDD"><meta property="og:title" content="用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台"><meta property="og:description" content="用约 300 行 Swift 代码，零第三方依赖，把 iPhone 变成功能完备的 Kimi CLI 控制台。详解 Web UI 架构、Wire 协议和 iOS 封装实现。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-16T01:20:00+08:00"><meta property="article:modified_time" content="2026-02-16T10:48:14+08:00"><meta property="article:tag" content="Kimi CLI"><meta property="article:tag" content="Swift"><meta property="article:tag" content="IOS"><meta property="article:tag" content="WebView"><meta property="article:tag" content="AI 工具"><meta name=twitter:card content="summary"><meta name=twitter:title content="用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台"><meta name=twitter:description content="用约 300 行 Swift 代码，零第三方依赖，把 iPhone 变成功能完备的 Kimi CLI 控制台。详解 Web UI 架构、Wire 协议和 iOS 封装实现。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://miss-you.github.io/posts/"},{"@type":"ListItem","position":2,"name":"用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台","item":"https://miss-you.github.io/posts/20260216-swift-kimi-cli-console/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台","name":"用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台","description":"用约 300 行 Swift 代码，零第三方依赖，把 iPhone 变成功能完备的 Kimi CLI 控制台。详解 Web UI 架构、Wire 协议和 iOS 封装实现。","keywords":["Kimi CLI","Swift","iOS","WebView","AI 工具"],"articleBody":"用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台 你在咖啡馆喝完拿铁，突然想起 Mac 上挂着的 Kimi CLI 正在跑一个代码分析任务。你掏出手机，打开一个原生 App，看到 Agent 的输出正在实时滚动，已经跑完三分之二。你追加一条新指令，然后继续刷朋友圈。\n这不是科幻场景。只需要约 300 行 Swift 代码，零第三方依赖，就能把 iPhone 变成功能完备的 Kimi CLI 控制台。手机端并不是把 CLI 跑在手机上，而是给 Kimi 已有的 Web UI 套一层原生壳，借助 WebView 直接复用现有界面。这个项目的特点是代码量少，更多时间花在理解架构和拆解任务上。\nTL;DR — 读完你会得到什么\n理解 Kimi CLI 的「内核 + 多前端」架构，以及 Web UI 为什么能让移动端封装变得低成本 掌握 useSessionStream 中两个关键设计：wsRef 连接守卫 + Ref 流式累积 知道 WKWebView 封装的三个必踩坑：ATS 权限 / JS 弹窗 / 真机网络 获得一个可复用的工程模式：「本地 Web 服务 + WebView」 学到一套面对不确定目标的拆解方法：把大问题拆成可验证的小实验 阅读路线：如果你只想 30 分钟做一个 iOS 壳，直接跳到第 4 节 + 第 5 节 + Quick Start。如果你想理解 Web UI 的通信机制或基于 Wire 协议做自定义客户端，重点读第 2 节。\n1. 背景与需求 1.1 为什么需要手机操控 CLI CLI 工具的生产力很高，但它们被锁在终端里。坐在地铁上想看看刚才让 Kimi 分析的日志有没有跑完，通常只能掏出笔记本。\n更麻烦的是，很多 CLI Agent 任务是长时运行的，代码审查、日志分析、测试报告生成动辄几分钟，随时查看进度、调整策略就变得很有价值。\n这个需求一直存在，但合适的方案不多。Remote Desktop 太重，SSH + tmux 太原始，第三方面板又引入信任和部署成本。理想方案：原生、轻量、无侵入，让手机成为 CLI 的第二块屏幕。\n1.2 Kimi Web UI 是什么 Kimi CLI 在 v1.4（2026-01-30）引入了 kimi web 命令。执行后，本地 Web 服务在 127.0.0.1:5494 启动，浏览器打开即可看到控制台界面，支持实时对话、文件上传、会话管理、流式响应，体验接近终端版。\nKimi CLI 采用「内核 + 多前端」架构：终端 Shell、Web UI、IDE 侧边栏都是前端壳，背后是同一个 Agent 内核，通过统一的 Wire 协议通信。\n这套架构的优势在于解耦，Web UI 只需做好展示数据、接收输入、管理连接三件事，也为移动端封装打开了入口。\n2. Web UI 核心代码解析 2.1 三层架构总览 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ┌─────────────────────────────────────────┐ │ Frontend: React + TypeScript + Vite │ │ 浏览器中运行的 UI 界面 │ └──────────────────┬──────────────────────┘ │ WebSocket ↓ ┌─────────────────────────────────────────┐ │ Backend: FastAPI + WebSocket │ │ Python 后端，消息转发层 │ └──────────────────┬──────────────────────┘ │ Wire 协议 (JSON-RPC 2.0) ↓ ┌─────────────────────────────────────────┐ │ Agent Core: Kimi CLI Wire Mode │ │ AI Agent 运行时内核 │ └─────────────────────────────────────────┘ 内核通过 Wire 协议对外暴露能力，任何客户端都能接入。\n2.2 Wire 协议通信机制 Wire 协议基于 JSON-RPC 2.0 规范，当前版本 1.3。它定义了四种核心消息类型：\n消息类型 方向 用途 initialize Client → Server 握手协商，确认协议版本和能力 prompt Client → Server 发送用户输入，启动新对话轮次 event Server → Client 推送内容片段，流式响应的关键 request Server → Client 请求审批或工具调用确认 一次典型的交互流程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 sequenceDiagram participant C as Client (Web UI) participant S as Server (Agent Core) C-\u003e\u003eS: initialize S--\u003e\u003eC: response (协议版本+能力) C-\u003e\u003eS: prompt(用户输入) S--\u003e\u003eC: event: TurnBegin S--\u003e\u003eC: event: StepBegin S--\u003e\u003eC: event: ContentPart (思考过程) S--\u003e\u003eC: event: ContentPart S--\u003e\u003eC: event: ToolCall (工具调用) S--\u003e\u003eC: request: Approval (请求审批) C-\u003e\u003eS: response: approve S--\u003e\u003eC: event: ToolResult (工具结果) S--\u003e\u003eC: event: ContentPart (最终回复) S--\u003e\u003eC: session_status: idle event 是流式输出的核心：Agent 每生成一小段内容就推送一个 ContentPart 事件，前端逐步累积渲染，呈现打字机效果。\n值得注意的是，这里的实时通信走的是 WebSocket，而非 HTTP 轮询。WebSocket 提供了全双工通道，适合 Agent 这种「持续推送 + 偶尔上行」的交互模式。前端通过 WebSocket 接收 Wire 事件流，同时也能随时发送取消、审批等控制消息，不必等服务端回复完毕。\n2.3 useSessionStream：实时通信的心脏 useSessionStream 管理 WebSocket 连接、解析 Wire 消息、更新状态，对外接口简洁：\n1 2 3 4 5 6 useSessionStream({ sessionId }) ├── messages: LiveMessage[] // UI 消息列表 ├── status: ChatStatus // 流状态 ├── sendMessage(text) // 发送消息 ├── respondToApproval(id, decision) // 响应审批 └── cancel() // 取消当前流 上层组件只用这五个成员，不必关心 WebSocket 和 Wire 协议细节。\nWebSocket 生命周期管理\nHook 用 useLayoutEffect 监听 sessionId 变化：切换会话时先关闭旧连接、重置状态，再延迟 50ms 建立新连接，避免快速切换时堆积无效连接。\n关键设计一：wsRef 身份验证\n用户快速从 Session A 切换到 Session B 时，A 的 WebSocket onmessage 回调可能仍在事件队列中。如果不加控制，B 的界面会显示 A 的消息。\n解法是给每个回调加一道守卫：\n1 2 3 4 5 6 7 8 const ws = new WebSocket(url); wsRef.current = ws; // 将当前连接注册为「活跃连接」 ws.onmessage = (e) =\u003e { // 如果当前活跃连接已不是这个 ws，直接忽略 if (wsRef.current !== ws) return; handleMessage(e.data); }; wsRef.current 始终指向最新的活跃连接，过期连接的回调会被守卫拦截。时间线上看：\n1 2 3 T1: 点击 Session A → wsRef.current = A T2: 点击 Session B → 关闭 A, wsRef.current = B T3: A 的 onmessage 延迟到达 → wsRef.current(B) !== A → 忽略 所有回调（onmessage、onclose、onerror）都带有这个守卫。\n关键设计二：流式状态累积（Ref vs State）\nContentPart 事件每秒可能推送几十次。每次都调用 setState 会触发同等次数的重渲染。\n解法是用 Ref 累积中间状态，在合适的时机统一更新 State：\n1 2 3 4 5 6 7 8 9 10 11 const currentThinkingRef = useRef(\"\"); // 累积思考内容，不触发渲染 const currentTextRef = useRef(\"\"); // 累积回复文本，不触发渲染 case \"ContentPart\": { if (type === \"think\") { // 追加到 Ref 而非 State，避免高频 setState currentThinkingRef.current += event.payload.think ?? \"\"; } else if (type === \"text\") { currentTextRef.current += event.payload.text ?? \"\"; } } Ref 的修改不触发重渲染，只在需要更新 UI 时才同步到 State。\n事件分发\nprocessEvent 用 switch 路由所有 Wire 事件：TurnBegin 创建消息、StepBegin 重置步骤、ContentPart 累积内容、ToolCall/ToolResult 处理工具调用、ApprovalRequest 弹审批框、StatusUpdate 更新上下文用量。\n2.4 状态分层与性能优化 Web UI 将状态按更新频率和共享范围分为三层：\n1 2 3 Layer 3: 全局状态 (Zustand) → 消息队列、工具事件 Layer 2: 共享状态 (Hooks) → 会话列表、消息流、配置 Layer 1: 组件状态 (useState) → UI 开关、折叠状态 分层的目的是控制重渲染的波及范围，高频变化的状态下沉到最小作用域，避免牵连无关组件。\n第一个优化手段是 Container/Presentational（容器/展示）分离。ChatWorkspaceContainer 订阅 useSessionStream 的高频更新，重渲染不会波及 App.tsx 和侧边栏。消息流式更新时，只有聊天区域重渲染，其余部分保持静止。\n第二个手段是虚拟列表。react-virtuoso 只渲染可见区域的消息（约 10-20 条），即使会话中有上万条历史消息也不会卡顿：\n1 2 3 4 5 6 7 \u003cVirtuoso data={messages} computeItemKey={(index, msg) =\u003e msg.id} followOutput=\"smooth\" key={conversationKey} itemContent={(index, msg) =\u003e \u003cMessageItem message={msg} /\u003e} /\u003e computeItemKey 用 message.id 保证列表项稳定，followOutput=\"smooth\" 自动滚动到底，conversationKey 在切换会话时强制重新挂载，避免滚动位置残留。\n3. 任务拆解：从想法到可执行步骤 3.1 面对不确定性的拆解策略 理解了 Web UI 的架构后，我决定在手机上复现它。但我面对两个不确定性：不懂 iOS 开发，也不知道 WKWebView 能否完整承载 Web UI。\n策略是把目标拆成三个小实验，每个只回答一个问题，失败代价控制在半天以内。\n3.2 三阶段实验设计 阶段一：找到 Kimi Web 服务\n要回答的问题：Kimi Web UI 到底跑在哪里，我能直接访问吗？\n我在终端执行 kimi web 启动服务后，用 lsof | grep kimi 找不到端口。卡了一会儿才想起来，Kimi CLI 是 Python 编写的，进程名是 python 而不是 kimi。换成 lsof -i -P | grep python | grep LISTEN 就定位到端口 5494。\n浏览器打开 http://127.0.0.1:5494，Web UI 完整可用。可行性确认。耗时约 30 分钟。\n阶段二：验证 iOS 开发门槛\n要回答的问题：作为零 iOS 经验的人，我能不能在 Xcode 里写出一个能运行的 App？\n我用 SwiftUI 写了一个 Hello World App，不到 100 行代码，在模拟器和真机上都跑通了。SwiftUI 的声明式语法和 React 很像，学习成本比预期低。门槛可接受。耗时约 2 小时（含环境搭建）。\n阶段三：WebView 封装\n要回答的问题：WKWebView 能不能正常加载 Kimi Web UI，所有交互功能是否可用？\n用 WKWebView 加载本地 Web 服务，遇到三个问题：HTTP 被 ATS 拦截、JS 弹窗不显示、真机连不上。逐一解决后，3 个 Swift 文件，287 行代码，功能完整可用。耗时约 3 小时。\n3.3 拆解的价值 每步成本低（最长 3 小时），且有明确的成败标准。每步边界清楚，出问题时容易定位。\n4. iOS 封装核心实现 4.1 项目结构 整个项目只有四个文件：\n1 2 3 4 5 KimiWebUI/ ├── KimiWebUIApp.swift # App 入口 ├── ContentView.swift # 主界面（地址栏 + WebView） ├── WebView.swift # WKWebView 封装 └── Info.plist # 权限配置（ATS + 本地网络） 完整源码见 GitHub 仓库（TODO: 替换为实际地址）。\n4.2 权限配置 ATS（App Transport Security）\niOS 默认禁止 HTTP 明文传输，而 Kimi Web UI 用的是 HTTP。我们不必全局禁用 ATS，只需开启本地网络例外：\n1 2 3 4 5 6 NSAppTransportSecurity NSAllowsLocalNetworking 相比 NSAllowsArbitraryLoads（全局放开），NSAllowsLocalNetworking 只对本地/局域网 IP 生效，是 Apple 推荐的更窄例外。如果需要对特定域名单独放行，可以用 NSExceptionDomains。\n本地网络访问权限\n真机访问局域网 IP 时，iOS 会弹出「本地网络」权限弹窗。需要在 Info.plist 中声明用途，否则用户可能拒绝授权：\n1 2 NSLocalNetworkUsageDescription 需要访问本地网络以连接 Mac 上运行的 Kimi CLI Web 服务 详见 Apple TN3179: Understanding local network privacy。\n4.3 WKWebView 封装 SwiftUI 没有原生 WebView 组件，需要通过 UIViewRepresentable 协议桥接 UIKit 的 WKWebView。核心在 makeUIView 方法中完成配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func makeUIView(context: Context) -\u003e WKWebView { let config = WKWebViewConfiguration() config.preferences.javaScriptEnabled = true // React 应用必须启用 JS config.websiteDataStore = .default() // 持久化存储，保持登录态 let webView = WKWebView(frame: .zero, configuration: config) webView.allowsBackForwardNavigationGestures = true // 支持左右滑动导航 webView.navigationDelegate = context.coordinator webView.uiDelegate = context.coordinator // 桥接 JS 弹窗（见 4.4） if let url = URL(string: urlString) { webView.load(URLRequest(url: url)) } return webView } 各配置项的作用：\n配置项 作用 必要性 javaScriptEnabled 启用 JS 执行 必须（React 依赖） websiteDataStore 持久化 Cookie / LocalStorage 推荐（保持会话状态） allowsBackForwardNavigationGestures 左右滑动前进后退 体验优化 uiDelegate 处理 JS 弹窗 关键（见下节） 4.4 JavaScript 弹窗桥接 WKWebView 默认静默忽略 JS 弹窗（alert/confirm/prompt）。Kimi Web UI 用 confirm() 做删除确认，忽略后用户点删除按钮毫无反应。\n解法是实现 WKUIDelegate 的三个方法，把 JS 弹窗桥接到原生 UIAlertController。以 confirm() 为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -\u003e Void) { // 从当前 window scene 获取根视图控制器（兼容多窗口） guard let windowScene = UIApplication.shared.connectedScenes .first(where: { $0.activationState == .foregroundActive }) as? UIWindowScene, let vc = windowScene.windows.first?.rootViewController else { completionHandler(false) return } let alert = UIAlertController(title: nil, message: message, preferredStyle: .alert) alert.addAction(UIAlertAction(title: \"取消\", style: .cancel) { _ in completionHandler(false) // 用户点取消 → JS confirm() 返回 false }) alert.addAction(UIAlertAction(title: \"确定\", style: .default) { _ in completionHandler(true) // 用户点确定 → JS confirm() 返回 true }) vc.present(alert, animated: true) } 三个弹窗方法模式相同，区别仅在 completionHandler 的参数类型：alert() 传 Void，confirm() 传 Bool，prompt() 传 String?。\n注：早期写法常用 UIApplication.shared.windows.first?.rootViewController，但 windows 属性已被标记 deprecated。上面的写法通过 UIWindowScene 获取活跃窗口，兼容多 Scene 场景。\n4.5 网络差异处理 模拟器和真机访问本地服务的网络路径不同：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 模拟器： 真机： ┌────────────┐ ┌────────────┐ │ Simulator │ │ iPhone │ │ 127.0.0.1 │ │ 127.0.0.1 │ └─────┬──────┘ └─────┬──────┘ │ 共享网络栈 │ 指向自己 ↓ ↓ ┌────────────┐ ┌────────────┐ │ Mac 本机 │ │ 路由器 │ │ :5494 │ │ │ └────────────┘ └─────┬──────┘ ↓ kimi web ┌────────────┐ │ Mac :5494 │ └────────────┘ kimi web --network 模拟器与 Mac 共享网络栈，127.0.0.1 指向 Mac 本机，直接用 kimi web 就能访问。真机是独立设备，127.0.0.1 指向自己，必须用 kimi web --network 绑定 0.0.0.0，然后用 Mac 的局域网 IP 访问。\nApp 中设计了地址切换功能，提供预设地址列表（127.0.0.1 + 常见局域网网段），用户可以快速切换或手动输入。\n4.6 安全模型与部署建议 用 --network 暴露 Web 服务到局域网时，需要考虑安全边界。Kimi CLI 的 Agent 具备文件读写、命令执行、工具调用等能力，如果控制面暴露给同网段的其他人，后果不可控。\nKimi CLI 从 v1.6（2026-02-03）起引入了基于 Token 的认证和访问控制：\n参数 作用 --auth-token 启用 Token 认证，客户端需携带 Token 才能访问 --lan-only 仅允许局域网访问（拒绝公网流量） --allowed-origins 限制允许的请求来源（CORS 白名单） --restrict-sensitive-apis 限制敏感 API（文件操作、命令执行等） 一条原则：远程访问默认最小权限。Agent 能读写文件、跑命令、调用工具，暴露控制面等于把 Mac 的操作权交出去。--restrict-sensitive-apis 会禁掉文件写入、命令执行等高危 API，--network 场景下建议始终开启，只在明确需要时关闭。\n推荐的部署姿势：\n仅本机调试：默认 kimi web，服务只绑定 127.0.0.1，不出本机 局域网真机：kimi web --network --auth-token \u003c强随机token\u003e --lan-only --restrict-sensitive-apis 不要在不可信网络暴露服务，即使加了 Token，当前方案走的是 HTTP 明文，同网段可被嗅探 详见 Kimi CLI 变更记录 中 v1.6 的安全更新。\n5. 踩坑速查 现象 根因 解法 模拟器正常，真机白屏 真机是独立设备，127.0.0.1 指向自己 kimi web --network + Mac 局域网 IP 删除会话等操作无反应 WKWebView 默认静默忽略 JS 弹窗 实现 WKUIDelegate 三个方法桥接弹窗 lsof | grep kimi 查不到端口 Kimi CLI 是 Python 程序，进程名是 python lsof -i -P | grep python | grep LISTEN，默认 5494，占用时顺延至 5503 真机弹「是否允许访问本地网络」后被拒绝 缺少 NSLocalNetworkUsageDescription 在 Info.plist 中添加本地网络用途说明（见 4.2） 弹窗代码编译有 deprecation 警告 UIApplication.shared.windows 已废弃 改用 UIWindowScene 获取活跃窗口（见 4.4） 6. 小结 6.1 核心要点回顾 回到开篇的场景：在咖啡馆能用手机操控 Kimi CLI 吗？可以，实现成本远低于预期。\n架构：Kimi Web UI 三层设计（React 前端 + FastAPI 后端 + Agent 内核）通过 Wire 协议解耦 UI 与 Agent，Web UI 只是 Agent 内核的一种「壳」。 代码机制：useSessionStream 用 wsRef 守卫解决多连接竞态，用 Ref 累积流式状态避免高频渲染，processEvent 路由十几种 Wire 事件。 封装三要素：WKWebView 封装需要处理 HTTP 权限（ATS 配置）、JS 弹窗桥接（WKUIDelegate）、网络差异（模拟器 vs 真机）三个关键问题。 方法论：面对不确定目标，拆成可验证的小步骤（找进程 → iOS 入门 → WebView 封装），每步只回答一个问题，失败代价控制在半天以内。 6.2 架构局限与演进方向 当前方案有几个值得正视的限制：\n网络边界：手机和 Mac 必须在同一局域网。离开咖啡馆的 Wi-Fi，连接就断了。跨网访问有几条路：VPN 组网（Tailscale、WireGuard 等把两台设备拉到同一虚拟私网，加密且不暴露公网端口，个人自用推荐）、反向隧道（Cloudflare Tunnel、ngrok，省事但引入第三方中转）、公网部署 + 域名 + TLS（工程最完整，但你得把它当一个互联网服务来做安全）。注意 VPN + WebSocket 偶尔有兼容问题（某些组网工具会出现 WebSocket 403），真跑之前需要验收。\n传输安全：当前方案走 HTTP/WS 明文，局域网内可被同网段设备嗅探。个人开发场景风险可控，但如果 Agent 处理敏感代码或执行高权限操作，应当升级到 HTTPS/WSS。最直接的做法是在 Kimi Web 前面加一个反向代理（Caddy、nginx）做 TLS 终止，本地证书用 mkcert 生成即可。\n连接稳定性：WebSocket 长连接在移动端有天然脆弱性。手机切后台时 iOS 会挂起网络，回前台后连接已断。生产可用需要至少两件事：断线重连策略（指数退避 + 恢复到正确 session），以及回前台时的状态检测和自动恢复。如果需要离线可读，可以在本地缓存历史消息，形成 WebSocket（实时）+ HTTP（补偿）+ 本地缓存（离线）的三层架构。\n通信模型：Kimi Web UI 的通信是 WebSocket 全双工，不是传统的 HTTP 请求-响应。这其实是正确的选择。Agent 的输出是持续的流式推送（每秒几十个 ContentPart 事件），HTTP 轮询在这个场景下延迟高、开销大。WebSocket 保持一条长连接，服务端可以随时推送，客户端也能随时发送取消或审批，双向实时。\n服务端运维：Demo 阶段手动跑 kimi web 没问题，长期使用需要考虑：开机自启（launchd plist 或 systemd service）、日志（至少记录访问和认证失败）、Token 轮换策略（定期更换 --auth-token）。\n可复用的工程模式：「本地 Web 服务 + WebView」适用于任何提供 Web 界面的 CLI 工具。后端有 HTTP 接口就能跨平台复用，代价是性能和体验不如原生。对于 AI Agent 这种交互密度不高的场景，WebView 够用。当交互复杂度上升（比如需要原生手势、离线缓存、推送通知），就需要考虑原生 UI + Wire 协议直连的方案了。\n6.3 快速开始 前置条件：\nKimi CLI \u003e= v1.4（推荐 \u003e= v1.6，支持 Token 认证） Xcode \u003e= 15.0，iOS \u003e= 16.0 Mac 和 iPhone 在同一 Wi-Fi 网络下 30 分钟部署清单：\n启动服务：kimi web --network --auth-token mytoken --lan-only --restrict-sensitive-apis 获取 Mac 局域网 IP：ipconfig getifaddr en0 用 Xcode 新建 iOS 项目，将本文第 4、5 节的代码添加进去 在 ContentView.swift 中修改 serverAddress 为 http://:5494 连接 iPhone，在 Xcode 中选择真机目标，点击 Run 命令速查表：\n场景 命令 默认启动（仅本机） kimi web 局域网 + 认证 + 最小权限 kimi web --network --auth-token --lan-only --restrict-sensitive-apis 指定端口 kimi web --port 8080 获取 Mac IP ipconfig getifaddr en0 查找 Kimi Web 端口 lsof -i -P | grep python | grep LISTEN 进阶资源：\nKimi CLI Wire 模式文档：协议细节和扩展开发 Kimi CLI 变更记录：各版本安全功能演进 Apple WKWebView 文档：API 参考和最佳实践 Apple: Preventing Insecure Network Connections：ATS 配置最佳实践 回头看，这个项目的大部分时间花在理解系统边界上，真正动手写代码反而很快。\n","wordCount":"1580","inLanguage":"zh","datePublished":"2026-02-16T01:20:00+08:00","dateModified":"2026-02-16T10:48:14+08:00","author":{"@type":"Person","name":"Miss-you"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://miss-you.github.io/posts/20260216-swift-kimi-cli-console/"},"publisher":{"@type":"Organization","name":"Yousa Driven Development | YDD","logo":{"@type":"ImageObject","url":"https://miss-you.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://miss-you.github.io/ accesskey=h title="Yousa Driven Development | YDD (Alt + H)">Yousa Driven Development | YDD</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://miss-you.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://miss-you.github.io/archives title=归档><span>归档</span></a></li><li><a href=https://miss-you.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://miss-you.github.io/tools/ title=工具><span>工具</span></a></li><li><a href=https://miss-you.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://github.com/Miss-you title=GitHub><span>GitHub</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://miss-you.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://miss-you.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台</h1><div class=post-description>用约 300 行 Swift 代码，零第三方依赖，把 iPhone 变成功能完备的 Kimi CLI 控制台。详解 Web UI 架构、Wire 协议和 iOS 封装实现。</div><div class=post-meta><span title='2026-02-16 01:20:00 +0800 +0800'>二月 16, 2026</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;12781 字&nbsp;·&nbsp;Miss-you&nbsp;|&nbsp;<a href=https://github.com/Miss-you/miss-you.github.io/tree/main/content/posts/20260216-swift-kimi-cli-console/index.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-背景与需求>1. 背景与需求</a><ul><li><a href=#11-为什么需要手机操控-cli>1.1 为什么需要手机操控 CLI</a></li><li><a href=#12-kimi-web-ui-是什么>1.2 Kimi Web UI 是什么</a></li></ul></li><li><a href=#2-web-ui-核心代码解析>2. Web UI 核心代码解析</a><ul><li><a href=#21-三层架构总览>2.1 三层架构总览</a></li><li><a href=#22-wire-协议通信机制>2.2 Wire 协议通信机制</a></li><li><a href=#23-usesessionstream实时通信的心脏>2.3 <code>useSessionStream</code>：实时通信的心脏</a></li><li><a href=#24-状态分层与性能优化>2.4 状态分层与性能优化</a></li></ul></li><li><a href=#3-任务拆解从想法到可执行步骤>3. 任务拆解：从想法到可执行步骤</a><ul><li><a href=#31-面对不确定性的拆解策略>3.1 面对不确定性的拆解策略</a></li><li><a href=#32-三阶段实验设计>3.2 三阶段实验设计</a></li><li><a href=#33-拆解的价值>3.3 拆解的价值</a></li></ul></li><li><a href=#4-ios-封装核心实现>4. iOS 封装核心实现</a><ul><li><a href=#41-项目结构>4.1 项目结构</a></li><li><a href=#42-权限配置>4.2 权限配置</a></li><li><a href=#43-wkwebview-封装>4.3 <code>WKWebView</code> 封装</a></li><li><a href=#44-javascript-弹窗桥接>4.4 JavaScript 弹窗桥接</a></li><li><a href=#45-网络差异处理>4.5 网络差异处理</a></li><li><a href=#46-安全模型与部署建议>4.6 安全模型与部署建议</a></li></ul></li><li><a href=#5-踩坑速查>5. 踩坑速查</a></li><li><a href=#6-小结>6. 小结</a><ul><li><a href=#61-核心要点回顾>6.1 核心要点回顾</a></li><li><a href=#62-架构局限与演进方向>6.2 架构局限与演进方向</a></li><li><a href=#63-快速开始>6.3 快速开始</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=用-300-行-swift-让-iphone-变成-kimi-cli-控制台>用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台<a hidden class=anchor aria-hidden=true href=#用-300-行-swift-让-iphone-变成-kimi-cli-控制台>#</a></h1><p>你在咖啡馆喝完拿铁，突然想起 Mac 上挂着的 Kimi CLI 正在跑一个代码分析任务。你掏出手机，打开一个原生 App，看到 Agent 的输出正在实时滚动，已经跑完三分之二。你追加一条新指令，然后继续刷朋友圈。</p><p>这不是科幻场景。只需要约 300 行 Swift 代码，零第三方依赖，就能把 iPhone 变成功能完备的 Kimi CLI 控制台。手机端并不是把 CLI 跑在手机上，而是给 Kimi 已有的 Web UI 套一层原生壳，借助 WebView 直接复用现有界面。这个项目的特点是代码量少，更多时间花在理解架构和拆解任务上。</p><blockquote><p><strong>TL;DR — 读完你会得到什么</strong></p><ol><li>理解 Kimi CLI 的「内核 + 多前端」架构，以及 Web UI 为什么能让移动端封装变得低成本</li><li>掌握 <code>useSessionStream</code> 中两个关键设计：wsRef 连接守卫 + Ref 流式累积</li><li>知道 <code>WKWebView</code> 封装的三个必踩坑：ATS 权限 / JS 弹窗 / 真机网络</li><li>获得一个可复用的工程模式：「本地 Web 服务 + WebView」</li><li>学到一套面对不确定目标的拆解方法：把大问题拆成可验证的小实验</li></ol></blockquote><p><strong>阅读路线</strong>：如果你只想 30 分钟做一个 iOS 壳，直接跳到第 4 节 + 第 5 节 + Quick Start。如果你想理解 Web UI 的通信机制或基于 Wire 协议做自定义客户端，重点读第 2 节。</p><hr><h2 id=1-背景与需求>1. 背景与需求<a hidden class=anchor aria-hidden=true href=#1-背景与需求>#</a></h2><h3 id=11-为什么需要手机操控-cli>1.1 为什么需要手机操控 CLI<a hidden class=anchor aria-hidden=true href=#11-为什么需要手机操控-cli>#</a></h3><p>CLI 工具的生产力很高，但它们被锁在终端里。坐在地铁上想看看刚才让 Kimi 分析的日志有没有跑完，通常只能掏出笔记本。</p><p>更麻烦的是，很多 CLI Agent 任务是长时运行的，代码审查、日志分析、测试报告生成动辄几分钟，随时查看进度、调整策略就变得很有价值。</p><p>这个需求一直存在，但合适的方案不多。Remote Desktop 太重，SSH + tmux 太原始，第三方面板又引入信任和部署成本。理想方案：原生、轻量、无侵入，让手机成为 CLI 的第二块屏幕。</p><h3 id=12-kimi-web-ui-是什么>1.2 Kimi Web UI 是什么<a hidden class=anchor aria-hidden=true href=#12-kimi-web-ui-是什么>#</a></h3><p>Kimi CLI 在 v1.4（2026-01-30）引入了 <code>kimi web</code> 命令。执行后，本地 Web 服务在 <code>127.0.0.1:5494</code> 启动，浏览器打开即可看到控制台界面，支持实时对话、文件上传、会话管理、流式响应，体验接近终端版。</p><p>Kimi CLI 采用「内核 + 多前端」架构：终端 Shell、Web UI、IDE 侧边栏都是前端壳，背后是同一个 Agent 内核，通过统一的 Wire 协议通信。</p><p>这套架构的优势在于解耦，Web UI 只需做好展示数据、接收输入、管理连接三件事，也为移动端封装打开了入口。</p><hr><h2 id=2-web-ui-核心代码解析>2. Web UI 核心代码解析<a hidden class=anchor aria-hidden=true href=#2-web-ui-核心代码解析>#</a></h2><h3 id=21-三层架构总览>2.1 三层架构总览<a hidden class=anchor aria-hidden=true href=#21-三层架构总览>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>┌─────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│  Frontend: React + TypeScript + Vite   │
</span></span><span class=line><span class=cl>│  浏览器中运行的 UI 界面                  │
</span></span><span class=line><span class=cl>└──────────────────┬──────────────────────┘
</span></span><span class=line><span class=cl>                   │ WebSocket
</span></span><span class=line><span class=cl>                   ↓
</span></span><span class=line><span class=cl>┌─────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│  Backend: FastAPI + WebSocket          │
</span></span><span class=line><span class=cl>│  Python 后端，消息转发层                │
</span></span><span class=line><span class=cl>└──────────────────┬──────────────────────┘
</span></span><span class=line><span class=cl>                   │ Wire 协议 (JSON-RPC 2.0)
</span></span><span class=line><span class=cl>                   ↓
</span></span><span class=line><span class=cl>┌─────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│  Agent Core: Kimi CLI Wire Mode        │
</span></span><span class=line><span class=cl>│  AI Agent 运行时内核                    │
</span></span><span class=line><span class=cl>└─────────────────────────────────────────┘
</span></span></code></pre></td></tr></table></div></div><p>内核通过 Wire 协议对外暴露能力，任何客户端都能接入。</p><h3 id=22-wire-协议通信机制>2.2 Wire 协议通信机制<a hidden class=anchor aria-hidden=true href=#22-wire-协议通信机制>#</a></h3><p>Wire 协议基于 JSON-RPC 2.0 规范，当前版本 1.3。它定义了四种核心消息类型：</p><table><thead><tr><th>消息类型</th><th>方向</th><th>用途</th></tr></thead><tbody><tr><td><code>initialize</code></td><td>Client → Server</td><td>握手协商，确认协议版本和能力</td></tr><tr><td><code>prompt</code></td><td>Client → Server</td><td>发送用户输入，启动新对话轮次</td></tr><tr><td><code>event</code></td><td>Server → Client</td><td>推送内容片段，流式响应的关键</td></tr><tr><td><code>request</code></td><td>Server → Client</td><td>请求审批或工具调用确认</td></tr></tbody></table><p>一次典型的交互流程：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sequenceDiagram
</span></span><span class=line><span class=cl>    participant C as Client (Web UI)
</span></span><span class=line><span class=cl>    participant S as Server (Agent Core)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    C-&gt;&gt;S: initialize
</span></span><span class=line><span class=cl>    S--&gt;&gt;C: response (协议版本+能力)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    C-&gt;&gt;S: prompt(用户输入)
</span></span><span class=line><span class=cl>    S--&gt;&gt;C: event: TurnBegin
</span></span><span class=line><span class=cl>    S--&gt;&gt;C: event: StepBegin
</span></span><span class=line><span class=cl>    S--&gt;&gt;C: event: ContentPart (思考过程)
</span></span><span class=line><span class=cl>    S--&gt;&gt;C: event: ContentPart
</span></span><span class=line><span class=cl>    S--&gt;&gt;C: event: ToolCall (工具调用)
</span></span><span class=line><span class=cl>    S--&gt;&gt;C: request: Approval (请求审批)
</span></span><span class=line><span class=cl>    C-&gt;&gt;S: response: approve
</span></span><span class=line><span class=cl>    S--&gt;&gt;C: event: ToolResult (工具结果)
</span></span><span class=line><span class=cl>    S--&gt;&gt;C: event: ContentPart (最终回复)
</span></span><span class=line><span class=cl>    S--&gt;&gt;C: session_status: idle
</span></span></code></pre></td></tr></table></div></div><p><code>event</code> 是流式输出的核心：Agent 每生成一小段内容就推送一个 <code>ContentPart</code> 事件，前端逐步累积渲染，呈现打字机效果。</p><p>值得注意的是，这里的实时通信走的是 WebSocket，而非 HTTP 轮询。WebSocket 提供了全双工通道，适合 Agent 这种「持续推送 + 偶尔上行」的交互模式。前端通过 WebSocket 接收 Wire 事件流，同时也能随时发送取消、审批等控制消息，不必等服务端回复完毕。</p><h3 id=23-usesessionstream实时通信的心脏>2.3 <code>useSessionStream</code>：实时通信的心脏<a hidden class=anchor aria-hidden=true href=#23-usesessionstream实时通信的心脏>#</a></h3><p><code>useSessionStream</code> 管理 WebSocket 连接、解析 Wire 消息、更新状态，对外接口简洁：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=nx>useSessionStream</span><span class=p>({</span> <span class=nx>sessionId</span> <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=err>├──</span> <span class=nx>messages</span>: <span class=kt>LiveMessage</span><span class=p>[]</span>          <span class=c1>// UI 消息列表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>├──</span> <span class=nx>status</span>: <span class=kt>ChatStatus</span>               <span class=c1>// 流状态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>├──</span> <span class=nx>sendMessage</span><span class=p>(</span><span class=nx>text</span><span class=p>)</span>                <span class=c1>// 发送消息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>├──</span> <span class=nx>respondToApproval</span><span class=p>(</span><span class=nx>id</span><span class=p>,</span> <span class=nx>decision</span><span class=p>)</span>  <span class=c1>// 响应审批
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>└──</span> <span class=nx>cancel</span><span class=p>()</span>                         <span class=c1>// 取消当前流
</span></span></span></code></pre></td></tr></table></div></div><p>上层组件只用这五个成员，不必关心 WebSocket 和 Wire 协议细节。</p><p><strong>WebSocket 生命周期管理</strong></p><p>Hook 用 <code>useLayoutEffect</code> 监听 <code>sessionId</code> 变化：切换会话时先关闭旧连接、重置状态，再延迟 50ms 建立新连接，避免快速切换时堆积无效连接。</p><p><strong>关键设计一：wsRef 身份验证</strong></p><p>用户快速从 Session A 切换到 Session B 时，A 的 WebSocket <code>onmessage</code> 回调可能仍在事件队列中。如果不加控制，B 的界面会显示 A 的消息。</p><p>解法是给每个回调加一道守卫：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7>7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>ws</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>WebSocket</span><span class=p>(</span><span class=nx>url</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>wsRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>=</span> <span class=nx>ws</span><span class=p>;</span>               <span class=c1>// 将当前连接注册为「活跃连接」
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>ws</span><span class=p>.</span><span class=nx>onmessage</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 如果当前活跃连接已不是这个 ws，直接忽略
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nx>wsRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>!==</span> <span class=nx>ws</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>handleMessage</span><span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p><code>wsRef.current</code> 始终指向最新的活跃连接，过期连接的回调会被守卫拦截。时间线上看：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>T1: 点击 Session A → wsRef.current = A
</span></span><span class=line><span class=cl>T2: 点击 Session B → 关闭 A, wsRef.current = B
</span></span><span class=line><span class=cl>T3: A 的 onmessage 延迟到达 → wsRef.current(B) !== A → 忽略
</span></span></code></pre></td></tr></table></div></div><p>所有回调（<code>onmessage</code>、<code>onclose</code>、<code>onerror</code>）都带有这个守卫。</p><p><strong>关键设计二：流式状态累积（Ref vs State）</strong></p><p><code>ContentPart</code> 事件每秒可能推送几十次。每次都调用 <code>setState</code> 会触发同等次数的重渲染。</p><p>解法是用 Ref 累积中间状态，在合适的时机统一更新 State：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>currentThinkingRef</span> <span class=o>=</span> <span class=nx>useRef</span><span class=p>(</span><span class=s2>&#34;&#34;</span><span class=p>);</span>   <span class=c1>// 累积思考内容，不触发渲染
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>currentTextRef</span> <span class=o>=</span> <span class=nx>useRef</span><span class=p>(</span><span class=s2>&#34;&#34;</span><span class=p>);</span>       <span class=c1>// 累积回复文本，不触发渲染
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=s2>&#34;ContentPart&#34;</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=kr>type</span> <span class=o>===</span> <span class=s2>&#34;think&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 追加到 Ref 而非 State，避免高频 setState
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>currentThinkingRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>+=</span> <span class=nx>event</span><span class=p>.</span><span class=nx>payload</span><span class=p>.</span><span class=nx>think</span> <span class=o>??</span> <span class=s2>&#34;&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=kr>type</span> <span class=o>===</span> <span class=s2>&#34;text&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>currentTextRef</span><span class=p>.</span><span class=nx>current</span> <span class=o>+=</span> <span class=nx>event</span><span class=p>.</span><span class=nx>payload</span><span class=p>.</span><span class=nx>text</span> <span class=o>??</span> <span class=s2>&#34;&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Ref 的修改不触发重渲染，只在需要更新 UI 时才同步到 State。</p><p><strong>事件分发</strong></p><p><code>processEvent</code> 用 <code>switch</code> 路由所有 Wire 事件：<code>TurnBegin</code> 创建消息、<code>StepBegin</code> 重置步骤、<code>ContentPart</code> 累积内容、<code>ToolCall</code>/<code>ToolResult</code> 处理工具调用、<code>ApprovalRequest</code> 弹审批框、<code>StatusUpdate</code> 更新上下文用量。</p><h3 id=24-状态分层与性能优化>2.4 状态分层与性能优化<a hidden class=anchor aria-hidden=true href=#24-状态分层与性能优化>#</a></h3><p>Web UI 将状态按更新频率和共享范围分为三层：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Layer 3: 全局状态 (Zustand)     → 消息队列、工具事件
</span></span><span class=line><span class=cl>Layer 2: 共享状态 (Hooks)       → 会话列表、消息流、配置
</span></span><span class=line><span class=cl>Layer 1: 组件状态 (useState)    → UI 开关、折叠状态
</span></span></code></pre></td></tr></table></div></div><p>分层的目的是控制重渲染的波及范围，高频变化的状态下沉到最小作用域，避免牵连无关组件。</p><p>第一个优化手段是 Container/Presentational（容器/展示）分离。<code>ChatWorkspaceContainer</code> 订阅 <code>useSessionStream</code> 的高频更新，重渲染不会波及 <code>App.tsx</code> 和侧边栏。消息流式更新时，只有聊天区域重渲染，其余部分保持静止。</p><p>第二个手段是虚拟列表。<code>react-virtuoso</code> 只渲染可见区域的消息（约 10-20 条），即使会话中有上万条历史消息也不会卡顿：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6>6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>Virtuoso</span>
</span></span><span class=line><span class=cl>  <span class=na>data</span><span class=o>=</span><span class=p>{</span><span class=nx>messages</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=na>computeItemKey</span><span class=o>=</span><span class=p>{(</span><span class=nx>index</span><span class=p>,</span> <span class=nx>msg</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>id</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=na>followOutput</span><span class=o>=</span><span class=s>&#34;smooth&#34;</span>
</span></span><span class=line><span class=cl>  <span class=na>key</span><span class=o>=</span><span class=p>{</span><span class=nx>conversationKey</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=na>itemContent</span><span class=o>=</span><span class=p>{(</span><span class=nx>index</span><span class=p>,</span> <span class=nx>msg</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=p>&lt;</span><span class=nt>MessageItem</span> <span class=na>message</span><span class=o>=</span><span class=p>{</span><span class=nx>msg</span><span class=p>}</span> <span class=p>/&gt;}</span>
</span></span><span class=line><span class=cl><span class=p>/&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p><code>computeItemKey</code> 用 <code>message.id</code> 保证列表项稳定，<code>followOutput="smooth"</code> 自动滚动到底，<code>conversationKey</code> 在切换会话时强制重新挂载，避免滚动位置残留。</p><hr><h2 id=3-任务拆解从想法到可执行步骤>3. 任务拆解：从想法到可执行步骤<a hidden class=anchor aria-hidden=true href=#3-任务拆解从想法到可执行步骤>#</a></h2><h3 id=31-面对不确定性的拆解策略>3.1 面对不确定性的拆解策略<a hidden class=anchor aria-hidden=true href=#31-面对不确定性的拆解策略>#</a></h3><p>理解了 Web UI 的架构后，我决定在手机上复现它。但我面对两个不确定性：不懂 iOS 开发，也不知道 <code>WKWebView</code> 能否完整承载 Web UI。</p><p>策略是把目标拆成三个小实验，每个只回答一个问题，失败代价控制在半天以内。</p><h3 id=32-三阶段实验设计>3.2 三阶段实验设计<a hidden class=anchor aria-hidden=true href=#32-三阶段实验设计>#</a></h3><p><strong>阶段一：找到 Kimi Web 服务</strong></p><p>要回答的问题：Kimi Web UI 到底跑在哪里，我能直接访问吗？</p><p>我在终端执行 <code>kimi web</code> 启动服务后，用 <code>lsof | grep kimi</code> 找不到端口。卡了一会儿才想起来，Kimi CLI 是 Python 编写的，进程名是 <code>python</code> 而不是 <code>kimi</code>。换成 <code>lsof -i -P | grep python | grep LISTEN</code> 就定位到端口 5494。</p><p>浏览器打开 <code>http://127.0.0.1:5494</code>，Web UI 完整可用。可行性确认。耗时约 30 分钟。</p><p><strong>阶段二：验证 iOS 开发门槛</strong></p><p>要回答的问题：作为零 iOS 经验的人，我能不能在 Xcode 里写出一个能运行的 App？</p><p>我用 SwiftUI 写了一个 Hello World App，不到 100 行代码，在模拟器和真机上都跑通了。SwiftUI 的声明式语法和 React 很像，学习成本比预期低。门槛可接受。耗时约 2 小时（含环境搭建）。</p><p><strong>阶段三：WebView 封装</strong></p><p>要回答的问题：<code>WKWebView</code> 能不能正常加载 Kimi Web UI，所有交互功能是否可用？</p><p>用 <code>WKWebView</code> 加载本地 Web 服务，遇到三个问题：HTTP 被 ATS 拦截、JS 弹窗不显示、真机连不上。逐一解决后，3 个 Swift 文件，287 行代码，功能完整可用。耗时约 3 小时。</p><h3 id=33-拆解的价值>3.3 拆解的价值<a hidden class=anchor aria-hidden=true href=#33-拆解的价值>#</a></h3><p>每步成本低（最长 3 小时），且有明确的成败标准。每步边界清楚，出问题时容易定位。</p><hr><h2 id=4-ios-封装核心实现>4. iOS 封装核心实现<a hidden class=anchor aria-hidden=true href=#4-ios-封装核心实现>#</a></h2><h3 id=41-项目结构>4.1 项目结构<a hidden class=anchor aria-hidden=true href=#41-项目结构>#</a></h3><p>整个项目只有四个文件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>KimiWebUI/
</span></span><span class=line><span class=cl>├── KimiWebUIApp.swift       # App 入口
</span></span><span class=line><span class=cl>├── ContentView.swift        # 主界面（地址栏 + WebView）
</span></span><span class=line><span class=cl>├── WebView.swift            # WKWebView 封装
</span></span><span class=line><span class=cl>└── Info.plist               # 权限配置（ATS + 本地网络）
</span></span></code></pre></td></tr></table></div></div><p>完整源码见 <a href=https://github.com/user/kimi-webui-ios>GitHub 仓库</a>（TODO: 替换为实际地址）。</p><h3 id=42-权限配置>4.2 权限配置<a hidden class=anchor aria-hidden=true href=#42-权限配置>#</a></h3><p><strong>ATS（App Transport Security）</strong></p><p>iOS 默认禁止 HTTP 明文传输，而 Kimi Web UI 用的是 HTTP。我们不必全局禁用 ATS，只需开启本地网络例外：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;key&gt;</span>NSAppTransportSecurity<span class=nt>&lt;/key&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;dict&gt;</span>
</span></span><span class=line><span class=cl>    <span class=c>&lt;!-- 仅允许本地网络的 HTTP 请求，不影响公网 HTTPS 策略 --&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;key&gt;</span>NSAllowsLocalNetworking<span class=nt>&lt;/key&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;true/&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/dict&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>相比 <code>NSAllowsArbitraryLoads</code>（全局放开），<a href=https://developer.apple.com/documentation/bundleresources/information-property-list/nsapptransportsecurity/nsallowslocalnetworking><code>NSAllowsLocalNetworking</code></a> 只对本地/局域网 IP 生效，是 Apple 推荐的更窄例外。如果需要对特定域名单独放行，可以用 <a href=https://developer.apple.com/documentation/bundleresources/information-property-list/nsapptransportsecurity/nsexceptiondomains><code>NSExceptionDomains</code></a>。</p><p><strong>本地网络访问权限</strong></p><p>真机访问局域网 IP 时，iOS 会弹出「本地网络」权限弹窗。需要在 <code>Info.plist</code> 中声明用途，否则用户可能拒绝授权：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;key&gt;</span>NSLocalNetworkUsageDescription<span class=nt>&lt;/key&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;string&gt;</span>需要访问本地网络以连接 Mac 上运行的 Kimi CLI Web 服务<span class=nt>&lt;/string&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>详见 Apple <a href=https://developer.apple.com/documentation/technotes/tn3179-understanding-local-network-privacy>TN3179: Understanding local network privacy</a>。</p><h3 id=43-wkwebview-封装>4.3 <code>WKWebView</code> 封装<a hidden class=anchor aria-hidden=true href=#43-wkwebview-封装>#</a></h3><p>SwiftUI 没有原生 WebView 组件，需要通过 <code>UIViewRepresentable</code> 协议桥接 UIKit 的 <code>WKWebView</code>。核心在 <code>makeUIView</code> 方法中完成配置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14>14</a>
</span><span class=lnt id=hl-11-15><a class=lnlinks href=#hl-11-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>makeUIView</span><span class=p>(</span><span class=n>context</span><span class=p>:</span> <span class=n>Context</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=n>WKWebView</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>config</span> <span class=p>=</span> <span class=n>WKWebViewConfiguration</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>config</span><span class=p>.</span><span class=n>preferences</span><span class=p>.</span><span class=n>javaScriptEnabled</span> <span class=p>=</span> <span class=kc>true</span>  <span class=c1>// React 应用必须启用 JS</span>
</span></span><span class=line><span class=cl>    <span class=n>config</span><span class=p>.</span><span class=n>websiteDataStore</span> <span class=p>=</span> <span class=p>.</span><span class=k>default</span><span class=p>()</span>         <span class=c1>// 持久化存储，保持登录态</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>webView</span> <span class=p>=</span> <span class=n>WKWebView</span><span class=p>(</span><span class=n>frame</span><span class=p>:</span> <span class=p>.</span><span class=n>zero</span><span class=p>,</span> <span class=n>configuration</span><span class=p>:</span> <span class=n>config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>webView</span><span class=p>.</span><span class=n>allowsBackForwardNavigationGestures</span> <span class=p>=</span> <span class=kc>true</span>   <span class=c1>// 支持左右滑动导航</span>
</span></span><span class=line><span class=cl>    <span class=n>webView</span><span class=p>.</span><span class=n>navigationDelegate</span> <span class=p>=</span> <span class=n>context</span><span class=p>.</span><span class=n>coordinator</span>
</span></span><span class=line><span class=cl>    <span class=n>webView</span><span class=p>.</span><span class=n>uiDelegate</span> <span class=p>=</span> <span class=n>context</span><span class=p>.</span><span class=n>coordinator</span>             <span class=c1>// 桥接 JS 弹窗（见 4.4）</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>URL</span><span class=p>(</span><span class=n>string</span><span class=p>:</span> <span class=n>urlString</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>webView</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>URLRequest</span><span class=p>(</span><span class=n>url</span><span class=p>:</span> <span class=n>url</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>webView</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>各配置项的作用：</p><table><thead><tr><th>配置项</th><th>作用</th><th>必要性</th></tr></thead><tbody><tr><td><code>javaScriptEnabled</code></td><td>启用 JS 执行</td><td>必须（React 依赖）</td></tr><tr><td><code>websiteDataStore</code></td><td>持久化 Cookie / LocalStorage</td><td>推荐（保持会话状态）</td></tr><tr><td><code>allowsBackForwardNavigationGestures</code></td><td>左右滑动前进后退</td><td>体验优化</td></tr><tr><td><code>uiDelegate</code></td><td>处理 JS 弹窗</td><td>关键（见下节）</td></tr></tbody></table><h3 id=44-javascript-弹窗桥接>4.4 JavaScript 弹窗桥接<a hidden class=anchor aria-hidden=true href=#44-javascript-弹窗桥接>#</a></h3><p><code>WKWebView</code> 默认静默忽略 JS 弹窗（<code>alert</code>/<code>confirm</code>/<code>prompt</code>）。Kimi Web UI 用 <code>confirm()</code> 做删除确认，忽略后用户点删除按钮毫无反应。</p><p>解法是实现 <code>WKUIDelegate</code> 的三个方法，把 JS 弹窗桥接到原生 <code>UIAlertController</code>。以 <code>confirm()</code> 为例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span><span class=lnt id=hl-12-18><a class=lnlinks href=#hl-12-18>18</a>
</span><span class=lnt id=hl-12-19><a class=lnlinks href=#hl-12-19>19</a>
</span><span class=lnt id=hl-12-20><a class=lnlinks href=#hl-12-20>20</a>
</span><span class=lnt id=hl-12-21><a class=lnlinks href=#hl-12-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>webView</span><span class=p>(</span><span class=kc>_</span> <span class=n>webView</span><span class=p>:</span> <span class=n>WKWebView</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=n>runJavaScriptConfirmPanelWithMessage</span> <span class=n>message</span><span class=p>:</span> <span class=nb>String</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=n>initiatedByFrame</span> <span class=n>frame</span><span class=p>:</span> <span class=n>WKFrameInfo</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=n>completionHandler</span><span class=p>:</span> <span class=p>@</span><span class=n>escaping</span> <span class=p>(</span><span class=nb>Bool</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=nb>Void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 从当前 window scene 获取根视图控制器（兼容多窗口）</span>
</span></span><span class=line><span class=cl>    <span class=k>guard</span> <span class=kd>let</span> <span class=nv>windowScene</span> <span class=p>=</span> <span class=n>UIApplication</span><span class=p>.</span><span class=n>shared</span><span class=p>.</span><span class=n>connectedScenes</span>
</span></span><span class=line><span class=cl>              <span class=p>.</span><span class=bp>first</span><span class=p>(</span><span class=k>where</span><span class=p>:</span> <span class=p>{</span> <span class=nv>$0</span><span class=p>.</span><span class=n>activationState</span> <span class=p>==</span> <span class=p>.</span><span class=n>foregroundActive</span> <span class=p>})</span> <span class=k>as</span><span class=p>?</span> <span class=n>UIWindowScene</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=kd>let</span> <span class=nv>vc</span> <span class=p>=</span> <span class=n>windowScene</span><span class=p>.</span><span class=n>windows</span><span class=p>.</span><span class=bp>first</span><span class=p>?.</span><span class=n>rootViewController</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>completionHandler</span><span class=p>(</span><span class=kc>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>alert</span> <span class=p>=</span> <span class=n>UIAlertController</span><span class=p>(</span><span class=n>title</span><span class=p>:</span> <span class=kc>nil</span><span class=p>,</span> <span class=n>message</span><span class=p>:</span> <span class=n>message</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>preferredStyle</span><span class=p>:</span> <span class=p>.</span><span class=n>alert</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>alert</span><span class=p>.</span><span class=n>addAction</span><span class=p>(</span><span class=n>UIAlertAction</span><span class=p>(</span><span class=n>title</span><span class=p>:</span> <span class=s>&#34;取消&#34;</span><span class=p>,</span> <span class=n>style</span><span class=p>:</span> <span class=p>.</span><span class=n>cancel</span><span class=p>)</span> <span class=p>{</span> <span class=kc>_</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>        <span class=n>completionHandler</span><span class=p>(</span><span class=kc>false</span><span class=p>)</span>   <span class=c1>// 用户点取消 → JS confirm() 返回 false</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=n>alert</span><span class=p>.</span><span class=n>addAction</span><span class=p>(</span><span class=n>UIAlertAction</span><span class=p>(</span><span class=n>title</span><span class=p>:</span> <span class=s>&#34;确定&#34;</span><span class=p>,</span> <span class=n>style</span><span class=p>:</span> <span class=p>.</span><span class=k>default</span><span class=p>)</span> <span class=p>{</span> <span class=kc>_</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>        <span class=n>completionHandler</span><span class=p>(</span><span class=kc>true</span><span class=p>)</span>    <span class=c1>// 用户点确定 → JS confirm() 返回 true</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=n>vc</span><span class=p>.</span><span class=n>present</span><span class=p>(</span><span class=n>alert</span><span class=p>,</span> <span class=n>animated</span><span class=p>:</span> <span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>三个弹窗方法模式相同，区别仅在 <code>completionHandler</code> 的参数类型：<code>alert()</code> 传 <code>Void</code>，<code>confirm()</code> 传 <code>Bool</code>，<code>prompt()</code> 传 <code>String?</code>。</p><blockquote><p>注：早期写法常用 <code>UIApplication.shared.windows.first?.rootViewController</code>，但 <code>windows</code> 属性<a href=https://developer.apple.com/documentation/uikit/uiapplication/windows>已被标记 deprecated</a>。上面的写法通过 <code>UIWindowScene</code> 获取活跃窗口，兼容多 Scene 场景。</p></blockquote><h3 id=45-网络差异处理>4.5 网络差异处理<a hidden class=anchor aria-hidden=true href=#45-网络差异处理>#</a></h3><p>模拟器和真机访问本地服务的网络路径不同：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span><span class=lnt id=hl-13-16><a class=lnlinks href=#hl-13-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>模拟器：                        真机：
</span></span><span class=line><span class=cl>┌────────────┐                ┌────────────┐
</span></span><span class=line><span class=cl>│ Simulator  │                │  iPhone    │
</span></span><span class=line><span class=cl>│ 127.0.0.1  │                │ 127.0.0.1  │
</span></span><span class=line><span class=cl>└─────┬──────┘                └─────┬──────┘
</span></span><span class=line><span class=cl>      │ 共享网络栈                    │ 指向自己
</span></span><span class=line><span class=cl>      ↓                             ↓
</span></span><span class=line><span class=cl>┌────────────┐                ┌────────────┐
</span></span><span class=line><span class=cl>│ Mac 本机   │                │  路由器    │
</span></span><span class=line><span class=cl>│ :5494      │                │            │
</span></span><span class=line><span class=cl>└────────────┘                └─────┬──────┘
</span></span><span class=line><span class=cl>                                    ↓
</span></span><span class=line><span class=cl>kimi web                      ┌────────────┐
</span></span><span class=line><span class=cl>                              │ Mac :5494  │
</span></span><span class=line><span class=cl>                              └────────────┘
</span></span><span class=line><span class=cl>                              kimi web --network
</span></span></code></pre></td></tr></table></div></div><p>模拟器与 Mac 共享网络栈，<code>127.0.0.1</code> 指向 Mac 本机，直接用 <code>kimi web</code> 就能访问。真机是独立设备，<code>127.0.0.1</code> 指向自己，必须用 <code>kimi web --network</code> 绑定 <code>0.0.0.0</code>，然后用 Mac 的局域网 IP 访问。</p><p>App 中设计了地址切换功能，提供预设地址列表（<code>127.0.0.1</code> + 常见局域网网段），用户可以快速切换或手动输入。</p><h3 id=46-安全模型与部署建议>4.6 安全模型与部署建议<a hidden class=anchor aria-hidden=true href=#46-安全模型与部署建议>#</a></h3><p>用 <code>--network</code> 暴露 Web 服务到局域网时，需要考虑安全边界。Kimi CLI 的 Agent 具备文件读写、命令执行、工具调用等能力，如果控制面暴露给同网段的其他人，后果不可控。</p><p>Kimi CLI 从 v1.6（2026-02-03）起引入了基于 Token 的认证和访问控制：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>--auth-token &lt;token></code></td><td>启用 Token 认证，客户端需携带 Token 才能访问</td></tr><tr><td><code>--lan-only</code></td><td>仅允许局域网访问（拒绝公网流量）</td></tr><tr><td><code>--allowed-origins &lt;origins></code></td><td>限制允许的请求来源（CORS 白名单）</td></tr><tr><td><code>--restrict-sensitive-apis</code></td><td>限制敏感 API（文件操作、命令执行等）</td></tr></tbody></table><p>一条原则：<strong>远程访问默认最小权限</strong>。Agent 能读写文件、跑命令、调用工具，暴露控制面等于把 Mac 的操作权交出去。<code>--restrict-sensitive-apis</code> 会禁掉文件写入、命令执行等高危 API，<code>--network</code> 场景下建议始终开启，只在明确需要时关闭。</p><p>推荐的部署姿势：</p><ul><li><strong>仅本机调试</strong>：默认 <code>kimi web</code>，服务只绑定 <code>127.0.0.1</code>，不出本机</li><li><strong>局域网真机</strong>：<code>kimi web --network --auth-token &lt;强随机token> --lan-only --restrict-sensitive-apis</code></li><li><strong>不要在不可信网络暴露服务</strong>，即使加了 Token，当前方案走的是 HTTP 明文，同网段可被嗅探</li></ul><p>详见 <a href=https://moonshotai.github.io/kimi-cli/zh/release-notes/changelog.html>Kimi CLI 变更记录</a> 中 v1.6 的安全更新。</p><hr><h2 id=5-踩坑速查>5. 踩坑速查<a hidden class=anchor aria-hidden=true href=#5-踩坑速查>#</a></h2><table><thead><tr><th>现象</th><th>根因</th><th>解法</th></tr></thead><tbody><tr><td>模拟器正常，真机白屏</td><td>真机是独立设备，<code>127.0.0.1</code> 指向自己</td><td><code>kimi web --network</code> + Mac 局域网 IP</td></tr><tr><td>删除会话等操作无反应</td><td><code>WKWebView</code> 默认静默忽略 JS 弹窗</td><td>实现 <code>WKUIDelegate</code> 三个方法桥接弹窗</td></tr><tr><td><code>lsof | grep kimi</code> 查不到端口</td><td>Kimi CLI 是 Python 程序，进程名是 <code>python</code></td><td><code>lsof -i -P | grep python | grep LISTEN</code>，默认 5494，占用时顺延至 5503</td></tr><tr><td>真机弹「是否允许访问本地网络」后被拒绝</td><td>缺少 <code>NSLocalNetworkUsageDescription</code></td><td>在 <code>Info.plist</code> 中添加本地网络用途说明（见 4.2）</td></tr><tr><td>弹窗代码编译有 deprecation 警告</td><td><code>UIApplication.shared.windows</code> 已废弃</td><td>改用 <code>UIWindowScene</code> 获取活跃窗口（见 4.4）</td></tr></tbody></table><hr><h2 id=6-小结>6. 小结<a hidden class=anchor aria-hidden=true href=#6-小结>#</a></h2><h3 id=61-核心要点回顾>6.1 核心要点回顾<a hidden class=anchor aria-hidden=true href=#61-核心要点回顾>#</a></h3><p>回到开篇的场景：在咖啡馆能用手机操控 Kimi CLI 吗？可以，实现成本远低于预期。</p><ol><li><strong>架构</strong>：Kimi Web UI 三层设计（React 前端 + FastAPI 后端 + Agent 内核）通过 Wire 协议解耦 UI 与 Agent，Web UI 只是 Agent 内核的一种「壳」。</li><li><strong>代码机制</strong>：<code>useSessionStream</code> 用 <code>wsRef</code> 守卫解决多连接竞态，用 Ref 累积流式状态避免高频渲染，<code>processEvent</code> 路由十几种 Wire 事件。</li><li><strong>封装三要素</strong>：<code>WKWebView</code> 封装需要处理 HTTP 权限（ATS 配置）、JS 弹窗桥接（<code>WKUIDelegate</code>）、网络差异（模拟器 vs 真机）三个关键问题。</li><li><strong>方法论</strong>：面对不确定目标，拆成可验证的小步骤（找进程 → iOS 入门 → WebView 封装），每步只回答一个问题，失败代价控制在半天以内。</li></ol><h3 id=62-架构局限与演进方向>6.2 架构局限与演进方向<a hidden class=anchor aria-hidden=true href=#62-架构局限与演进方向>#</a></h3><p>当前方案有几个值得正视的限制：</p><p><strong>网络边界</strong>：手机和 Mac 必须在同一局域网。离开咖啡馆的 Wi-Fi，连接就断了。跨网访问有几条路：VPN 组网（Tailscale、WireGuard 等把两台设备拉到同一虚拟私网，加密且不暴露公网端口，个人自用推荐）、反向隧道（Cloudflare Tunnel、ngrok，省事但引入第三方中转）、公网部署 + 域名 + TLS（工程最完整，但你得把它当一个互联网服务来做安全）。注意 VPN + WebSocket 偶尔有兼容问题（某些组网工具会出现 WebSocket 403），真跑之前需要验收。</p><p><strong>传输安全</strong>：当前方案走 HTTP/WS 明文，局域网内可被同网段设备嗅探。个人开发场景风险可控，但如果 Agent 处理敏感代码或执行高权限操作，应当升级到 HTTPS/WSS。最直接的做法是在 Kimi Web 前面加一个反向代理（Caddy、nginx）做 TLS 终止，本地证书用 mkcert 生成即可。</p><p><strong>连接稳定性</strong>：WebSocket 长连接在移动端有天然脆弱性。手机切后台时 iOS 会挂起网络，回前台后连接已断。生产可用需要至少两件事：断线重连策略（指数退避 + 恢复到正确 session），以及回前台时的状态检测和自动恢复。如果需要离线可读，可以在本地缓存历史消息，形成 WebSocket（实时）+ HTTP（补偿）+ 本地缓存（离线）的三层架构。</p><p><strong>通信模型</strong>：Kimi Web UI 的通信是 WebSocket 全双工，不是传统的 HTTP 请求-响应。这其实是正确的选择。Agent 的输出是持续的流式推送（每秒几十个 <code>ContentPart</code> 事件），HTTP 轮询在这个场景下延迟高、开销大。WebSocket 保持一条长连接，服务端可以随时推送，客户端也能随时发送取消或审批，双向实时。</p><p><strong>服务端运维</strong>：Demo 阶段手动跑 <code>kimi web</code> 没问题，长期使用需要考虑：开机自启（launchd plist 或 systemd service）、日志（至少记录访问和认证失败）、Token 轮换策略（定期更换 <code>--auth-token</code>）。</p><p><strong>可复用的工程模式</strong>：「本地 Web 服务 + WebView」适用于任何提供 Web 界面的 CLI 工具。后端有 HTTP 接口就能跨平台复用，代价是性能和体验不如原生。对于 AI Agent 这种交互密度不高的场景，WebView 够用。当交互复杂度上升（比如需要原生手势、离线缓存、推送通知），就需要考虑原生 UI + Wire 协议直连的方案了。</p><h3 id=63-快速开始>6.3 快速开始<a hidden class=anchor aria-hidden=true href=#63-快速开始>#</a></h3><p><strong>前置条件</strong>：</p><ul><li>Kimi CLI >= v1.4（推荐 >= v1.6，支持 Token 认证）</li><li>Xcode >= 15.0，iOS >= 16.0</li><li>Mac 和 iPhone 在同一 Wi-Fi 网络下</li></ul><p><strong>30 分钟部署清单</strong>：</p><ol><li>启动服务：<code>kimi web --network --auth-token mytoken --lan-only --restrict-sensitive-apis</code></li><li>获取 Mac 局域网 IP：<code>ipconfig getifaddr en0</code></li><li>用 Xcode 新建 iOS 项目，将本文第 4、5 节的代码添加进去</li><li>在 <code>ContentView.swift</code> 中修改 <code>serverAddress</code> 为 <code>http://&lt;Mac-IP>:5494</code></li><li>连接 iPhone，在 Xcode 中选择真机目标，点击 Run</li></ol><p><strong>命令速查表</strong>：</p><table><thead><tr><th>场景</th><th>命令</th></tr></thead><tbody><tr><td>默认启动（仅本机）</td><td><code>kimi web</code></td></tr><tr><td>局域网 + 认证 + 最小权限</td><td><code>kimi web --network --auth-token &lt;token> --lan-only --restrict-sensitive-apis</code></td></tr><tr><td>指定端口</td><td><code>kimi web --port 8080</code></td></tr><tr><td>获取 Mac IP</td><td><code>ipconfig getifaddr en0</code></td></tr><tr><td>查找 Kimi Web 端口</td><td><code>lsof -i -P | grep python | grep LISTEN</code></td></tr></tbody></table><p><strong>进阶资源</strong>：</p><ul><li><a href=https://moonshotai.github.io/kimi-cli/zh/customization/wire-mode.html>Kimi CLI Wire 模式文档</a>：协议细节和扩展开发</li><li><a href=https://moonshotai.github.io/kimi-cli/zh/release-notes/changelog.html>Kimi CLI 变更记录</a>：各版本安全功能演进</li><li><a href=https://developer.apple.com/documentation/webkit/wkwebview>Apple WKWebView 文档</a>：API 参考和最佳实践</li><li><a href=https://developer.apple.com/documentation/security/preventing-insecure-network-connections>Apple: Preventing Insecure Network Connections</a>：ATS 配置最佳实践</li></ul><hr><p>回头看，这个项目的大部分时间花在理解系统边界上，真正动手写代码反而很快。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://miss-you.github.io/tags/kimi-cli/>Kimi CLI</a></li><li><a href=https://miss-you.github.io/tags/swift/>Swift</a></li><li><a href=https://miss-you.github.io/tags/ios/>IOS</a></li><li><a href=https://miss-you.github.io/tags/webview/>WebView</a></li><li><a href=https://miss-you.github.io/tags/ai-%E5%B7%A5%E5%85%B7/>AI 工具</a></li></ul><nav class=paginav><a class=prev href=https://miss-you.github.io/posts/20260217-websocket-to-four-components/><span class=title>« 上一页</span><br><span>从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化</span>
</a><a class=next href=https://miss-you.github.io/posts/20260214-choose-leader-signal-vs-system/><span class=title>下一页 »</span><br><span>选工作，你在看朋友圈还是体检报告？</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台 on x" href="https://x.com/intent/tweet/?text=%e7%94%a8%20300%20%e8%a1%8c%20Swift%20%e8%ae%a9%20iPhone%20%e5%8f%98%e6%88%90%20Kimi%20CLI%20%e6%8e%a7%e5%88%b6%e5%8f%b0&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260216-swift-kimi-cli-console%2f&amp;hashtags=KimiCLI%2cSwift%2ciOS%2cWebView%2cAI%e5%b7%a5%e5%85%b7"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260216-swift-kimi-cli-console%2f&amp;title=%e7%94%a8%20300%20%e8%a1%8c%20Swift%20%e8%ae%a9%20iPhone%20%e5%8f%98%e6%88%90%20Kimi%20CLI%20%e6%8e%a7%e5%88%b6%e5%8f%b0&amp;summary=%e7%94%a8%20300%20%e8%a1%8c%20Swift%20%e8%ae%a9%20iPhone%20%e5%8f%98%e6%88%90%20Kimi%20CLI%20%e6%8e%a7%e5%88%b6%e5%8f%b0&amp;source=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260216-swift-kimi-cli-console%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260216-swift-kimi-cli-console%2f&title=%e7%94%a8%20300%20%e8%a1%8c%20Swift%20%e8%ae%a9%20iPhone%20%e5%8f%98%e6%88%90%20Kimi%20CLI%20%e6%8e%a7%e5%88%b6%e5%8f%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260216-swift-kimi-cli-console%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台 on whatsapp" href="https://api.whatsapp.com/send?text=%e7%94%a8%20300%20%e8%a1%8c%20Swift%20%e8%ae%a9%20iPhone%20%e5%8f%98%e6%88%90%20Kimi%20CLI%20%e6%8e%a7%e5%88%b6%e5%8f%b0%20-%20https%3a%2f%2fmiss-you.github.io%2fposts%2f20260216-swift-kimi-cli-console%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台 on telegram" href="https://telegram.me/share/url?text=%e7%94%a8%20300%20%e8%a1%8c%20Swift%20%e8%ae%a9%20iPhone%20%e5%8f%98%e6%88%90%20Kimi%20CLI%20%e6%8e%a7%e5%88%b6%e5%8f%b0&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260216-swift-kimi-cli-console%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e7%94%a8%20300%20%e8%a1%8c%20Swift%20%e8%ae%a9%20iPhone%20%e5%8f%98%e6%88%90%20Kimi%20CLI%20%e6%8e%a7%e5%88%b6%e5%8f%b0&u=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260216-swift-kimi-cli-console%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://miss-you.github.io/>Yousa Driven Development | YDD</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  
  
  const isDarkMode = () => {
    return document.body.classList.contains('dark');
  };
  
  
  const mermaidKeywords = [
    'graph ', 'graph TB', 'graph TD', 'graph LR', 'graph RL', 'graph BT',
    'flowchart ', 'flowchart TB', 'flowchart TD', 'flowchart LR', 'flowchart RL', 'flowchart BT',
    'sequenceDiagram', 'classDiagram', 'stateDiagram', 'stateDiagram-v2',
    'erDiagram', 'journey', 'gantt', 'pie', 'requirementDiagram',
    'gitGraph', 'mindmap', 'timeline', 'sankey'
  ];
  
  const isMermaidCode = (code) => {
    const trimmed = code.trim();
    return mermaidKeywords.some(keyword => trimmed.startsWith(keyword));
  };
  
  
  const getColors = () => {
    if (isDarkMode()) {
      return {
        
        bg: '#1d1e20',
        surface: '#2d2e30',
        border: '#444',
        text: '#dadaeb',
        secondary: '#9c9d9e',
        line: '#9c9d9e',
        
        accent1: '#5a7a96',  
        accent2: '#6b8e6b',  
        accent3: '#b8a87c',  
      };
    }
    
    return {
      bg: '#f4f3ee',        
      surface: '#faf9f5',   
      border: '#2c2c2c',    
      text: '#1f1f1f',      
      secondary: '#6c6c6c', 
      line: '#4a4a4a',      
      
      accent1: '#8fb8d4',   
      accent2: '#a8c6a8',   
      accent3: '#d4c59a',   
    };
  };
  
  const initMermaid = () => {
    const c = getColors();
    
    mermaid.initialize({
      startOnLoad: false,
      theme: 'base',
      themeVariables: {
        
        fontFamily: '"Noto Serif SC", Georgia, serif',
        fontSize: '16px',           
        
        
        background: c.bg,
        mainBkg: c.surface,
        
        
        primaryColor: c.surface,
        primaryTextColor: c.text,
        primaryBorderColor: c.border,
        
        
        secondaryColor: c.accent1,
        tertiaryColor: c.accent2,
        
        
        lineColor: c.line,
        nodeBorder: c.border,
        clusterBkg: c.bg,
        clusterBorder: c.border,
        
        
        textColor: c.text,
        titleColor: c.text,
        nodeTextColor: c.text,
        labelColor: c.text,
        
        
        edgeLabelBackground: c.bg,
        
        
        actorBorder: c.border,
        actorBkg: c.surface,
        actorTextColor: c.text,
        actorLineColor: c.border,
        signalColor: c.line,
        signalTextColor: c.text,
        
        
        stateBorder: c.border,
        stateBkg: c.surface,
        
        
        cScale0: c.surface,
        cScale1: c.accent1,
        cScale2: c.accent2,
        cScale3: c.accent3,
        cScale4: c.surface,
        cScale5: c.accent1,
      },
      
      
      flowchart: {
        useMaxWidth: true,
        htmlLabels: true,
        curve: 'basis',
        padding: 20,
        nodeSpacing: 50,
        rankSpacing: 60,
      },
      
      
      sequence: {
        useMaxWidth: true,
        diagramMarginX: 50,
        diagramMarginY: 20,
        actorMargin: 60,
        width: 160,
        height: 70,
        boxMargin: 15,
        boxTextMargin: 8,
        noteMargin: 15,
        messageMargin: 40,
        mirrorActors: true,
        bottomMarginAdj: 1,
        rightAngles: false,
        showSequenceNumbers: false,
        
        actorFontSize: '16px',
        noteFontSize: '15px',
        messageFontSize: '15px',
      },
      
      
      state: {
        useMaxWidth: true,
        padding: 15,
        fontSize: '16px',
      },
      
      
      class: {
        useMaxWidth: true,
        fontSize: '15px',
      },
      
      
      er: {
        useMaxWidth: true,
        fontSize: '15px',
      },
      
      
      gantt: {
        useMaxWidth: true,
        fontSize: '14px',
      },
      
      
      look: 'handDrawn',
    });
  };
  
  const renderMermaidDiagrams = async () => {
    const allCodeBlocks = document.querySelectorAll('pre code');
    const mermaidBlocks = [];
    
    allCodeBlocks.forEach(block => {
      const code = block.textContent;
      if (isMermaidCode(code)) {
        mermaidBlocks.push(block);
      }
    });
    
    if (mermaidBlocks.length === 0) return;
    
    initMermaid();
    const c = getColors();
    
    for (const block of mermaidBlocks) {
      const pre = block.parentElement;
      const code = block.textContent.trim();
      
      
      const wrapper = document.createElement('div');
      wrapper.className = 'mermaid-diagram';
      wrapper.style.cssText = `
        margin: 2em 0;
        padding: 24px;
        background: ${c.bg};
        border: 1px solid ${c.border}30;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        overflow-x: auto;
      `;
      
      
      const container = document.createElement('div');
      container.style.cssText = `
        display: flex;
        justify-content: center;
        min-width: fit-content;
      `;
      
      const mermaidDiv = document.createElement('div');
      mermaidDiv.className = 'mermaid';
      mermaidDiv.textContent = code;
      container.appendChild(mermaidDiv);
      wrapper.appendChild(container);
      
      pre.parentNode.replaceChild(wrapper, pre);
      
      try {
        await mermaid.run({ querySelector: '.mermaid' });
      } catch (error) {
        console.error('Mermaid error:', error);
      }
    }
  };
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', renderMermaidDiagrams);
  } else {
    renderMermaidDiagrams();
  }
  
  
  let timeout;
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === 'class') {
        clearTimeout(timeout);
        timeout = setTimeout(() => location.reload(), 300);
      }
    });
  });
  observer.observe(document.body, { attributes: true });
</script><style>.mermaid-diagram{font-family:noto serif sc,Georgia,serif}.mermaid-diagram .mermaid{display:flex;justify-content:center}.mermaid-diagram svg{max-width:100% !important;height:auto !important;font-family:noto serif sc,Georgia,serif !important}.mermaid-diagram svg text,.mermaid-diagram svg .label,.mermaid-diagram svg .nodeLabel,.mermaid-diagram svg .edgeLabel,.mermaid-diagram svg .messageText,.mermaid-diagram svg .actor text,.mermaid-diagram svg .participant text{fill:#1f1f1f !important;font-family:noto serif sc,Georgia,serif !important;font-size:15px !important;font-weight:500 !important}.dark .mermaid-diagram svg text,.dark .mermaid-diagram svg .label,.dark .mermaid-diagram svg .nodeLabel,.dark .mermaid-diagram svg .edgeLabel,.dark .mermaid-diagram svg .messageText,.dark .mermaid-diagram svg .actor text,.dark .mermaid-diagram svg .participant text{fill:#dadaeb !important}.mermaid-diagram svg .sequenceDiagram text{font-size:16px !important}.mermaid-diagram svg .actor{font-size:16px !important}.mermaid-diagram svg .messageText{font-size:15px !important}.mermaid-diagram svg .node rect,.mermaid-diagram svg .node circle,.mermaid-diagram svg .node ellipse,.mermaid-diagram svg .node polygon{stroke-width:2px !important}.mermaid-diagram svg{filter:drop-shadow(0 1px 3px rgba(0,0,0,8%))}.dark .mermaid-diagram{background:#1d1e20 !important;border-color:#444 !important;box-shadow:0 2px 8px rgba(0,0,0,.2) !important}@media(max-width:768px){.mermaid-diagram{padding:16px !important;margin:1.5em 0 !important}.mermaid-diagram svg text{font-size:14px !important}}.mermaid-diagram{opacity:0;animation:fadeIn .4s ease-out forwards}@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}</style><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>