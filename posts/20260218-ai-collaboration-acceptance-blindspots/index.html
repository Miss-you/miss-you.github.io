<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获 | Yousa Driven Development | YDD</title><meta name=keywords content="AI,Prompt Engineering,软件工程,测试,代码审查,Rust,TypeScript"><meta name=description content="169 个测试全过，功能却完全失效。本文解剖一个真实任务的四层验收漏斗，揭示多层架构中横向传播遗漏的本质问题——以及不同 Prompt 策略如何决定验收效率。"><meta name=author content="Miss-you"><link rel=canonical href=https://miss-you.github.io/posts/20260218-ai-collaboration-acceptance-blindspots/><link crossorigin=anonymous href=/assets/css/stylesheet.90ccfe940c2ebacfe29cf6c094281c8c148bd718511cde00be68d330109118be.css integrity="sha256-kMz+lAwuus/inPbAlCgcjBSL1xhRHN4AvmjTMBCRGL4=" rel="preload stylesheet" as=style><link rel=icon href=https://miss-you.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://miss-you.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://miss-you.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://miss-you.github.io/apple-touch-icon.png><link rel=mask-icon href=https://miss-you.github.io/safari-pinned-tab.svg><meta name=theme-color content="#f4f3ee"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://miss-you.github.io/posts/20260218-ai-collaboration-acceptance-blindspots/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Noto+Serif+SC:wght@400;600;700;900&family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel=stylesheet><meta property="og:url" content="https://miss-you.github.io/posts/20260218-ai-collaboration-acceptance-blindspots/"><meta property="og:site_name" content="Yousa Driven Development | YDD"><meta property="og:title" content="AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获"><meta property="og:description" content="169 个测试全过，功能却完全失效。本文解剖一个真实任务的四层验收漏斗，揭示多层架构中横向传播遗漏的本质问题——以及不同 Prompt 策略如何决定验收效率。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-18T13:12:00+08:00"><meta property="article:modified_time" content="2026-02-18T13:13:59+08:00"><meta property="article:tag" content="AI"><meta property="article:tag" content="Prompt Engineering"><meta property="article:tag" content="软件工程"><meta property="article:tag" content="测试"><meta property="article:tag" content="代码审查"><meta property="article:tag" content="Rust"><meta name=twitter:card content="summary"><meta name=twitter:title content="AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获"><meta name=twitter:description content="169 个测试全过，功能却完全失效。本文解剖一个真实任务的四层验收漏斗，揭示多层架构中横向传播遗漏的本质问题——以及不同 Prompt 策略如何决定验收效率。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://miss-you.github.io/posts/"},{"@type":"ListItem","position":2,"name":"AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获","item":"https://miss-you.github.io/posts/20260218-ai-collaboration-acceptance-blindspots/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获","name":"AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获","description":"169 个测试全过，功能却完全失效。本文解剖一个真实任务的四层验收漏斗，揭示多层架构中横向传播遗漏的本质问题——以及不同 Prompt 策略如何决定验收效率。","keywords":["AI","Prompt Engineering","软件工程","测试","代码审查","Rust","TypeScript"],"articleBody":"AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获 TypeScript 编译零错误，clippy 零 warning，CLI 返回正确数据。AI 报告「代码完成」。\nsubmit 功能完全失效。前端校验会拒绝包含新数据源的提交请求。文档有多处与代码不一致的描述。这些问题在首轮验收中全部隐形（不是被忽略，而是现有验证手段从结构上无法触及）。\n测试全绿证明不了质量，只证明了测试覆盖了多少。在多层架构中，纵向测试验证的是「这段代码做了什么」，而非「这段代码应该做什么但没做」。一个新增的枚举值需要在 26 个触点完成注册，其中只有约 8 个的缺失会触发编译错误。剩余 18 个触点即使全部遗漏，编译照过，测试照绿，功能链路静默断裂在中间层。遗漏是一种 absence——在缺乏穷尽匹配约束的代码层中，absence 不报错。\n这不是理论推演。本文解剖的是一个真实任务：为 Tokscale 添加第 10 个 AI 数据源（Kimi），涉及 28 个文件修改、约 300 行新增 Rust 代码、横跨 6 个架构层（Core → Pricing → CLI → TUI → Frontend → Docs）。AI 首轮交付后，第一轮验收发现 0 个问题，第二轮发现 12 处遗漏，第三轮仍追出 3 处。每一轮使用不同的验证方法，每一层专门捕获前一层的盲区。\n但这篇文章不仅仅是方法论的分类账。本文同时复盘了每一轮验收背后的 Prompt——人类如何向 AI 提问，直接决定了 AI 能暴露多少自身的盲区。同一个 AI，面对不同的提问方式，交出的答案质量天差地别。四轮验收的差异，很大程度上源于 Prompt 策略的差异（第三层除外——那一层更多依赖人工逐段追踪而非 Prompt 引导）。\n多层架构中的「枚举值传播」问题 Tokscale 的架构分为 6 层，从底层的 Rust Core 解析器一直延伸到最上层的文档：\n1 2 3 4 5 6 7 8 9 10 11 Layer 1: Rust Core Parser (kimi.rs) ↓ UnifiedMessage Layer 2: Rust Scanner + Pipeline (scanner.rs, lib.rs) ↓ ParsedMessages { kimiCount } Layer 3: TypeScript CLI (graph-types.ts, native.ts, cli.ts, submit.ts) ↓ SourceType = \"kimi\" Layer 4: TUI Display (types, colors, Footer, useData, App) ↓ badge, hotkey, color Layer 5: Frontend (types.ts, validation/submission.ts, constants.ts, SourceLogo.tsx) ↓ Zod schema, display config Layer 6: Documentation (README × 4) 每新增一个数据源，这 6 层中总共有 26 个触点需要添加对应的逻辑。以 scanner.rs 中的 ScanResult 为例，这个结构体为每个数据源各保留了一个文件列表字段：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #[derive(Debug, Default)] pub struct ScanResult { pub opencode_files: Vec\u003cPathBuf\u003e, pub opencode_db: Option\u003cPathBuf\u003e, pub claude_files: Vec\u003cPathBuf\u003e, pub codex_files: Vec\u003cPathBuf\u003e, pub gemini_files: Vec\u003cPathBuf\u003e, pub cursor_files: Vec\u003cPathBuf\u003e, pub amp_files: Vec\u003cPathBuf\u003e, pub droid_files: Vec\u003cPathBuf\u003e, pub openclaw_files: Vec\u003cPathBuf\u003e, pub pi_files: Vec\u003cPathBuf\u003e, pub kimi_files: Vec\u003cPathBuf\u003e, // ← 第 10 个数据源 } 这种模式意味着 kimi_files 必须出现在 ScanResult 的定义、total_files() 的求和、all_files() 的遍历、scan_all_sources() 的扫描和聚合等多处。仅 scanner.rs 一个文件就占 5 个触点。\n26 个触点中，只有约 8 个遗漏会导致编译失败——比如 ScanResult 新增字段后有代码引用它（缺失则编译失败）、SessionType 缺枚举值（在没有通配符的 match 中报 non-exhaustive）、ParsedMessages 缺计数字段。这些错误编译器直接拦截。但剩下的约 18 个触点，遗漏后编译通过、测试通过，功能却不完整。比如 submit.ts 的 hasFilter 逻辑不检查 options.kimi，结果是 --kimi 参数定义了但提交时不生效；又比如前端的 z.enum 不包含 \"kimi\"，结果是包含 Kimi 数据的提交会被校验拒绝。\nAI 在首轮实现中完成了约 14 个触点——Rust Core 全部正确，CLI 大部分到位——遗漏了 12 个。自动化测试一处遗漏也没检出。\n实现 Prompt 复盘：计划的覆盖范围 ≠ 实现的覆盖范围 在分析验收手段之前，先看源头：我们给 AI 的实现指令是什么，AI 交付了什么，差距出现在哪里。\n实现阶段的核心 Prompt 是一条探索性指令，附带了详细的技术方案：\n1 2 实现以下计划：为 Tokscale 添加 Kimi CLI 支持 [附带详细的技术方案、任务清单、验收标准] 这条 Prompt 的设计意图是充分的：它包含了 Rust Core 和 TypeScript CLI 两端的完整修改范围，列出了 6 层架构的触点清单，甚至附带了可执行的验收标准。从计划文档的角度看，覆盖范围是完整的。\n但计划的覆盖范围和实现的覆盖范围是两回事。\nAI 的实际交付呈现出一个清晰的模式：Rust Core 层的 8 个触点全部正确完成——kimi.rs 解析器、scanner.rs 扫描逻辑、lib.rs 管线集成、aliases.rs 定价映射，无一遗漏。而 TypeScript/Frontend/Docs 层的约 18 个触点中，只完成了 6 个，遗漏了 12 个。\n这个分布不是随机的。Rust 端有编译器充当「隐形验收官」：在本项目中，ScanResult 的字段被其他代码引用，缺一个就编译不过；SessionType 的 match 没有使用通配符分支，少一个枚举值就报 non-exhaustive pattern。编译器迫使 AI 在实现阶段就把这些触点补齐。而 TypeScript 端的可选类型（kimi?: boolean）和运行时校验（z.enum）不会在编译期发出任何信号——遗漏了也能通过，于是 AI 就停在了「编译通过」的节点上。\n这揭示了探索性 Prompt 的一个结构性局限：它给 AI 提供了「做什么」的清单，但 AI 的完成判定依赖于环境反馈。在有强类型约束的 Rust 端，环境反馈是即时且强制的——编译失败就必须修；在弱约束的 TypeScript/Frontend 端，环境反馈是静默的——编译通过就以为完成了。同一条 Prompt，在不同语言层产生了截然不同的完成度，差异不在指令本身，而在目标语言的类型系统对遗漏的容忍度。\n在本案例中，AI 的实现深度更多跟着编译器走，而不是跟着计划走。计划说「修改 28 个文件」，编译器只强制其中 8 个，AI 做到了 8 + 6 = 14 个——6 个 TypeScript 触点靠 AI 自身的上下文理解完成，没有编译器兜底，这说明 AI 并非完全依赖编译器反馈。但编译器反馈的有无，仍然是 Rust 端 100% 完成 vs TypeScript 端大量遗漏的最显著区别因素。剩余 12 个触点需要人类的验收手段来发现。\n第一层：自动化测试的天花板 AI 完成首轮实现后，执行了完整的自动化验证流程，6 项检查全部通过：\n1 2 3 4 5 6 7 8 $ cargo build ✅ 无 error $ cargo test ✅ 169 passed, 0 failed $ cargo clippy ✅ 0 new warning $ bun run build:cli ✅ TypeScript 编译通过 $ bun run cli -- sources ✅ 显示 Kimi CLI（674 messages） $ bun run cli -- models --kimi --json ✅ 返回正确数据 这 6 项检查为什么没有发现 12 处遗漏？\n原因在于编译器和测试框架检查的是纵向的类型一致性，而非横向的传播完整性。cargo build 能检测到 ScanResult 缺 kimi_files 字段（其他代码会引用它，不存在则编译失败）。但 cargo build 无法检测到 submit.ts 里的 hasFilter（过滤条件变量）是否包含了 options.kimi 这一项——因为 kimi 在 SubmitOptions 中的类型是可选的：\n1 2 3 4 5 6 7 8 interface SubmitOptions { opencode?: boolean; claude?: boolean; codex?: boolean; // ... 省略其他 source kimi?: boolean; // ← 可选参数，不传 = undefined since?: string; } 当 cli.ts 调用 submit({...}) 时没有传递 kimi: options.kimi，TypeScript 不会报错。kimi 本来就是可选的，不传等于 undefined，走到 hasFilter 时不触发，结果进入默认路径。功能表现为「--kimi 参数存在但没有任何效果」，不会有任何运行时错误。\n前端的情况类似。Zod schema 中的 z.enum 是运行时校验，只在提交包含 source: \"kimi\" 的数据时才触发校验失败。不提交就不会发现 enum 少了一项。而我们的测试流程只验证了读取路径（models --kimi --json），没有走到提交路径。\n1 2 3 4 // source 字段的合法值全部硬编码在此——列表残缺即校验失败 source: z.enum([\"opencode\", \"claude\", \"codex\", \"gemini\", \"cursor\", \"amp\", \"droid\", \"openclaw\", \"pi\"]), // ↑ 缺少 \"kimi\"，测试只走读取路径，从未触发这条校验 SOP 自检 Prompt 的失效 在自动化测试全绿之后，验收的第一个直觉是让 AI 自我检查。使用的 Prompt 是：\n1 2 3 1. 代码完成了吗？ 2. 你列的验收列表这里，完成情况如何，包括存量用例运行，以及新增的单元测试等等 3. 现在还有哪些没完成呢？请你检查下 这是一种「元认知」策略——要求 AI 先生成自己的验收清单，再对着清单逐项核对。AI 随后启动了两个并行 Subagent 做全量验证：一个跑 cargo test（169 passed）+ cargo clippy（零新 warning），另一个执行 6 条 CLI 集成测试命令。\n结果：发现 0 个结构性遗漏。\n这个 Prompt 为什么失效？因为它让 AI 用自己的心智模型来审计自己的产出。AI 的自检 SOP 和它的实现逻辑共享同一个盲区——两者都沿纵向路径检查（代码能编译吗？测试能跑通吗？CLI 能返回数据吗？），而不会沿横向路径检查（\"kimi\" 是否出现在所有 26 个触点？）。让同一个 AI 既写代码又写验收清单，等价于让考生在没有标准答案的情况下批改自己的试卷——它不是不会，而是无从判断自己遗漏了什么。用工程术语说，这是一种「共模失效」（common-mode failure）：审计者和被审计者共享同一套假设，AI 在 Review 时的检查范围和它在编码时的认知范围高度重叠。但这不是 AI 能力的上限——后文会证明，换一种 Prompt（基准对比），同一个 AI 就能发现全部 12 处遗漏。问题不在 AI「看不到」，而在于没有外部参照物时，它不知道该往哪里看。\n这两类遗漏——可选参数默默缺席、运行时校验从未触发——需要完全不同的检测手段。自动化测试和 AI 自检都无法触及它们，因为两者的检测原理都是纵向的：验证已有代码的行为，而非审计应有代码的存在。\n第二层：基准对比法——以 Codex 为镜 核心思路是：既然 Codex 已完整实现，那么 Codex 出现的每个位置，Kimi 也应该出现。在全代码库搜索 \"codex\" 的所有出现位置：\n1 2 # Rust 侧由编译器保证，遗漏集中在 TypeScript/Frontend 层 $ grep -rn '\"codex\"' packages/cli/src/ packages/frontend/src/ 结果：一次性暴露 12 处遗漏。以 validation/submission.ts 为例，修复前后的对比：\n1 2 3 4 5 6 7 8 9 10 11 // 修复前——z.enum 缺少 \"kimi\" source: z.enum([ \"opencode\", \"claude\", \"codex\", \"gemini\", \"cursor\", \"amp\", \"droid\", \"openclaw\", \"pi\" ]), // 修复后 source: z.enum([ \"opencode\", \"claude\", \"codex\", \"gemini\", \"cursor\", \"amp\", \"droid\", \"openclaw\", \"pi\", \"kimi\" // ← 修复点 ]), 这个文件中有两处 z.enum——SourceContributionSchema 和 DataSummarySchema——两处都遗漏了 \"kimi\"。如果用户提交包含 Kimi 数据的使用报告，Zod 校验会在 source 字段处失败，请求被拦截或服务端返回 400。\nsubmit.ts 中有 4 处遗漏（类型定义、过滤逻辑、数组填充），其余分布在前端的 types.ts、constants.ts、SourceLogo.tsx 和 README。\n基准对比 Prompt 的设计逻辑 触发这一轮发现的 Prompt 是一条结构化的基准比对指令：\n1 2 3 4 5 6 7 8 9 以 Codex 作为基准，逐项列出所有修改点： 1. Core 解析链路：模块注册、扫描、计数、汇总 2. CLI 源类型与过滤：--codex、source union、默认 source 列表 3. TUI 交互与显示：source 类型、底部来源 badge、快捷键映射 4. Submit/社交链路：提交侧 source 过滤 + 服务端 schema 验证 5. 前端展示链路：frontend source type、名称/图标/颜色映射 6. 文档：来源列表、功能描述、筛选说明、Windows 路径表 反推 Kimi 是否一一对应。 这条 Prompt 之所以是全流程中 ROI 最高的验收手段（一条指令发现 12 处遗漏），关键在于它绕过了 AI 自检的共模失效。上一节已经证明，让 AI 自问「完成了吗？」得不到有效答案，因为 AI 的自检逻辑和实现逻辑共享同一套假设。而这条 Prompt 引入了一个外部参照物——Codex 的已有实现——作为「应该」的标准。\n区别在于问题的性质被转换了。「代码完整吗？」是一个主观判断题，AI 只能依赖自己的认知来回答。「Codex 出现在这 6 个位置，Kimi 是否也出现在这 6 个位置？」是一个客观模式匹配题，AI 只需要做字符串搜索和逐项比对，不需要依赖自身对「完整性」的主观理解。\n这条 Prompt 还有一个设计细节值得注意：它预先按功能域划分了 6 个类别（Core、CLI、TUI、Submit、Frontend、Docs），而不是简单地说「搜一下 codex 和 kimi 的对比」。这个分类框架引导 AI 在每个架构层都做一遍完整比对，避免 AI 在某一层找到几处遗漏后就停止搜索。事实上，12 处遗漏分布在 Submit、Frontend、Docs 三个不同的功能域——如果没有分类框架，AI 可能在发现 Submit 的 4 处遗漏后就报告「已修复」。\n基准对比的关键价值在于它检测的不是「代码对不对」，而是「代码全不全」。自动化测试不知道哪些文件「应该」包含 kimi，而基准对比通过一个已实现的参照物提供了这个「应该」。\n但基准对比有一个隐含假设：如果 Kimi 在某个文件中出现了，就认为该文件的实现是完整的。下一层会打破这个假设。\n第三层：端到端调用链追踪 基准对比修复了 12 处遗漏后，submit.ts 内部的类型定义、过滤逻辑、数组填充都已补齐。但追踪 --kimi 参数的完整数据流，调用链在中间断了。\n--kimi 参数的数据流分为三段：\n1 2 3 cli.ts .option(\"--kimi\", \"Include only Kimi CLI data\") ✅ 定义正确 cli.ts submit({ ..., kimi: options.kimi, ... }) ❌ 漏传 submit.ts if (options.kimi) sources.push(\"kimi\") ✅ 使用正确 两端各自正确，但中段传递断裂：cli.ts 的 action 函数调用 submit({...}) 时未传 kimi: options.kimi。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // cli.ts submit 命令的 action（修复前） await submit({ opencode: options.opencode, claude: options.claude, codex: options.codex, gemini: options.gemini, cursor: options.cursor, amp: options.amp, droid: options.droid, openclaw: options.openclaw, pi: options.pi, // kimi: options.kimi, ← 缺失 since: options.since, until: options.until, year: options.year, dryRun: options.dryRun, }); TypeScript 编译器不会报错，因为 kimi 在 SubmitOptions 中是可选参数（kimi?: boolean）。不传就是 undefined。submit 函数内部的 hasFilter 检查 options.kimi，得到 undefined，不触发过滤，走默认的全量提交路径。表面上功能正常——数据能提交——但 --kimi 过滤完全无效。\n为什么基准对比没有发现这个问题？grep 的输出本身是行级的，理论上可以逐行比对。但实际操作中，检查者（人或 AI）看到 cli.ts 中已经存在 \"kimi\" 字符串（在 .option(\"--kimi\", ...) 中），就认为这个文件已覆盖，没有继续追踪同一文件内其他应出现 kimi 的位置。submit.ts 的情况类似：修复后文件内部确实有了 kimi 的完整逻辑，但 cli.ts 调用 submit({...}) 的那一行属于 cli.ts，在那里被漏掉了。\n这暴露的不是基准对比方法本身的固有限制，而是执行粒度的问题：当检查者将 grep 结果退化为文件级扫描（「这个文件有 kimi 就算过」）时，行级遗漏就会漏网。要捕获这类问题，需要沿数据从 A 点到 B 点的完整路径逐段追踪，验证每段是否连通。\n第四层：质疑外部数据 前三层解决的都是代码层面的问题：遗漏、断链、类型不匹配。但还有一类问题不在代码逻辑中，而在代码引用的外部事实中。\nTokscale 需要知道每个模型的定价才能计算成本。Kimi CLI 使用 kimi-for-coding 作为模型标识，这个标识需要映射到一个有定价数据的模型名。AI 在 aliases.rs 中写下了这个映射：\n1 2 // 推断值——未经官方定价文档核实 m.insert(\"kimi-for-coding\", \"kimi-k2-thinking\"); kimi-k2-thinking 的 output 定价是 $2.50/M tokens。如果不追问，没有理由怀疑它。\n一句 Prompt 切换 AI 的认知模式 追问的 Prompt 是：\n1 2 代码修改中，像是 kimi 模型成本这种比较细节的问题， 你是如何获取的呢？你应该只能通过联网的方式获取到这个数据吧？请你自检下 AI 坦承这是基于模型命名的推断，而非来自官方定价文档。联网验证后发现 kimi-for-coding 实际对应的是 kimi-k2.5，output 定价为 $3.00/M tokens。两者差距 20%。\n1 2 // 官方定价页核实：kimi-for-coding → kimi-k2.5，$3.00/M output m.insert(\"kimi-for-coding\", \"kimi-k2.5\"); 改动只有一行，但如果漏过，Tokscale 对所有 Kimi 用户的成本计算都会偏低 20%。\n这条 Prompt 值得单独拆解，因为它在四轮验收中单位字数的 ROI 最高——一句话就把一个隐蔽的事实性错误逼了出来。\n关键在于它没有问「定价对不对？」——如果这样问，AI 会回顾自己填入的值，发现 $2.50 在 Kimi 系列的价格区间内属于合理范围，然后回答「对的」。这条 Prompt 问的是「你是如何获取的？」——这迫使 AI 从「给答案」模式切换到「评估答案置信度」模式。AI 不再试图辩护答案的合理性，而是被要求复盘自己的推理链条：我是从官方文档查到的，还是根据模型命名规律推断的？一旦进入这个模式，AI 会主动暴露推理过程中的不确定性，而不是把不确定性包装成确定的答案。\n这条 Prompt 的后半句「你应该只能通过联网的方式获取到这个数据吧？」进一步收窄了 AI 的退路。它预设了一个判断标准：这类数据的唯一可靠来源是联网查询。AI 无法在这个前提下继续声称「我根据模型名推断的结果是可靠的」，只能承认推断并转向联网验证。\n这类问题的特征是：AI 面对不确定的事实时，倾向于给出一个「合理推断」而非拒绝回答。推断出的值往往在语义上足够接近，不会触发开发者的直觉警报。kimi-k2-thinking 和 kimi-k2.5 都是 Kimi K2 系列的模型，$2.50 和 $3.00 的差距也不是数量级的错误。只有在明确追问数据来源时，这类错误才会浮出水面。对于涉及外部事实的映射关系——定价、API endpoint、版本号——追问来源，和验证「值看起来合不合理」是两件独立的事，前者无法被后者覆盖。\n闭环：四层漏斗模型与 Prompt 策略 四层漏斗的核心逻辑是：每一层用不同的检测原理过滤不同类型的问题，前一层的假阴性恰好落在后一层的检测范围内。\n层级 验证手段 Prompt 策略 发现问题数 典型案例 0 实现指令 探索性 Prompt + 详细计划 — Rust 100% / TS 遗漏 12 处 1 自动化测试 + AI 自检 「完成了吗？请你检查下」 0（假阴性） 169 个测试全部通过 2 基准对比 以 Codex 为参照物，分 6 域逐项比对 12 submit.ts、Zod schema、README 3 端到端追踪 人工逐段追踪调用链 3 submit 参数未传递 4 外部数据质疑 「这个数据你是如何获取的？」 1 定价别名映射错误 各层的检测原理不同，在实际操作中形成互补：第一层沿纵向做逻辑验证，对横向传播遗漏无感知；第二层通过字符串匹配发现了文件级遗漏，但在本次实践中未深入到行级的调用链检查；第三层追踪了数据流的完整生命周期，却不会质疑数据本身的真实性；第四层针对 AI「合理推断」的外部事实做源头验证。理论上，如果某一层的执行粒度足够细（比如基准对比逐行比对而非文件级扫描），可以覆盖下一层的部分检测范围。但在实际操作中，每层倾向于在自身的抽象粒度上工作，层间的互补关系因此成立。\n复盘 Prompt 后可以看到一条规律：有效的验收 Prompt 都在做同一件事——把 AI 从「回答者」模式切换到「审计者」模式。但切换的杠杆不同：\n自检 Prompt（失效）：「完成了吗？」——审计者和被审计者共享同一套假设（共模失效），检出率为零。 基准对比 Prompt（高效）：「Codex 有的，Kimi 也该有」——引入外部参照物，把主观判断题转换为客观匹配题，一次检出 12 处。 溯源 Prompt（精准）：「这个数据你怎么来的？」——攻击 AI 的推理链条而非推理结果，迫使 AI 暴露不确定性。 每一层的盲区在下一层中有针对性的对应手段。\n实践清单 自动化验证做基线：运行全量测试和 lint，检查是否引入回归。绿色结果代表「已有功能未被破坏」。 基准对比做横向覆盖：选一个已完整实现的同类功能作参照，用 grep 列出其所有出现位置，对照检查新增实现的覆盖情况。Prompt 中按功能域分类（Core / CLI / TUI / Submit / Frontend / Docs），避免 AI 在某一域发现遗漏后过早停止。 端到端追踪做连通性：从用户输入沿调用链追踪到最终输出，逐段验证参数传递。可选参数是断链高发区——TypeScript 的 ? 和 Rust 的 Option 都让缺失静默通过。 外部数据追问来源：对 AI 产出中涉及定价、API endpoint、版本号等外部事实，不问「对不对」，问「怎么来的」。前者让 AI 辩护结果的合理性，后者迫使 AI 暴露推理链条的薄弱环节。 169 个测试、0 个失败——这是本文的起点。四条 Prompt、16 处修复——这是从起点到终点之间，验收手段和提问策略共同填补的距离。\n","wordCount":"1146","inLanguage":"zh","datePublished":"2026-02-18T13:12:00+08:00","dateModified":"2026-02-18T13:13:59+08:00","author":{"@type":"Person","name":"Miss-you"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://miss-you.github.io/posts/20260218-ai-collaboration-acceptance-blindspots/"},"publisher":{"@type":"Organization","name":"Yousa Driven Development | YDD","logo":{"@type":"ImageObject","url":"https://miss-you.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://miss-you.github.io/ accesskey=h title="Yousa Driven Development | YDD (Alt + H)">Yousa Driven Development | YDD</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://miss-you.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://miss-you.github.io/archives title=归档><span>归档</span></a></li><li><a href=https://miss-you.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://miss-you.github.io/tools/ title=工具><span>工具</span></a></li><li><a href=https://miss-you.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://github.com/Miss-you title=GitHub><span>GitHub</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://miss-you.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://miss-you.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获</h1><div class=post-description>169 个测试全过，功能却完全失效。本文解剖一个真实任务的四层验收漏斗，揭示多层架构中横向传播遗漏的本质问题——以及不同 Prompt 策略如何决定验收效率。</div><div class=post-meta><span title='2026-02-18 13:12:00 +0800 +0800'>二月 18, 2026</span>&nbsp;·&nbsp;6 分钟&nbsp;·&nbsp;10443 字&nbsp;·&nbsp;Miss-you&nbsp;|&nbsp;<a href=https://github.com/Miss-you/miss-you.github.io/tree/main/content/posts/20260218-ai-collaboration-acceptance-blindspots/index.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#多层架构中的枚举值传播问题>多层架构中的「枚举值传播」问题</a></li><li><a href=#实现-prompt-复盘计划的覆盖范围--实现的覆盖范围>实现 Prompt 复盘：计划的覆盖范围 ≠ 实现的覆盖范围</a></li><li><a href=#第一层自动化测试的天花板>第一层：自动化测试的天花板</a><ul><li><a href=#sop-自检-prompt-的失效>SOP 自检 Prompt 的失效</a></li></ul></li><li><a href=#第二层基准对比法以-codex-为镜>第二层：基准对比法——以 Codex 为镜</a><ul><li><a href=#基准对比-prompt-的设计逻辑>基准对比 Prompt 的设计逻辑</a></li></ul></li><li><a href=#第三层端到端调用链追踪>第三层：端到端调用链追踪</a></li><li><a href=#第四层质疑外部数据>第四层：质疑外部数据</a><ul><li><a href=#一句-prompt-切换-ai-的认知模式>一句 Prompt 切换 AI 的认知模式</a></li></ul></li><li><a href=#闭环四层漏斗模型与-prompt-策略>闭环：四层漏斗模型与 Prompt 策略</a><ul><li><a href=#实践清单>实践清单</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=ai-协作开发的验收盲区169-个测试全过16-处遗漏未捕获>AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获<a hidden class=anchor aria-hidden=true href=#ai-协作开发的验收盲区169-个测试全过16-处遗漏未捕获>#</a></h1><p>TypeScript 编译零错误，<code>clippy</code> 零 warning，CLI 返回正确数据。AI 报告「代码完成」。</p><p>submit 功能完全失效。前端校验会拒绝包含新数据源的提交请求。文档有多处与代码不一致的描述。这些问题在首轮验收中全部隐形（不是被忽略，而是现有验证手段从结构上无法触及）。</p><p>测试全绿证明不了质量，只证明了测试覆盖了多少。在多层架构中，纵向测试验证的是「这段代码做了什么」，而非「这段代码应该做什么但没做」。一个新增的枚举值需要在 26 个触点完成注册，其中只有约 8 个的缺失会触发编译错误。剩余 18 个触点即使全部遗漏，编译照过，测试照绿，功能链路静默断裂在中间层。遗漏是一种 absence——在缺乏穷尽匹配约束的代码层中，absence 不报错。</p><p>这不是理论推演。本文解剖的是一个真实任务：为 Tokscale 添加第 10 个 AI 数据源（Kimi），涉及 28 个文件修改、约 300 行新增 Rust 代码、横跨 6 个架构层（Core → Pricing → CLI → TUI → Frontend → Docs）。AI 首轮交付后，第一轮验收发现 0 个问题，第二轮发现 12 处遗漏，第三轮仍追出 3 处。每一轮使用不同的验证方法，每一层专门捕获前一层的盲区。</p><p>但这篇文章不仅仅是方法论的分类账。本文同时复盘了每一轮验收背后的 Prompt——人类如何向 AI 提问，直接决定了 AI 能暴露多少自身的盲区。同一个 AI，面对不同的提问方式，交出的答案质量天差地别。四轮验收的差异，很大程度上源于 Prompt 策略的差异（第三层除外——那一层更多依赖人工逐段追踪而非 Prompt 引导）。</p><hr><h2 id=多层架构中的枚举值传播问题>多层架构中的「枚举值传播」问题<a hidden class=anchor aria-hidden=true href=#多层架构中的枚举值传播问题>#</a></h2><p>Tokscale 的架构分为 6 层，从底层的 Rust Core 解析器一直延伸到最上层的文档：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>Layer</span> <span class=mi>1</span><span class=p>:</span> <span class=n>Rust</span> <span class=n>Core</span> <span class=n>Parser</span> <span class=p>(</span><span class=n>kimi</span><span class=o>.</span><span class=n>rs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=err>↓</span> <span class=n>UnifiedMessage</span>
</span></span><span class=line><span class=cl><span class=n>Layer</span> <span class=mi>2</span><span class=p>:</span> <span class=n>Rust</span> <span class=n>Scanner</span> <span class=o>+</span> <span class=n>Pipeline</span> <span class=p>(</span><span class=n>scanner</span><span class=o>.</span><span class=n>rs</span><span class=p>,</span> <span class=n>lib</span><span class=o>.</span><span class=n>rs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=err>↓</span> <span class=n>ParsedMessages</span> <span class=p>{</span> <span class=n>kimiCount</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>Layer</span> <span class=mi>3</span><span class=p>:</span> <span class=n>TypeScript</span> <span class=n>CLI</span> <span class=p>(</span><span class=n>graph</span><span class=o>-</span><span class=n>types</span><span class=o>.</span><span class=n>ts</span><span class=p>,</span> <span class=n>native</span><span class=o>.</span><span class=n>ts</span><span class=p>,</span> <span class=n>cli</span><span class=o>.</span><span class=n>ts</span><span class=p>,</span> <span class=n>submit</span><span class=o>.</span><span class=n>ts</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=err>↓</span> <span class=n>SourceType</span> <span class=o>=</span> <span class=s2>&#34;kimi&#34;</span>
</span></span><span class=line><span class=cl><span class=n>Layer</span> <span class=mi>4</span><span class=p>:</span> <span class=n>TUI</span> <span class=n>Display</span> <span class=p>(</span><span class=n>types</span><span class=p>,</span> <span class=n>colors</span><span class=p>,</span> <span class=n>Footer</span><span class=p>,</span> <span class=n>useData</span><span class=p>,</span> <span class=n>App</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=err>↓</span> <span class=n>badge</span><span class=p>,</span> <span class=n>hotkey</span><span class=p>,</span> <span class=n>color</span>
</span></span><span class=line><span class=cl><span class=n>Layer</span> <span class=mi>5</span><span class=p>:</span> <span class=n>Frontend</span> <span class=p>(</span><span class=n>types</span><span class=o>.</span><span class=n>ts</span><span class=p>,</span> <span class=n>validation</span><span class=o>/</span><span class=n>submission</span><span class=o>.</span><span class=n>ts</span><span class=p>,</span> <span class=n>constants</span><span class=o>.</span><span class=n>ts</span><span class=p>,</span> <span class=n>SourceLogo</span><span class=o>.</span><span class=n>tsx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=err>↓</span> <span class=n>Zod</span> <span class=n>schema</span><span class=p>,</span> <span class=n>display</span> <span class=n>config</span>
</span></span><span class=line><span class=cl><span class=n>Layer</span> <span class=mi>6</span><span class=p>:</span> <span class=n>Documentation</span> <span class=p>(</span><span class=n>README</span> <span class=err>×</span> <span class=mi>4</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>每新增一个数据源，这 6 层中总共有 26 个触点需要添加对应的逻辑。以 <code>scanner.rs</code> 中的 <code>ScanResult</code> 为例，这个结构体为每个数据源各保留了一个文件列表字段：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[derive(Debug, Default)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>ScanResult</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>opencode_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>opencode_db</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>claude_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>codex_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>gemini_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>cursor_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>amp_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>droid_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>openclaw_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>pi_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>kimi_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>    </span><span class=c1>// ← 第 10 个数据源
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这种模式意味着 <code>kimi_files</code> 必须出现在 <code>ScanResult</code> 的定义、<code>total_files()</code> 的求和、<code>all_files()</code> 的遍历、<code>scan_all_sources()</code> 的扫描和聚合等多处。仅 <code>scanner.rs</code> 一个文件就占 5 个触点。</p><p>26 个触点中，只有约 8 个遗漏会导致编译失败——比如 <code>ScanResult</code> 新增字段后有代码引用它（缺失则编译失败）、<code>SessionType</code> 缺枚举值（在没有通配符的 <code>match</code> 中报 non-exhaustive）、<code>ParsedMessages</code> 缺计数字段。这些错误编译器直接拦截。但剩下的约 18 个触点，遗漏后编译通过、测试通过，功能却不完整。比如 <code>submit.ts</code> 的 <code>hasFilter</code> 逻辑不检查 <code>options.kimi</code>，结果是 <code>--kimi</code> 参数定义了但提交时不生效；又比如前端的 <code>z.enum</code> 不包含 <code>"kimi"</code>，结果是包含 Kimi 数据的提交会被校验拒绝。</p><p>AI 在首轮实现中完成了约 14 个触点——Rust Core 全部正确，CLI 大部分到位——遗漏了 12 个。自动化测试一处遗漏也没检出。</p><hr><h2 id=实现-prompt-复盘计划的覆盖范围--实现的覆盖范围>实现 Prompt 复盘：计划的覆盖范围 ≠ 实现的覆盖范围<a hidden class=anchor aria-hidden=true href=#实现-prompt-复盘计划的覆盖范围--实现的覆盖范围>#</a></h2><p>在分析验收手段之前，先看源头：我们给 AI 的实现指令是什么，AI 交付了什么，差距出现在哪里。</p><p>实现阶段的核心 Prompt 是一条探索性指令，附带了详细的技术方案：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>实现以下计划：为 Tokscale 添加 Kimi CLI 支持
</span></span><span class=line><span class=cl>[附带详细的技术方案、任务清单、验收标准]
</span></span></code></pre></td></tr></table></div></div><p>这条 Prompt 的设计意图是充分的：它包含了 Rust Core 和 TypeScript CLI 两端的完整修改范围，列出了 6 层架构的触点清单，甚至附带了可执行的验收标准。从计划文档的角度看，覆盖范围是完整的。</p><p>但计划的覆盖范围和实现的覆盖范围是两回事。</p><p>AI 的实际交付呈现出一个清晰的模式：Rust Core 层的 8 个触点全部正确完成——<code>kimi.rs</code> 解析器、<code>scanner.rs</code> 扫描逻辑、<code>lib.rs</code> 管线集成、<code>aliases.rs</code> 定价映射，无一遗漏。而 TypeScript/Frontend/Docs 层的约 18 个触点中，只完成了 6 个，遗漏了 12 个。</p><p>这个分布不是随机的。Rust 端有编译器充当「隐形验收官」：在本项目中，<code>ScanResult</code> 的字段被其他代码引用，缺一个就编译不过；<code>SessionType</code> 的 <code>match</code> 没有使用通配符分支，少一个枚举值就报 non-exhaustive pattern。编译器迫使 AI 在实现阶段就把这些触点补齐。而 TypeScript 端的可选类型（<code>kimi?: boolean</code>）和运行时校验（<code>z.enum</code>）不会在编译期发出任何信号——遗漏了也能通过，于是 AI 就停在了「编译通过」的节点上。</p><p>这揭示了探索性 Prompt 的一个结构性局限：它给 AI 提供了「做什么」的清单，但 AI 的完成判定依赖于环境反馈。在有强类型约束的 Rust 端，环境反馈是即时且强制的——编译失败就必须修；在弱约束的 TypeScript/Frontend 端，环境反馈是静默的——编译通过就以为完成了。同一条 Prompt，在不同语言层产生了截然不同的完成度，差异不在指令本身，而在目标语言的类型系统对遗漏的容忍度。</p><p>在本案例中，AI 的实现深度更多跟着编译器走，而不是跟着计划走。计划说「修改 28 个文件」，编译器只强制其中 8 个，AI 做到了 8 + 6 = 14 个——6 个 TypeScript 触点靠 AI 自身的上下文理解完成，没有编译器兜底，这说明 AI 并非完全依赖编译器反馈。但编译器反馈的有无，仍然是 Rust 端 100% 完成 vs TypeScript 端大量遗漏的最显著区别因素。剩余 12 个触点需要人类的验收手段来发现。</p><hr><h2 id=第一层自动化测试的天花板>第一层：自动化测试的天花板<a hidden class=anchor aria-hidden=true href=#第一层自动化测试的天花板>#</a></h2><p>AI 完成首轮实现后，执行了完整的自动化验证流程，6 项检查全部通过：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7>7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cargo build          ✅  无 error
</span></span><span class=line><span class=cl>$ cargo test           ✅  169 passed, 0 failed
</span></span><span class=line><span class=cl>$ cargo clippy         ✅  0 new warning
</span></span><span class=line><span class=cl>$ bun run build:cli    ✅  TypeScript 编译通过
</span></span><span class=line><span class=cl>$ bun run cli -- sources
</span></span><span class=line><span class=cl>                       ✅  显示 Kimi CLI（674 messages）
</span></span><span class=line><span class=cl>$ bun run cli -- models --kimi --json
</span></span><span class=line><span class=cl>                       ✅  返回正确数据
</span></span></code></pre></td></tr></table></div></div><p>这 6 项检查为什么没有发现 12 处遗漏？</p><p>原因在于编译器和测试框架检查的是纵向的类型一致性，而非横向的传播完整性。<code>cargo build</code> 能检测到 <code>ScanResult</code> 缺 <code>kimi_files</code> 字段（其他代码会引用它，不存在则编译失败）。但 <code>cargo build</code> 无法检测到 <code>submit.ts</code> 里的 <code>hasFilter</code>（过滤条件变量）是否包含了 <code>options.kimi</code> 这一项——因为 <code>kimi</code> 在 <code>SubmitOptions</code> 中的类型是可选的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7>7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>interface</span> <span class=nx>SubmitOptions</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>opencode?</span>: <span class=kt>boolean</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>claude?</span>: <span class=kt>boolean</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>codex?</span>: <span class=kt>boolean</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ... 省略其他 source
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>kimi?</span>: <span class=kt>boolean</span><span class=p>;</span>      <span class=c1>// ← 可选参数，不传 = undefined
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>since?</span>: <span class=kt>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>当 <code>cli.ts</code> 调用 <code>submit({...})</code> 时没有传递 <code>kimi: options.kimi</code>，TypeScript 不会报错。<code>kimi</code> 本来就是可选的，不传等于 <code>undefined</code>，走到 <code>hasFilter</code> 时不触发，结果进入默认路径。功能表现为「<code>--kimi</code> 参数存在但没有任何效果」，不会有任何运行时错误。</p><p>前端的情况类似。Zod schema 中的 <code>z.enum</code> 是运行时校验，只在提交包含 <code>source: "kimi"</code> 的数据时才触发校验失败。不提交就不会发现 enum 少了一项。而我们的测试流程只验证了读取路径（<code>models --kimi --json</code>），没有走到提交路径。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// source 字段的合法值全部硬编码在此——列表残缺即校验失败
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>source</span>: <span class=kt>z.enum</span><span class=p>([</span><span class=s2>&#34;opencode&#34;</span><span class=p>,</span> <span class=s2>&#34;claude&#34;</span><span class=p>,</span> <span class=s2>&#34;codex&#34;</span><span class=p>,</span> <span class=s2>&#34;gemini&#34;</span><span class=p>,</span> <span class=s2>&#34;cursor&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s2>&#34;amp&#34;</span><span class=p>,</span> <span class=s2>&#34;droid&#34;</span><span class=p>,</span> <span class=s2>&#34;openclaw&#34;</span><span class=p>,</span> <span class=s2>&#34;pi&#34;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl><span class=c1>// ↑ 缺少 &#34;kimi&#34;，测试只走读取路径，从未触发这条校验
</span></span></span></code></pre></td></tr></table></div></div><h3 id=sop-自检-prompt-的失效>SOP 自检 Prompt 的失效<a hidden class=anchor aria-hidden=true href=#sop-自检-prompt-的失效>#</a></h3><p>在自动化测试全绿之后，验收的第一个直觉是让 AI 自我检查。使用的 Prompt 是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. 代码完成了吗？
</span></span><span class=line><span class=cl>2. 你列的验收列表这里，完成情况如何，包括存量用例运行，以及新增的单元测试等等
</span></span><span class=line><span class=cl>3. 现在还有哪些没完成呢？请你检查下
</span></span></code></pre></td></tr></table></div></div><p>这是一种「元认知」策略——要求 AI 先生成自己的验收清单，再对着清单逐项核对。AI 随后启动了两个并行 Subagent 做全量验证：一个跑 <code>cargo test</code>（169 passed）+ <code>cargo clippy</code>（零新 warning），另一个执行 6 条 CLI 集成测试命令。</p><p>结果：发现 0 个结构性遗漏。</p><p>这个 Prompt 为什么失效？因为它让 AI 用自己的心智模型来审计自己的产出。AI 的自检 SOP 和它的实现逻辑共享同一个盲区——两者都沿纵向路径检查（代码能编译吗？测试能跑通吗？CLI 能返回数据吗？），而不会沿横向路径检查（<code>"kimi"</code> 是否出现在所有 26 个触点？）。让同一个 AI 既写代码又写验收清单，等价于让考生在没有标准答案的情况下批改自己的试卷——它不是不会，而是无从判断自己遗漏了什么。用工程术语说，这是一种「共模失效」（common-mode failure）：审计者和被审计者共享同一套假设，AI 在 Review 时的检查范围和它在编码时的认知范围高度重叠。但这不是 AI 能力的上限——后文会证明，换一种 Prompt（基准对比），同一个 AI 就能发现全部 12 处遗漏。问题不在 AI「看不到」，而在于没有外部参照物时，它不知道该往哪里看。</p><p>这两类遗漏——可选参数默默缺席、运行时校验从未触发——需要完全不同的检测手段。自动化测试和 AI 自检都无法触及它们，因为两者的检测原理都是纵向的：验证已有代码的行为，而非审计应有代码的存在。</p><hr><h2 id=第二层基准对比法以-codex-为镜>第二层：基准对比法——以 Codex 为镜<a hidden class=anchor aria-hidden=true href=#第二层基准对比法以-codex-为镜>#</a></h2><p>核心思路是：既然 Codex 已完整实现，那么 Codex 出现的每个位置，Kimi 也应该出现。在全代码库搜索 <code>"codex"</code> 的所有出现位置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Rust 侧由编译器保证，遗漏集中在 TypeScript/Frontend 层</span>
</span></span><span class=line><span class=cl>$ grep -rn <span class=s1>&#39;&#34;codex&#34;&#39;</span> packages/cli/src/ packages/frontend/src/
</span></span></code></pre></td></tr></table></div></div><p>结果：一次性暴露 12 处遗漏。以 <code>validation/submission.ts</code> 为例，修复前后的对比：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// 修复前——z.enum 缺少 &#34;kimi&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>source</span>: <span class=kt>z.enum</span><span class=p>([</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;opencode&#34;</span><span class=p>,</span> <span class=s2>&#34;claude&#34;</span><span class=p>,</span> <span class=s2>&#34;codex&#34;</span><span class=p>,</span> <span class=s2>&#34;gemini&#34;</span><span class=p>,</span> <span class=s2>&#34;cursor&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;amp&#34;</span><span class=p>,</span> <span class=s2>&#34;droid&#34;</span><span class=p>,</span> <span class=s2>&#34;openclaw&#34;</span><span class=p>,</span> <span class=s2>&#34;pi&#34;</span>
</span></span><span class=line><span class=cl><span class=p>]),</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 修复后
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>source</span>: <span class=kt>z.enum</span><span class=p>([</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;opencode&#34;</span><span class=p>,</span> <span class=s2>&#34;claude&#34;</span><span class=p>,</span> <span class=s2>&#34;codex&#34;</span><span class=p>,</span> <span class=s2>&#34;gemini&#34;</span><span class=p>,</span> <span class=s2>&#34;cursor&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;amp&#34;</span><span class=p>,</span> <span class=s2>&#34;droid&#34;</span><span class=p>,</span> <span class=s2>&#34;openclaw&#34;</span><span class=p>,</span> <span class=s2>&#34;pi&#34;</span><span class=p>,</span> <span class=s2>&#34;kimi&#34;</span>   <span class=c1>// ← 修复点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>]),</span>
</span></span></code></pre></td></tr></table></div></div><p>这个文件中有两处 <code>z.enum</code>——<code>SourceContributionSchema</code> 和 <code>DataSummarySchema</code>——两处都遗漏了 <code>"kimi"</code>。如果用户提交包含 Kimi 数据的使用报告，Zod 校验会在 <code>source</code> 字段处失败，请求被拦截或服务端返回 400。</p><p><code>submit.ts</code> 中有 4 处遗漏（类型定义、过滤逻辑、数组填充），其余分布在前端的 <code>types.ts</code>、<code>constants.ts</code>、<code>SourceLogo.tsx</code> 和 README。</p><h3 id=基准对比-prompt-的设计逻辑>基准对比 Prompt 的设计逻辑<a hidden class=anchor aria-hidden=true href=#基准对比-prompt-的设计逻辑>#</a></h3><p>触发这一轮发现的 Prompt 是一条结构化的基准比对指令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7>7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8>8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>以 Codex 作为基准，逐项列出所有修改点：
</span></span><span class=line><span class=cl>1. Core 解析链路：模块注册、扫描、计数、汇总
</span></span><span class=line><span class=cl>2. CLI 源类型与过滤：--codex、source union、默认 source 列表
</span></span><span class=line><span class=cl>3. TUI 交互与显示：source 类型、底部来源 badge、快捷键映射
</span></span><span class=line><span class=cl>4. Submit/社交链路：提交侧 source 过滤 + 服务端 schema 验证
</span></span><span class=line><span class=cl>5. 前端展示链路：frontend source type、名称/图标/颜色映射
</span></span><span class=line><span class=cl>6. 文档：来源列表、功能描述、筛选说明、Windows 路径表
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>反推 Kimi 是否一一对应。
</span></span></code></pre></td></tr></table></div></div><p>这条 Prompt 之所以是全流程中 ROI 最高的验收手段（一条指令发现 12 处遗漏），关键在于它绕过了 AI 自检的共模失效。上一节已经证明，让 AI 自问「完成了吗？」得不到有效答案，因为 AI 的自检逻辑和实现逻辑共享同一套假设。而这条 Prompt 引入了一个外部参照物——Codex 的已有实现——作为「应该」的标准。</p><p>区别在于问题的性质被转换了。「代码完整吗？」是一个主观判断题，AI 只能依赖自己的认知来回答。「Codex 出现在这 6 个位置，Kimi 是否也出现在这 6 个位置？」是一个客观模式匹配题，AI 只需要做字符串搜索和逐项比对，不需要依赖自身对「完整性」的主观理解。</p><p>这条 Prompt 还有一个设计细节值得注意：它预先按功能域划分了 6 个类别（Core、CLI、TUI、Submit、Frontend、Docs），而不是简单地说「搜一下 codex 和 kimi 的对比」。这个分类框架引导 AI 在每个架构层都做一遍完整比对，避免 AI 在某一层找到几处遗漏后就停止搜索。事实上，12 处遗漏分布在 Submit、Frontend、Docs 三个不同的功能域——如果没有分类框架，AI 可能在发现 Submit 的 4 处遗漏后就报告「已修复」。</p><p>基准对比的关键价值在于它检测的不是「代码对不对」，而是「代码全不全」。自动化测试不知道哪些文件「应该」包含 kimi，而基准对比通过一个已实现的参照物提供了这个「应该」。</p><p>但基准对比有一个隐含假设：如果 Kimi 在某个文件中出现了，就认为该文件的实现是完整的。下一层会打破这个假设。</p><hr><h2 id=第三层端到端调用链追踪>第三层：端到端调用链追踪<a hidden class=anchor aria-hidden=true href=#第三层端到端调用链追踪>#</a></h2><p>基准对比修复了 12 处遗漏后，<code>submit.ts</code> 内部的类型定义、过滤逻辑、数组填充都已补齐。但追踪 <code>--kimi</code> 参数的完整数据流，调用链在中间断了。</p><p><code>--kimi</code> 参数的数据流分为三段：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>cli.ts    .option(&#34;--kimi&#34;, &#34;Include only Kimi CLI data&#34;)     ✅ 定义正确
</span></span><span class=line><span class=cl>cli.ts    submit({ ..., kimi: options.kimi, ... })             ❌ 漏传
</span></span><span class=line><span class=cl>submit.ts if (options.kimi) sources.push(&#34;kimi&#34;)               ✅ 使用正确
</span></span></code></pre></td></tr></table></div></div><p>两端各自正确，但中段传递断裂：<code>cli.ts</code> 的 action 函数调用 <code>submit({...})</code> 时未传 <code>kimi: options.kimi</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14>14</a>
</span><span class=lnt id=hl-11-15><a class=lnlinks href=#hl-11-15>15</a>
</span><span class=lnt id=hl-11-16><a class=lnlinks href=#hl-11-16>16</a>
</span><span class=lnt id=hl-11-17><a class=lnlinks href=#hl-11-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// cli.ts submit 命令的 action（修复前）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>await</span> <span class=nx>submit</span><span class=p>({</span>
</span></span><span class=line><span class=cl>  <span class=nx>opencode</span>: <span class=kt>options.opencode</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>claude</span>: <span class=kt>options.claude</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>codex</span>: <span class=kt>options.codex</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>gemini</span>: <span class=kt>options.gemini</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>cursor</span>: <span class=kt>options.cursor</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>amp</span>: <span class=kt>options.amp</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>droid</span>: <span class=kt>options.droid</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>openclaw</span>: <span class=kt>options.openclaw</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>pi</span>: <span class=kt>options.pi</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=c1>// kimi: options.kimi,    ← 缺失
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>since</span>: <span class=kt>options.since</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>until</span>: <span class=kt>options.until</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>year</span>: <span class=kt>options.year</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>dryRun</span>: <span class=kt>options.dryRun</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>TypeScript 编译器不会报错，因为 <code>kimi</code> 在 <code>SubmitOptions</code> 中是可选参数（<code>kimi?: boolean</code>）。不传就是 <code>undefined</code>。<code>submit</code> 函数内部的 <code>hasFilter</code> 检查 <code>options.kimi</code>，得到 <code>undefined</code>，不触发过滤，走默认的全量提交路径。表面上功能正常——数据能提交——但 <code>--kimi</code> 过滤完全无效。</p><p>为什么基准对比没有发现这个问题？<code>grep</code> 的输出本身是行级的，理论上可以逐行比对。但实际操作中，检查者（人或 AI）看到 <code>cli.ts</code> 中已经存在 <code>"kimi"</code> 字符串（在 <code>.option("--kimi", ...)</code> 中），就认为这个文件已覆盖，没有继续追踪同一文件内其他应出现 <code>kimi</code> 的位置。<code>submit.ts</code> 的情况类似：修复后文件内部确实有了 <code>kimi</code> 的完整逻辑，但 <code>cli.ts</code> 调用 <code>submit({...})</code> 的那一行属于 <code>cli.ts</code>，在那里被漏掉了。</p><p>这暴露的不是基准对比方法本身的固有限制，而是执行粒度的问题：当检查者将 <code>grep</code> 结果退化为文件级扫描（「这个文件有 kimi 就算过」）时，行级遗漏就会漏网。要捕获这类问题，需要沿数据从 A 点到 B 点的完整路径逐段追踪，验证每段是否连通。</p><hr><h2 id=第四层质疑外部数据>第四层：质疑外部数据<a hidden class=anchor aria-hidden=true href=#第四层质疑外部数据>#</a></h2><p>前三层解决的都是代码层面的问题：遗漏、断链、类型不匹配。但还有一类问题不在代码逻辑中，而在代码引用的外部事实中。</p><p>Tokscale 需要知道每个模型的定价才能计算成本。Kimi CLI 使用 <code>kimi-for-coding</code> 作为模型标识，这个标识需要映射到一个有定价数据的模型名。AI 在 <code>aliases.rs</code> 中写下了这个映射：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 推断值——未经官方定价文档核实
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;kimi-for-coding&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;kimi-k2-thinking&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>kimi-k2-thinking</code> 的 output 定价是 $2.50/M tokens。如果不追问，没有理由怀疑它。</p><h3 id=一句-prompt-切换-ai-的认知模式>一句 Prompt 切换 AI 的认知模式<a hidden class=anchor aria-hidden=true href=#一句-prompt-切换-ai-的认知模式>#</a></h3><p>追问的 Prompt 是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>代码修改中，像是 kimi 模型成本这种比较细节的问题，
</span></span><span class=line><span class=cl>你是如何获取的呢？你应该只能通过联网的方式获取到这个数据吧？请你自检下
</span></span></code></pre></td></tr></table></div></div><p>AI 坦承这是基于模型命名的推断，而非来自官方定价文档。联网验证后发现 <code>kimi-for-coding</code> 实际对应的是 <code>kimi-k2.5</code>，output 定价为 $3.00/M tokens。两者差距 20%。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 官方定价页核实：kimi-for-coding → kimi-k2.5，$3.00/M output
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;kimi-for-coding&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;kimi-k2.5&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>改动只有一行，但如果漏过，Tokscale 对所有 Kimi 用户的成本计算都会偏低 20%。</p><p>这条 Prompt 值得单独拆解，因为它在四轮验收中单位字数的 ROI 最高——一句话就把一个隐蔽的事实性错误逼了出来。</p><p>关键在于它没有问「定价对不对？」——如果这样问，AI 会回顾自己填入的值，发现 <code>$2.50</code> 在 Kimi 系列的价格区间内属于合理范围，然后回答「对的」。这条 Prompt 问的是「你是如何获取的？」——这迫使 AI 从「给答案」模式切换到「评估答案置信度」模式。AI 不再试图辩护答案的合理性，而是被要求复盘自己的推理链条：我是从官方文档查到的，还是根据模型命名规律推断的？一旦进入这个模式，AI 会主动暴露推理过程中的不确定性，而不是把不确定性包装成确定的答案。</p><p>这条 Prompt 的后半句「你应该只能通过联网的方式获取到这个数据吧？」进一步收窄了 AI 的退路。它预设了一个判断标准：这类数据的唯一可靠来源是联网查询。AI 无法在这个前提下继续声称「我根据模型名推断的结果是可靠的」，只能承认推断并转向联网验证。</p><p>这类问题的特征是：AI 面对不确定的事实时，倾向于给出一个「合理推断」而非拒绝回答。推断出的值往往在语义上足够接近，不会触发开发者的直觉警报。<code>kimi-k2-thinking</code> 和 <code>kimi-k2.5</code> 都是 Kimi K2 系列的模型，$2.50 和 $3.00 的差距也不是数量级的错误。只有在明确追问数据来源时，这类错误才会浮出水面。对于涉及外部事实的映射关系——定价、API endpoint、版本号——追问来源，和验证「值看起来合不合理」是两件独立的事，前者无法被后者覆盖。</p><hr><h2 id=闭环四层漏斗模型与-prompt-策略>闭环：四层漏斗模型与 Prompt 策略<a hidden class=anchor aria-hidden=true href=#闭环四层漏斗模型与-prompt-策略>#</a></h2><p>四层漏斗的核心逻辑是：每一层用不同的检测原理过滤不同类型的问题，前一层的假阴性恰好落在后一层的检测范围内。</p><table><thead><tr><th>层级</th><th>验证手段</th><th>Prompt 策略</th><th>发现问题数</th><th>典型案例</th></tr></thead><tbody><tr><td>0</td><td>实现指令</td><td>探索性 Prompt + 详细计划</td><td>—</td><td>Rust 100% / TS 遗漏 12 处</td></tr><tr><td>1</td><td>自动化测试 + AI 自检</td><td>「完成了吗？请你检查下」</td><td>0（假阴性）</td><td>169 个测试全部通过</td></tr><tr><td>2</td><td>基准对比</td><td>以 Codex 为参照物，分 6 域逐项比对</td><td>12</td><td>submit.ts、Zod schema、README</td></tr><tr><td>3</td><td>端到端追踪</td><td>人工逐段追踪调用链</td><td>3</td><td>submit 参数未传递</td></tr><tr><td>4</td><td>外部数据质疑</td><td>「这个数据你是如何获取的？」</td><td>1</td><td>定价别名映射错误</td></tr></tbody></table><p>各层的检测原理不同，在实际操作中形成互补：第一层沿纵向做逻辑验证，对横向传播遗漏无感知；第二层通过字符串匹配发现了文件级遗漏，但在本次实践中未深入到行级的调用链检查；第三层追踪了数据流的完整生命周期，却不会质疑数据本身的真实性；第四层针对 AI「合理推断」的外部事实做源头验证。理论上，如果某一层的执行粒度足够细（比如基准对比逐行比对而非文件级扫描），可以覆盖下一层的部分检测范围。但在实际操作中，每层倾向于在自身的抽象粒度上工作，层间的互补关系因此成立。</p><p>复盘 Prompt 后可以看到一条规律：有效的验收 Prompt 都在做同一件事——把 AI 从「回答者」模式切换到「审计者」模式。但切换的杠杆不同：</p><ul><li><strong>自检 Prompt（失效）</strong>：「完成了吗？」——审计者和被审计者共享同一套假设（共模失效），检出率为零。</li><li><strong>基准对比 Prompt（高效）</strong>：「Codex 有的，Kimi 也该有」——引入外部参照物，把主观判断题转换为客观匹配题，一次检出 12 处。</li><li><strong>溯源 Prompt（精准）</strong>：「这个数据你怎么来的？」——攻击 AI 的推理链条而非推理结果，迫使 AI 暴露不确定性。</li></ul><p>每一层的盲区在下一层中有针对性的对应手段。</p><h3 id=实践清单>实践清单<a hidden class=anchor aria-hidden=true href=#实践清单>#</a></h3><ul><li><strong>自动化验证做基线</strong>：运行全量测试和 <code>lint</code>，检查是否引入回归。绿色结果代表「已有功能未被破坏」。</li><li><strong>基准对比做横向覆盖</strong>：选一个已完整实现的同类功能作参照，用 <code>grep</code> 列出其所有出现位置，对照检查新增实现的覆盖情况。Prompt 中按功能域分类（Core / CLI / TUI / Submit / Frontend / Docs），避免 AI 在某一域发现遗漏后过早停止。</li><li><strong>端到端追踪做连通性</strong>：从用户输入沿调用链追踪到最终输出，逐段验证参数传递。可选参数是断链高发区——TypeScript 的 <code>?</code> 和 Rust 的 <code>Option&lt;T></code> 都让缺失静默通过。</li><li><strong>外部数据追问来源</strong>：对 AI 产出中涉及定价、API endpoint、版本号等外部事实，不问「对不对」，问「怎么来的」。前者让 AI 辩护结果的合理性，后者迫使 AI 暴露推理链条的薄弱环节。</li></ul><p>169 个测试、0 个失败——这是本文的起点。四条 Prompt、16 处修复——这是从起点到终点之间，验收手段和提问策略共同填补的距离。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://miss-you.github.io/tags/ai/>AI</a></li><li><a href=https://miss-you.github.io/tags/prompt-engineering/>Prompt Engineering</a></li><li><a href=https://miss-you.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/>软件工程</a></li><li><a href=https://miss-you.github.io/tags/%E6%B5%8B%E8%AF%95/>测试</a></li><li><a href=https://miss-you.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/>代码审查</a></li><li><a href=https://miss-you.github.io/tags/rust/>Rust</a></li><li><a href=https://miss-you.github.io/tags/typescript/>TypeScript</a></li></ul><nav class=paginav><a class=next href=https://miss-you.github.io/posts/20260217-websocket-to-four-components/><span class=title>下一页 »</span><br><span>从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获 on x" href="https://x.com/intent/tweet/?text=AI%20%e5%8d%8f%e4%bd%9c%e5%bc%80%e5%8f%91%e7%9a%84%e9%aa%8c%e6%94%b6%e7%9b%b2%e5%8c%ba%ef%bc%9a169%20%e4%b8%aa%e6%b5%8b%e8%af%95%e5%85%a8%e8%bf%87%ef%bc%8c16%20%e5%a4%84%e9%81%97%e6%bc%8f%e6%9c%aa%e6%8d%95%e8%8e%b7&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f&amp;hashtags=AI%2cPromptEngineering%2c%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%2c%e6%b5%8b%e8%af%95%2c%e4%bb%a3%e7%a0%81%e5%ae%a1%e6%9f%a5%2cRust%2cTypeScript"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f&amp;title=AI%20%e5%8d%8f%e4%bd%9c%e5%bc%80%e5%8f%91%e7%9a%84%e9%aa%8c%e6%94%b6%e7%9b%b2%e5%8c%ba%ef%bc%9a169%20%e4%b8%aa%e6%b5%8b%e8%af%95%e5%85%a8%e8%bf%87%ef%bc%8c16%20%e5%a4%84%e9%81%97%e6%bc%8f%e6%9c%aa%e6%8d%95%e8%8e%b7&amp;summary=AI%20%e5%8d%8f%e4%bd%9c%e5%bc%80%e5%8f%91%e7%9a%84%e9%aa%8c%e6%94%b6%e7%9b%b2%e5%8c%ba%ef%bc%9a169%20%e4%b8%aa%e6%b5%8b%e8%af%95%e5%85%a8%e8%bf%87%ef%bc%8c16%20%e5%a4%84%e9%81%97%e6%bc%8f%e6%9c%aa%e6%8d%95%e8%8e%b7&amp;source=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f&title=AI%20%e5%8d%8f%e4%bd%9c%e5%bc%80%e5%8f%91%e7%9a%84%e9%aa%8c%e6%94%b6%e7%9b%b2%e5%8c%ba%ef%bc%9a169%20%e4%b8%aa%e6%b5%8b%e8%af%95%e5%85%a8%e8%bf%87%ef%bc%8c16%20%e5%a4%84%e9%81%97%e6%bc%8f%e6%9c%aa%e6%8d%95%e8%8e%b7"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获 on whatsapp" href="https://api.whatsapp.com/send?text=AI%20%e5%8d%8f%e4%bd%9c%e5%bc%80%e5%8f%91%e7%9a%84%e9%aa%8c%e6%94%b6%e7%9b%b2%e5%8c%ba%ef%bc%9a169%20%e4%b8%aa%e6%b5%8b%e8%af%95%e5%85%a8%e8%bf%87%ef%bc%8c16%20%e5%a4%84%e9%81%97%e6%bc%8f%e6%9c%aa%e6%8d%95%e8%8e%b7%20-%20https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获 on telegram" href="https://telegram.me/share/url?text=AI%20%e5%8d%8f%e4%bd%9c%e5%bc%80%e5%8f%91%e7%9a%84%e9%aa%8c%e6%94%b6%e7%9b%b2%e5%8c%ba%ef%bc%9a169%20%e4%b8%aa%e6%b5%8b%e8%af%95%e5%85%a8%e8%bf%87%ef%bc%8c16%20%e5%a4%84%e9%81%97%e6%bc%8f%e6%9c%aa%e6%8d%95%e8%8e%b7&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share AI 协作开发的验收盲区：169 个测试全过，16 处遗漏未捕获 on ycombinator" href="https://news.ycombinator.com/submitlink?t=AI%20%e5%8d%8f%e4%bd%9c%e5%bc%80%e5%8f%91%e7%9a%84%e9%aa%8c%e6%94%b6%e7%9b%b2%e5%8c%ba%ef%bc%9a169%20%e4%b8%aa%e6%b5%8b%e8%af%95%e5%85%a8%e8%bf%87%ef%bc%8c16%20%e5%a4%84%e9%81%97%e6%bc%8f%e6%9c%aa%e6%8d%95%e8%8e%b7&u=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://miss-you.github.io/>Yousa Driven Development | YDD</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>