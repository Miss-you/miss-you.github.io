<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘 | Yousa Driven Development | YDD</title><meta name=keywords content="AI,Prompt Engineering,软件工程,测试,代码审查,Rust,TypeScript"><meta name=description content="169 个测试全过，功能却完全失效。本文解剖一个真实任务的四层验收漏斗，揭示多层架构中横向传播遗漏的本质问题——以及不同 Prompt 策略如何决定验收效率。"><meta name=author content="Miss-you"><link rel=canonical href=https://miss-you.github.io/posts/20260218-ai-collaboration-acceptance-blindspots/><link crossorigin=anonymous href=/assets/css/stylesheet.90ccfe940c2ebacfe29cf6c094281c8c148bd718511cde00be68d330109118be.css integrity="sha256-kMz+lAwuus/inPbAlCgcjBSL1xhRHN4AvmjTMBCRGL4=" rel="preload stylesheet" as=style><link rel=icon href=https://miss-you.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://miss-you.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://miss-you.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://miss-you.github.io/apple-touch-icon.png><link rel=mask-icon href=https://miss-you.github.io/safari-pinned-tab.svg><meta name=theme-color content="#f4f3ee"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://miss-you.github.io/posts/20260218-ai-collaboration-acceptance-blindspots/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Noto+Serif+SC:wght@400;600;700;900&family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel=stylesheet><meta property="og:url" content="https://miss-you.github.io/posts/20260218-ai-collaboration-acceptance-blindspots/"><meta property="og:site_name" content="Yousa Driven Development | YDD"><meta property="og:title" content="不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘"><meta property="og:description" content="169 个测试全过，功能却完全失效。本文解剖一个真实任务的四层验收漏斗，揭示多层架构中横向传播遗漏的本质问题——以及不同 Prompt 策略如何决定验收效率。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-18T13:12:00+08:00"><meta property="article:modified_time" content="2026-02-18T18:03:55+08:00"><meta property="article:tag" content="AI"><meta property="article:tag" content="Prompt Engineering"><meta property="article:tag" content="软件工程"><meta property="article:tag" content="测试"><meta property="article:tag" content="代码审查"><meta property="article:tag" content="Rust"><meta name=twitter:card content="summary"><meta name=twitter:title content="不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘"><meta name=twitter:description content="169 个测试全过，功能却完全失效。本文解剖一个真实任务的四层验收漏斗，揭示多层架构中横向传播遗漏的本质问题——以及不同 Prompt 策略如何决定验收效率。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://miss-you.github.io/posts/"},{"@type":"ListItem","position":2,"name":"不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘","item":"https://miss-you.github.io/posts/20260218-ai-collaboration-acceptance-blindspots/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘","name":"不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘","description":"169 个测试全过，功能却完全失效。本文解剖一个真实任务的四层验收漏斗，揭示多层架构中横向传播遗漏的本质问题——以及不同 Prompt 策略如何决定验收效率。","keywords":["AI","Prompt Engineering","软件工程","测试","代码审查","Rust","TypeScript"],"articleBody":"不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘 Tokscale 是一个开源的 AI 编程助手用量统计工具。它扫描本地各 AI 编程助手（Claude Code、Codex CLI、Gemini CLI 等）的会话文件，解析每次对话的 token 消耗量并汇总成本。技术上，Rust Core 负责解析各家助手的本地会话格式并提取 token 数据，TypeScript CLI/TUI/Frontend 负责过滤、展示和提交统计结果。\nTypeScript 编译零错误，clippy 零 warning，CLI 返回正确数据。AI 报告「代码完成」。\nsubmit 功能完全失效。前端校验拒绝含新数据源的提交请求。文档多处描述与代码不一致。这些问题在首轮验收中全部隐形——不是检查者忽略，而是现有验证手段从结构上无法触及。\n测试全绿只证明覆盖了多少，不证明质量。一个新增枚举值需要在 26 个触点注册，约 8 个缺失会触发编译错误，剩余 18 个全部遗漏也编译照过、测试照绿，功能链路静默断裂在中间层。遗漏是一种 absence——在缺乏穷尽匹配约束的代码层中，absence 不报错。\n本文解剖一个真实任务：为 Tokscale 添加第 10 个数据源（Kimi），28 个文件修改、约 300 行新增 Rust 代码、横跨 6 个架构层。AI 首轮交付后，第一轮验收发现 0 个问题，第二轮发现 12 处遗漏，第三轮追出 3 处——每一层用不同的验证方法捕获前一层的盲区。\n本文同时复盘了每一轮验收背后的 Prompt——人类如何提问，直接决定了 AI 能暴露多少盲区。同一个 AI，面对不同的提问方式，交出的答案质量天差地别。\n读完本文你会了解：测试全绿为什么不等于功能完整；四层互补的验收手段如何系统性地捕获遗漏；哪些 Prompt 策略有效、哪些无效；以及如何在设计阶段就预防大部分问题。\n各章节速览：\n多层架构中的「枚举值传播」问题——问题是什么：26 个触点、6 层架构、编译器只保护其中 8 个 实现 Prompt 复盘——AI 的完成度为什么跟着编译器走而非计划走，以及基准对比应前置到设计阶段 第一层 ~ 第四层——四种验收手段的原理、实际 Prompt、发现了什么、漏掉了什么 从验收兜底到设计预防——工作流和代码架构两个层面的预防策略 闭环——三条可复述的原则 + 可直接复用的 Prompt 模板 多层架构中的「枚举值传播」问题 Tokscale 的架构分为 6 层，从底层的 Rust Core 解析器一直延伸到最上层的文档：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 graph TD subgraph compiler_zone [\"编译器保护区——遗漏即报错\"] L1[\"Layer 1: Rust Core Parserkimi.rs\"] L2[\"Layer 2: Rust Scanner + Pipelinescanner.rs, lib.rs\"] end subgraph silent_zone [\"静默区——遗漏不报错\"] L3[\"Layer 3: TypeScript CLIcli.ts, submit.ts, graph-types.ts\"] L4[\"Layer 4: TUI Displaytypes, colors, Footer\"] L5[\"Layer 5: Frontendvalidation, constants, SourceLogo\"] L6[\"Layer 6: DocumentationREADME x 4\"] end L1 --\u003e|\"UnifiedMessage\"| L2 L2 --\u003e|\"ParsedMessages kimiCount\"| L3 L3 --\u003e|\"SourceType = kimi\"| L4 L4 --\u003e|\"badge, hotkey, color\"| L5 L5 --\u003e|\"Zod schema, display config\"| L6 style compiler_zone fill:#e8f5e9,stroke:#2e7d32 style silent_zone fill:#fff3e0,stroke:#e65100 每新增一个数据源，6 层中共 26 个触点需要添加对应逻辑。以 scanner.rs 中的 ScanResult 为例，每个数据源各有一个文件列表字段：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #[derive(Debug, Default)] pub struct ScanResult { pub opencode_files: Vec\u003cPathBuf\u003e, pub opencode_db: Option\u003cPathBuf\u003e, pub claude_files: Vec\u003cPathBuf\u003e, pub codex_files: Vec\u003cPathBuf\u003e, pub gemini_files: Vec\u003cPathBuf\u003e, pub cursor_files: Vec\u003cPathBuf\u003e, pub amp_files: Vec\u003cPathBuf\u003e, pub droid_files: Vec\u003cPathBuf\u003e, pub openclaw_files: Vec\u003cPathBuf\u003e, pub pi_files: Vec\u003cPathBuf\u003e, pub kimi_files: Vec\u003cPathBuf\u003e, // ← 第 10 个数据源 } 这种模式下，kimi_files 需要出现在 ScanResult 的定义、total_files() 的求和、all_files() 的遍历、scan_all_sources() 的扫描和聚合等多处。仅 scanner.rs 一个文件就占 5 个触点。\n26 个触点中，约 8 个遗漏会导致编译失败——ScanResult 缺字段、SessionType 缺枚举值（报 non-exhaustive pattern）、ParsedMessages 缺计数字段，编译器直接拦截。剩余约 18 个触点，遗漏后编译通过、测试通过，功能却不完整：submit.ts 的 hasFilter 不检查 options.kimi，--kimi 参数定义了但不生效；前端 z.enum 不包含 \"kimi\"，含 Kimi 数据的提交被校验拒绝。\n26 个触点在各层的分布：\n架构层 触点数 编译器保护 AI 首轮完成 遗漏 发现层 Rust Core (L1-L2) 8 全部强制 8 0 — TypeScript CLI (L3) 6 部分（可选参数不强制） 3 3 层2 + 层3 TUI (L4) 4 无 2 2 层2 Frontend (L5) 5 无 1 4 层2 Docs (L6) 3 无 0 3 层2 合计 26 ~8 14 12 加上第三层 3 处行级遗漏和第四层 1 处外部数据错误，总计 16 处修复。Rust 层零遗漏，TypeScript/Frontend/Docs 层遗漏集中。\n实现 Prompt 复盘：计划的覆盖范围 ≠ 实现的覆盖范围 实现阶段的核心 Prompt 是一条探索性指令：\n1 2 实现以下计划：为 Tokscale 添加 Kimi CLI 支持 [附带详细的技术方案、任务清单、验收标准] Prompt 包含完整修改范围、6 层触点清单、可执行验收标准。但计划覆盖范围和实现覆盖范围是两回事——AI 实际交付中，Rust Core 层 8 个触点全部正确完成（kimi.rs、scanner.rs、lib.rs、aliases.rs），TypeScript/Frontend/Docs 层约 18 个触点只完成 6 个，遗漏 12 个。\n分布并非随机——探索性 Prompt 的结构性局限在此：AI 的完成判定依赖环境反馈，而非计划清单。编译器在 Rust 端充当「隐形验收官」，ScanResult 缺字段就编译不过，SessionType 少枚举值就报 non-exhaustive pattern，AI 被迫补齐。TypeScript 端的可选类型（kimi?: boolean）和运行时校验（z.enum）不在编译期发出信号，遗漏照样通过，AI 停在「编译通过」的节点上。计划说「修改 28 个文件」，编译器只强制 8 个，AI 做到 14 个——多出 6 个靠上下文理解完成，但编译器反馈的有无仍是 Rust 100% vs TypeScript 大量遗漏的最显著分界。剩余 12 个触点靠人类验收发现。\n回头看，这是最值得反思的决策点。第二轮验收用基准对比一次性发现 12 处遗漏——但同样的方法完全可以前移到方案设计阶段。新增 provider 本质上是「在已有 provider 的所有出现位置添加新值」，grep 穷举出现位置就能生成触点清单。前移这一步，12 处遗漏大部分根本不会发生。具体做法见「工作流预防」一节。\n第一层：自动化测试的天花板 AI 完成首轮实现后，跑完全套自动化验证，6 项检查全部通过：\n1 2 3 4 5 6 7 8 $ cargo build ✅ 无 error $ cargo test ✅ 169 passed, 0 failed $ cargo clippy ✅ 0 new warning $ bun run build:cli ✅ TypeScript 编译通过 $ bun run cli -- sources ✅ 显示 Kimi CLI（674 messages） $ bun run cli -- models --kimi --json ✅ 返回正确数据 这 6 项检查为什么没有发现 12 处遗漏？\n编译器检查纵向的类型一致性，而非横向的传播完整性。cargo build 能检测 ScanResult 缺 kimi_files（引用不存在的字段则编译失败），但无法检测 submit.ts 的 hasFilter 是否包含 options.kimi——因为 kimi 在 SubmitOptions 中是可选的：\n1 2 3 4 5 6 7 8 interface SubmitOptions { opencode?: boolean; claude?: boolean; codex?: boolean; // ... 省略其他 source kimi?: boolean; // ← 可选参数，不传 = undefined since?: string; } cli.ts 调用 submit({...}) 时不传 kimi: options.kimi，TypeScript 不报错——不传等于 undefined，hasFilter 不触发，走默认路径。--kimi 参数存在但无效果，零运行时错误。\n前端类似。z.enum 是运行时校验，只在提交 source: \"kimi\" 时触发。测试只走读取路径（models --kimi --json），不走提交路径，enum 少一项也不会发现。\n1 2 3 4 // source 字段的合法值全部硬编码在此——列表残缺即校验失败 source: z.enum([\"opencode\", \"claude\", \"codex\", \"gemini\", \"cursor\", \"amp\", \"droid\", \"openclaw\", \"pi\"]), // ↑ 缺少 \"kimi\"，测试只走读取路径，从未触发这条校验 SOP 自检 Prompt 的失效 测试全绿后，第一个直觉是让 AI 自检：\n1 2 3 1. 代码完成了吗？ 2. 你列的验收列表这里，完成情况如何，包括存量用例运行，以及新增的单元测试等等 3. 现在还有哪些没完成呢？请你检查下 AI 随后启动两个并行 Subagent 跑全量验证：cargo test + cargo clippy + 6 条 CLI 集成测试。结果：0 个结构性遗漏。\n这个 Prompt 为什么失效？AI 的自检逻辑和实现逻辑共享同一个盲区——两者都沿纵向路径检查（能编译吗？测试能跑吗？），而不沿横向路径检查（\"kimi\" 是否出现在所有 26 个触点？）。用工程术语说，这是「共模失效」（common-mode failure）：审计者和被审计者共享同一套假设。但这不是 AI 能力的上限——换一种 Prompt（基准对比），同一个 AI 就能发现全部 12 处遗漏。问题不在 AI「看不到」，而在于没有外部参照物时，它不知道往哪里看。\n两种模式的对比：\n1 2 3 4 5 6 7 8 9 10 11 12 13 graph LR subgraph common_mode [\"共模失效：AI 自检\"] A1[\"AI 编码盲区：TypeScript 可选参数\"] --\u003e A2[\"AI 自检盲区：TypeScript 可选参数\"] A2 --\u003e|\"共享盲区→ 发现 0 处\"| A3[\"❌ 遗漏通过\"] end subgraph external_ref [\"外部参照物：基准对比\"] B1[\"AI 编码遗漏 12 处\"] --\u003e B2[\"Codex 实现（完整参照物）\"] B2 --\u003e|\"逐项匹配→ 发现 12 处\"| B3[\"✅ 遗漏暴露\"] end style common_mode fill:#fff3e0,stroke:#e65100 style external_ref fill:#e8f5e9,stroke:#2e7d32 可选参数默默缺席、运行时校验从未触发——这两类遗漏需要不同的检测手段。自动化测试和 AI 自检都沿纵向工作：验证已有代码的行为，而非审计应有代码的存在。\n第二层：基准对比法——以 Codex 为镜 Codex 已完整实现，Codex 出现的每个位置，Kimi 也需要出现：\n1 2 # Rust 侧由编译器保证，遗漏集中在 TypeScript/Frontend 层 $ grep -rn '\"codex\"' packages/cli/src/ packages/frontend/src/ 结果：一次性暴露 12 处遗漏。以 validation/submission.ts 为例，修复前后的对比：\n1 2 3 4 5 6 7 8 9 10 11 // 修复前——z.enum 缺少 \"kimi\" source: z.enum([ \"opencode\", \"claude\", \"codex\", \"gemini\", \"cursor\", \"amp\", \"droid\", \"openclaw\", \"pi\" ]), // 修复后 source: z.enum([ \"opencode\", \"claude\", \"codex\", \"gemini\", \"cursor\", \"amp\", \"droid\", \"openclaw\", \"pi\", \"kimi\" // ← 修复点 ]), 文件中两处 z.enum（SourceContributionSchema 和 DataSummarySchema）都遗漏了 \"kimi\"——用户提交含 Kimi 数据的报告时，Zod 校验在 source 字段失败，拦截请求或触发 400。其余遗漏分布在 submit.ts（4 处：类型定义、过滤逻辑、数组填充）、前端 types.ts、constants.ts、SourceLogo.tsx 和 README。\n基准对比 Prompt 的设计逻辑 触发这轮发现的 Prompt：\n1 2 3 4 5 6 7 8 9 以 Codex 作为基准，逐项列出所有修改点： 1. Core 解析链路：模块注册、扫描、计数、汇总 2. CLI 源类型与过滤：--codex、source union、默认 source 列表 3. TUI 交互与显示：source 类型、底部来源 badge、快捷键映射 4. Submit/社交链路：提交侧 source 过滤 + 服务端 schema 验证 5. 前端展示链路：frontend source type、名称/图标/颜色映射 6. 文档：来源列表、功能描述、筛选说明、Windows 路径表 反推 Kimi 是否一一对应。 这条 Prompt 是全流程中 ROI 最高的验收手段（一条指令发现 12 处遗漏）。它引入了外部参照物——Codex 的已有实现——绕过共模失效。「代码完整吗？」是主观判断题，AI 只能依赖自己的认知回答；「Codex 出现在这 6 个位置，Kimi 是否也出现？」是客观匹配题，AI 只需字符串搜索和逐项比对。\n另一个设计细节：预先按功能域划分 6 个类别，而非「搜一下 codex 和 kimi 的对比」。分类框架引导 AI 在每个架构层逐项比对，避免找到几处后就停止搜索。12 处遗漏分布在 Submit、Frontend、Docs 三个功能域——没有分类框架，AI 可能发现 Submit 的 4 处后就报告「已修复」。\n基准对比检测的不是「代码对不对」，而是「代码全不全」——参照物提供了「全」的标准。但它隐含一个假设：Kimi 在某个文件中出现了，就认为该文件完整。下一层打破了这个假设。\n无基准可对照时的替代方案 没有同类功能可对照时，三种替代思路：\n触点清单驱动：预先列出新增功能需要出现的所有结构位置（类型定义、枚举值、配置映射、校验规则、文档），要求 AI 对每个位置给出文件路径 + 行号 + 修改片段。清单本身充当参照物。 结构位搜索：grep 结构标记——SourceType、z.enum、.option(、Record\u003c——找到所有需要包含新值的代码结构，逐个检查。 契约对比：用 OpenAPI schema、TypeScript 接口定义或 Zod schema 作为完整性标准，对齐契约而非实现。 共同点：为 AI 提供外部参照，避免 AI 用自己的认知定义完整性。\n第三层：端到端调用链追踪 基准对比修复 12 处后，submit.ts 内部已补齐。但追踪 --kimi 的完整数据流——调用链在中间断了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 sequenceDiagram participant User as 用户输入 participant CLI as cli.ts participant Submit as submit.ts participant API as API 请求 User-\u003e\u003eCLI: --kimi Note over CLI: .option(\"--kimi\", ...) ✅ 定义正确 CLI-\u003e\u003eSubmit: submit({ opencode, claude, ..., since }) Note over CLI,Submit: ❌ 漏传 kimi: options.kimi Note over Submit: if (options.kimi) → undefined不触发过滤，走默认路径 Submit-\u003e\u003eAPI: 全量数据（非 Kimi 过滤） Note over API: --kimi 参数无效果 两端各自正确，中段断裂：cli.ts 调用 submit({...}) 时未传 kimi: options.kimi。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // cli.ts submit 命令的 action（修复前） await submit({ opencode: options.opencode, claude: options.claude, codex: options.codex, gemini: options.gemini, cursor: options.cursor, amp: options.amp, droid: options.droid, openclaw: options.openclaw, pi: options.pi, // kimi: options.kimi, ← 缺失 since: options.since, until: options.until, year: options.year, dryRun: options.dryRun, }); kimi 在 SubmitOptions 中是可选参数，不传就是 undefined。hasFilter 得到 undefined，不触发过滤，走全量提交路径。功能表面正常，数据能提交，但 --kimi 过滤完全无效。\n为什么基准对比没发现？检查者看到 cli.ts 中已存在 \"kimi\"（在 .option(\"--kimi\", ...) 中），就认为文件已覆盖，没有追踪同一文件内的其他触点。这是执行粒度问题：grep 退化为文件级扫描（「有 kimi 就算过」）时，行级遗漏漏网。捕获这类问题需要沿数据流逐段追踪，验证每段连通。\n第四层：质疑外部数据 前三层解决的都是代码问题，但还有一类问题藏在代码引用的外部事实中。Tokscale 需要模型定价来计算成本。Kimi CLI 使用 kimi-for-coding 作为模型标识，AI 在 aliases.rs 中映射到定价模型：\n1 2 // 推断值——未经官方定价文档核实 m.insert(\"kimi-for-coding\", \"kimi-k2-thinking\"); kimi-k2-thinking 的 output 定价 $2.50/M tokens。不追问的话，没有理由怀疑它。\n一句 Prompt 切换 AI 的认知模式 追问的 Prompt 是：\n1 2 代码修改中，像是 kimi 模型成本这种比较细节的问题， 你是如何获取的呢？你应该只能通过联网的方式获取到这个数据吧？请你自检下 AI 坦承这是根据模型命名推断的。联网核实后，实际对应 kimi-k2.5，output 定价 $3.00/M tokens——偏差 20%。\n1 2 // 官方定价页核实：kimi-for-coding → kimi-k2.5，$3.00/M output m.insert(\"kimi-for-coding\", \"kimi-k2.5\"); 改动只有一行，但漏过则所有 Kimi 用户的成本计算偏低 20%。\n这条 Prompt 在四轮验收中单位字数的 ROI 最高——一句话逼出一个隐蔽的事实性错误。\n它没有问「定价对不对？」——那样问，AI 会发现 $2.50 在合理范围内，回答「对的」。它问「你是如何获取的？」——迫使 AI 从「给答案」切换到「评估置信度」：我是从官方文档查到的，还是根据命名规律推断的？一旦进入这个模式，AI 主动暴露推理中的不确定性，而非把不确定性包装成确定答案。\n后半句「你应该只能通过联网的方式获取到这个数据吧？」收窄退路——预设了判断标准：这类数据的唯一可靠来源是联网查询。AI 无法在此前提下声称推断可靠，只能转向联网验证。\nAI 面对不确定的事实时倾向于给出「合理推断」而非拒绝回答。kimi-k2-thinking 和 kimi-k2.5 都属 K2 系列，$2.50 和 $3.00 差距不大，不触发直觉警报。对于定价、API endpoint、版本号等外部事实，追问来源和验证「值合不合理」是两件独立的事。\n从验收兜底到设计预防 前四层解决「如何发现遗漏」。能不能让遗漏更难发生？\n工作流预防：基准对比前置到设计阶段 对于「新增同类实体」类任务（新增 provider、权限角色、支付方式），写技术方案前先跑两条命令：\n1 2 $ grep -rn '\"codex\"' packages/ $ grep -rn '\"claude\"' packages/ 两个已有实体的全部出现位置就是新实体的触点清单。用两个参照而非一个，因为不同实体的实现路径不完全重叠——codex 在 submit 路径有触点而 claude 没有，交叉比对更广。清单写进技术方案，AI 拿到的就不是「添加 Kimi 支持」这样的模糊目标，而是精确到文件和行号的 26 个触点清单。编译器保护 8 个，清单保护剩余 18 个，验收漏斗的压力从 12 处降到接近 0。\n同样的 grep，方案阶段跑一次是预防，验收阶段跑一次是修补，成本差一个数量级。不改代码架构，只改工作流顺序。\n代码架构预防：让类型系统拦截遗漏 差异的根源不在 AI 的注意力，而在类型系统对 absence 的容忍度。Rust 的 match 穷尽检查把「缺失」变成编译错误；TypeScript 的可选参数让「缺失」静默通过。在 TypeScript 侧建立类似的强制约束，编写阶段就能拦截部分遗漏。三个方向：\n单一事实源（Single Source of Truth）。当前 SourceType 合法值分散在 CLI union、前端 z.enum、constants.ts、submit.ts 等多处，各自独立维护。集中到一个常量，其他位置从常量派生，新增 source 只改一处。26 个触点不会变成 1 个，但字符串字面量收敛为一个源头。\n穷尽映射（Exhaustive Mapping）。Record 或 satisfies 可以强制映射每个 source。把颜色配置从 if-else 链改为 Record，缺一个 source 就类型报错——在 TypeScript 侧复现 Rust match 的穷尽检查，把「横向传播遗漏」从运行时问题变成编译期问题。\n关键路径 E2E 冒烟测试。本案例中测试只覆盖读取路径（sources、models --kimi），未覆盖提交路径（submit --kimi）。为「新增数据源」建立固定冒烟用例——parse → cli filter → submit → frontend validate——第三层「人工追链」的成本就能转化为自动化测试。\n工作流预防和代码架构预防不替代四层验收漏斗，而是从源头减少漏斗拦截的问题数量。前者改变做事的顺序，后者改变代码的结构——两者共同降低兜底压力。\n闭环：四层漏斗模型与 Prompt 策略 每一层用不同的检测原理过滤不同类型的问题，前一层的假阴性恰好落在后一层的检测范围内。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 graph TD IN[\"AI 交付代码16 处潜在问题\"] --\u003e L1 L1[\"🔬 层 1：自动化测试 + AI 自检检测原理：纵向逻辑验证发现：0 处 | 泄漏：16 处\"] L1 --\u003e|\"16 处泄漏（横向遗漏全部漏过）\"| L2 L2[\"🔍 层 2：基准对比检测原理：字符串匹配 × 外部参照物发现：12 处 | 泄漏：4 处\"] L2 --\u003e|\"4 处泄漏（行级遗漏 + 外部数据）\"| L3 L3[\"🔗 层 3：端到端追踪检测原理：调用链逐段连通性验证发现：3 处 | 泄漏：1 处\"] L3 --\u003e|\"1 处泄漏（事实性错误）\"| L4 L4[\"❓ 层 4：外部数据质疑检测原理：追问数据来源与置信度发现：1 处 | 泄漏：0 处\"] L4 --\u003e OUT[\"✅ 16 处全部修复\"] style L1 fill:#ffebee,stroke:#c62828 style L2 fill:#e8f5e9,stroke:#2e7d32 style L3 fill:#e3f2fd,stroke:#1565c0 style L4 fill:#fff3e0,stroke:#e65100 style OUT fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px 各层 Prompt 策略与耗时：\n层级 验证手段 Prompt 策略 发现 耗时（估） 0 实现指令 探索性 Prompt + 详细计划 — ~40 min 1 自动化测试 + AI 自检 「完成了吗？请你检查下」 0（假阴性） ~5 min 2 基准对比 以 Codex 为参照物，分 6 域逐项比对 12 ~10 min 3 端到端追踪 人工逐段追踪调用链 3 ~15 min 4 外部数据质疑 「这个数据你是如何获取的？」 1 ~2 min 各层检测原理不同，形成互补：纵向逻辑验证 → 字符串匹配 → 调用链追踪 → 数据源头验证。理论上某一层粒度足够细时可以覆盖下一层的部分范围，但实际操作中每层倾向于在自身的抽象粒度上工作，层间互补因此成立。\nROI 最高的是层 2（10 分钟，12 处）和层 4（2 分钟，1 处致命错误）。层 1 投入产出为零但仍是必要的准入门槛。层 3 耗时最长、发现最少，却捕获了跨文件参数传递断裂。\n三条原则 不要让 AI 批改自己的试卷。自检 Prompt 导致共模失效——审计者和被审计者共享盲区。你写完文章自己检查三遍看不到错别字，朋友 30 秒就圈出来——不是朋友更仔细，而是你的大脑在用写作时的同一套预期做审查。AI 自检同理。验收引入外部参照物（已有实现、触点清单、官方文档），把主观判断题转换为客观匹配题。 问「怎么来的」而非「对不对」。前者攻击推理链条，迫使 AI 暴露不确定性；后者让 AI 辩护结果。古罗马验收石桥不审查图纸，而是让工程师站在桥下——追问过程比审查结论有效得多。涉及外部事实的代码（定价、API、版本号），这是唯一可靠的检测手段。 absence 不报错，所以要主动搜索 absence。测试验证「已有代码做了什么」，而非「应有代码是否存在」。泰坦尼克号的检查员逐项核查了锅炉、铆钉、电报机，全部通过——但没有检查表要求核验「救生艇数量是否匹配乘客总数」。遗漏的检查项不会自己举手。在弱约束语言层中，grep + 参照物主动搜索「应出现但没出现」的值，比等运行时报错高效得多。 实践清单 层 1：自动化验证做基线\n运行全量测试和 lint，确认未引入回归。绿色结果 = 已有功能未被破坏。\n层 2：基准对比做横向覆盖\n选同类功能作参照，按功能域逐项比对：\n1 2 3 4 5 6 7 以 [已有功能] 作为基准，逐项列出所有修改点： 1. [功能域1]：[具体检查项] 2. [功能域2]：[具体检查项] ... 对每个位置，给出：文件路径、行号、当前代码片段。 反推 [新增功能] 是否一一对应。未对齐的逐条列出。 所有功能域检查完毕后再给出总结。 按功能域分类避免 AI 过早停止搜索；要求「文件路径 + 行号」防止文件级扫描退化。\n层 3：端到端追踪做连通性\n沿调用链从用户输入追踪到最终输出，逐段验证参数传递。重点关注可选参数（? 和 Option）。每个新增参数追踪三段：定义处 → 传递处 → 使用处。\n层 4：外部数据追问来源\n对涉及外部事实（定价、API endpoint、版本号）的代码：\n1 2 3 [具体代码位置] 中的 [具体值]，你是如何获取的？ 是从官方文档查到的，还是根据命名规律推断的？ 如果是推断，请联网核实后给出修正。 169 个测试、0 个失败——这是起点。三条原则、四层漏斗、16 处修复——这是设计预防、验收手段和提问策略共同填补的距离。\n","wordCount":"1456","inLanguage":"zh","datePublished":"2026-02-18T13:12:00+08:00","dateModified":"2026-02-18T18:03:55+08:00","author":{"@type":"Person","name":"Miss-you"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://miss-you.github.io/posts/20260218-ai-collaboration-acceptance-blindspots/"},"publisher":{"@type":"Organization","name":"Yousa Driven Development | YDD","logo":{"@type":"ImageObject","url":"https://miss-you.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://miss-you.github.io/ accesskey=h title="Yousa Driven Development | YDD (Alt + H)">Yousa Driven Development | YDD</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://miss-you.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://miss-you.github.io/archives title=归档><span>归档</span></a></li><li><a href=https://miss-you.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://miss-you.github.io/tools/ title=工具><span>工具</span></a></li><li><a href=https://miss-you.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://github.com/Miss-you title=GitHub><span>GitHub</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://miss-you.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://miss-you.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘</h1><div class=post-description>169 个测试全过，功能却完全失效。本文解剖一个真实任务的四层验收漏斗，揭示多层架构中横向传播遗漏的本质问题——以及不同 Prompt 策略如何决定验收效率。</div><div class=post-meta><span title='2026-02-18 13:12:00 +0800 +0800'>二月 18, 2026</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;12294 字&nbsp;·&nbsp;Miss-you&nbsp;|&nbsp;<a href=https://github.com/Miss-you/miss-you.github.io/tree/main/content/posts/20260218-ai-collaboration-acceptance-blindspots/index.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#多层架构中的枚举值传播问题>多层架构中的「枚举值传播」问题</a></li><li><a href=#实现-prompt-复盘计划的覆盖范围--实现的覆盖范围>实现 Prompt 复盘：计划的覆盖范围 ≠ 实现的覆盖范围</a></li><li><a href=#第一层自动化测试的天花板>第一层：自动化测试的天花板</a><ul><li><a href=#sop-自检-prompt-的失效>SOP 自检 Prompt 的失效</a></li></ul></li><li><a href=#第二层基准对比法以-codex-为镜>第二层：基准对比法——以 Codex 为镜</a><ul><li><a href=#基准对比-prompt-的设计逻辑>基准对比 Prompt 的设计逻辑</a></li><li><a href=#无基准可对照时的替代方案>无基准可对照时的替代方案</a></li></ul></li><li><a href=#第三层端到端调用链追踪>第三层：端到端调用链追踪</a></li><li><a href=#第四层质疑外部数据>第四层：质疑外部数据</a><ul><li><a href=#一句-prompt-切换-ai-的认知模式>一句 Prompt 切换 AI 的认知模式</a></li></ul></li><li><a href=#从验收兜底到设计预防>从验收兜底到设计预防</a><ul><li><a href=#工作流预防基准对比前置到设计阶段>工作流预防：基准对比前置到设计阶段</a></li><li><a href=#代码架构预防让类型系统拦截遗漏>代码架构预防：让类型系统拦截遗漏</a></li></ul></li><li><a href=#闭环四层漏斗模型与-prompt-策略>闭环：四层漏斗模型与 Prompt 策略</a><ul><li><a href=#三条原则>三条原则</a></li><li><a href=#实践清单>实践清单</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=不要让-ai-批改自己的试卷--一次-16-处遗漏的协作复盘>不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘<a hidden class=anchor aria-hidden=true href=#不要让-ai-批改自己的试卷--一次-16-处遗漏的协作复盘>#</a></h1><blockquote><p><a href=https://github.com/synaptic-dev/tokscale>Tokscale</a> 是一个开源的 AI 编程助手用量统计工具。它扫描本地各 AI 编程助手（Claude Code、Codex CLI、Gemini CLI 等）的会话文件，解析每次对话的 token 消耗量并汇总成本。技术上，Rust Core 负责解析各家助手的本地会话格式并提取 token 数据，TypeScript CLI/TUI/Frontend 负责过滤、展示和提交统计结果。</p></blockquote><p>TypeScript 编译零错误，<code>clippy</code> 零 warning，CLI 返回正确数据。AI 报告「代码完成」。</p><p><code>submit</code> 功能完全失效。前端校验拒绝含新数据源的提交请求。文档多处描述与代码不一致。这些问题在首轮验收中全部隐形——不是检查者忽略，而是现有验证手段从结构上无法触及。</p><p>测试全绿只证明覆盖了多少，不证明质量。一个新增枚举值需要在 26 个触点注册，约 8 个缺失会触发编译错误，剩余 18 个全部遗漏也编译照过、测试照绿，功能链路静默断裂在中间层。遗漏是一种 absence——在缺乏穷尽匹配约束的代码层中，absence 不报错。</p><p>本文解剖一个真实任务：为 Tokscale 添加第 10 个数据源（Kimi），28 个文件修改、约 300 行新增 Rust 代码、横跨 6 个架构层。AI 首轮交付后，第一轮验收发现 0 个问题，第二轮发现 12 处遗漏，第三轮追出 3 处——每一层用不同的验证方法捕获前一层的盲区。</p><p>本文同时复盘了每一轮验收背后的 Prompt——人类如何提问，直接决定了 AI 能暴露多少盲区。同一个 AI，面对不同的提问方式，交出的答案质量天差地别。</p><p><strong>读完本文你会了解</strong>：测试全绿为什么不等于功能完整；四层互补的验收手段如何系统性地捕获遗漏；哪些 Prompt 策略有效、哪些无效；以及如何在设计阶段就预防大部分问题。</p><p><strong>各章节速览</strong>：</p><ul><li><strong>多层架构中的「枚举值传播」问题</strong>——问题是什么：26 个触点、6 层架构、编译器只保护其中 8 个</li><li><strong>实现 Prompt 复盘</strong>——AI 的完成度为什么跟着编译器走而非计划走，以及基准对比应前置到设计阶段</li><li><strong>第一层 ~ 第四层</strong>——四种验收手段的原理、实际 Prompt、发现了什么、漏掉了什么</li><li><strong>从验收兜底到设计预防</strong>——工作流和代码架构两个层面的预防策略</li><li><strong>闭环</strong>——三条可复述的原则 + 可直接复用的 Prompt 模板</li></ul><hr><h2 id=多层架构中的枚举值传播问题>多层架构中的「枚举值传播」问题<a hidden class=anchor aria-hidden=true href=#多层架构中的枚举值传播问题>#</a></h2><p>Tokscale 的架构分为 6 层，从底层的 Rust Core 解析器一直延伸到最上层的文档：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>graph</span> <span class=n>TD</span>
</span></span><span class=line><span class=cl>    <span class=n>subgraph</span> <span class=n>compiler_zone</span> <span class=p>[</span><span class=s2>&#34;编译器保护区——遗漏即报错&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>L1</span><span class=p>[</span><span class=s2>&#34;Layer 1: Rust Core Parser&lt;br/&gt;kimi.rs&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>L2</span><span class=p>[</span><span class=s2>&#34;Layer 2: Rust Scanner + Pipeline&lt;br/&gt;scanner.rs, lib.rs&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>subgraph</span> <span class=n>silent_zone</span> <span class=p>[</span><span class=s2>&#34;静默区——遗漏不报错&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>L3</span><span class=p>[</span><span class=s2>&#34;Layer 3: TypeScript CLI&lt;br/&gt;cli.ts, submit.ts, graph-types.ts&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>L4</span><span class=p>[</span><span class=s2>&#34;Layer 4: TUI Display&lt;br/&gt;types, colors, Footer&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>L5</span><span class=p>[</span><span class=s2>&#34;Layer 5: Frontend&lt;br/&gt;validation, constants, SourceLogo&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>L6</span><span class=p>[</span><span class=s2>&#34;Layer 6: Documentation&lt;br/&gt;README x 4&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>L1</span> <span class=o>--&gt;|</span><span class=s2>&#34;UnifiedMessage&#34;</span><span class=o>|</span> <span class=n>L2</span>
</span></span><span class=line><span class=cl>    <span class=n>L2</span> <span class=o>--&gt;|</span><span class=s2>&#34;ParsedMessages kimiCount&#34;</span><span class=o>|</span> <span class=n>L3</span>
</span></span><span class=line><span class=cl>    <span class=n>L3</span> <span class=o>--&gt;|</span><span class=s2>&#34;SourceType = kimi&#34;</span><span class=o>|</span> <span class=n>L4</span>
</span></span><span class=line><span class=cl>    <span class=n>L4</span> <span class=o>--&gt;|</span><span class=s2>&#34;badge, hotkey, color&#34;</span><span class=o>|</span> <span class=n>L5</span>
</span></span><span class=line><span class=cl>    <span class=n>L5</span> <span class=o>--&gt;|</span><span class=s2>&#34;Zod schema, display config&#34;</span><span class=o>|</span> <span class=n>L6</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>style</span> <span class=n>compiler_zone</span> <span class=n>fill</span><span class=p>:</span><span class=c1>#e8f5e9,stroke:#2e7d32</span>
</span></span><span class=line><span class=cl>    <span class=n>style</span> <span class=n>silent_zone</span> <span class=n>fill</span><span class=p>:</span><span class=c1>#fff3e0,stroke:#e65100</span>
</span></span></code></pre></td></tr></table></div></div><p>每新增一个数据源，6 层中共 26 个触点需要添加对应逻辑。以 <code>scanner.rs</code> 中的 <code>ScanResult</code> 为例，每个数据源各有一个文件列表字段：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[derive(Debug, Default)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>ScanResult</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>opencode_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>opencode_db</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>claude_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>codex_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>gemini_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>cursor_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>amp_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>droid_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>openclaw_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>pi_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>kimi_files</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>PathBuf</span><span class=o>&gt;</span><span class=p>,</span><span class=w>    </span><span class=c1>// ← 第 10 个数据源
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这种模式下，<code>kimi_files</code> 需要出现在 <code>ScanResult</code> 的定义、<code>total_files()</code> 的求和、<code>all_files()</code> 的遍历、<code>scan_all_sources()</code> 的扫描和聚合等多处。仅 <code>scanner.rs</code> 一个文件就占 5 个触点。</p><p>26 个触点中，约 8 个遗漏会导致编译失败——<code>ScanResult</code> 缺字段、<code>SessionType</code> 缺枚举值（报 <code>non-exhaustive pattern</code>）、<code>ParsedMessages</code> 缺计数字段，编译器直接拦截。剩余约 18 个触点，遗漏后编译通过、测试通过，功能却不完整：<code>submit.ts</code> 的 <code>hasFilter</code> 不检查 <code>options.kimi</code>，<code>--kimi</code> 参数定义了但不生效；前端 <code>z.enum</code> 不包含 <code>"kimi"</code>，含 Kimi 数据的提交被校验拒绝。</p><p>26 个触点在各层的分布：</p><table><thead><tr><th>架构层</th><th>触点数</th><th>编译器保护</th><th>AI 首轮完成</th><th>遗漏</th><th>发现层</th></tr></thead><tbody><tr><td>Rust Core (L1-L2)</td><td>8</td><td>全部强制</td><td>8</td><td>0</td><td>—</td></tr><tr><td>TypeScript CLI (L3)</td><td>6</td><td>部分（可选参数不强制）</td><td>3</td><td>3</td><td>层2 + 层3</td></tr><tr><td>TUI (L4)</td><td>4</td><td>无</td><td>2</td><td>2</td><td>层2</td></tr><tr><td>Frontend (L5)</td><td>5</td><td>无</td><td>1</td><td>4</td><td>层2</td></tr><tr><td>Docs (L6)</td><td>3</td><td>无</td><td>0</td><td>3</td><td>层2</td></tr><tr><td><strong>合计</strong></td><td><strong>26</strong></td><td><strong>~8</strong></td><td><strong>14</strong></td><td><strong>12</strong></td><td></td></tr></tbody></table><p>加上第三层 3 处行级遗漏和第四层 1 处外部数据错误，总计 16 处修复。Rust 层零遗漏，TypeScript/Frontend/Docs 层遗漏集中。</p><hr><h2 id=实现-prompt-复盘计划的覆盖范围--实现的覆盖范围>实现 Prompt 复盘：计划的覆盖范围 ≠ 实现的覆盖范围<a hidden class=anchor aria-hidden=true href=#实现-prompt-复盘计划的覆盖范围--实现的覆盖范围>#</a></h2><p>实现阶段的核心 Prompt 是一条探索性指令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>实现以下计划：为 Tokscale 添加 Kimi CLI 支持
</span></span><span class=line><span class=cl>[附带详细的技术方案、任务清单、验收标准]
</span></span></code></pre></td></tr></table></div></div><p>Prompt 包含完整修改范围、6 层触点清单、可执行验收标准。但计划覆盖范围和实现覆盖范围是两回事——AI 实际交付中，Rust Core 层 8 个触点全部正确完成（<code>kimi.rs</code>、<code>scanner.rs</code>、<code>lib.rs</code>、<code>aliases.rs</code>），TypeScript/Frontend/Docs 层约 18 个触点只完成 6 个，遗漏 12 个。</p><p>分布并非随机——探索性 Prompt 的结构性局限在此：AI 的完成判定依赖环境反馈，而非计划清单。编译器在 Rust 端充当「隐形验收官」，<code>ScanResult</code> 缺字段就编译不过，<code>SessionType</code> 少枚举值就报 <code>non-exhaustive pattern</code>，AI 被迫补齐。TypeScript 端的可选类型（<code>kimi?: boolean</code>）和运行时校验（<code>z.enum</code>）不在编译期发出信号，遗漏照样通过，AI 停在「编译通过」的节点上。计划说「修改 28 个文件」，编译器只强制 8 个，AI 做到 14 个——多出 6 个靠上下文理解完成，但编译器反馈的有无仍是 Rust 100% vs TypeScript 大量遗漏的最显著分界。剩余 12 个触点靠人类验收发现。</p><p>回头看，这是最值得反思的决策点。第二轮验收用基准对比一次性发现 12 处遗漏——但同样的方法完全可以前移到方案设计阶段。新增 provider 本质上是「在已有 provider 的所有出现位置添加新值」，<code>grep</code> 穷举出现位置就能生成触点清单。前移这一步，12 处遗漏大部分根本不会发生。具体做法见「工作流预防」一节。</p><hr><h2 id=第一层自动化测试的天花板>第一层：自动化测试的天花板<a hidden class=anchor aria-hidden=true href=#第一层自动化测试的天花板>#</a></h2><p>AI 完成首轮实现后，跑完全套自动化验证，6 项检查全部通过：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7>7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cargo build          ✅  无 error
</span></span><span class=line><span class=cl>$ cargo test           ✅  169 passed, 0 failed
</span></span><span class=line><span class=cl>$ cargo clippy         ✅  0 new warning
</span></span><span class=line><span class=cl>$ bun run build:cli    ✅  TypeScript 编译通过
</span></span><span class=line><span class=cl>$ bun run cli -- sources
</span></span><span class=line><span class=cl>                       ✅  显示 Kimi CLI（674 messages）
</span></span><span class=line><span class=cl>$ bun run cli -- models --kimi --json
</span></span><span class=line><span class=cl>                       ✅  返回正确数据
</span></span></code></pre></td></tr></table></div></div><p>这 6 项检查为什么没有发现 12 处遗漏？</p><p>编译器检查纵向的类型一致性，而非横向的传播完整性。<code>cargo build</code> 能检测 <code>ScanResult</code> 缺 <code>kimi_files</code>（引用不存在的字段则编译失败），但无法检测 <code>submit.ts</code> 的 <code>hasFilter</code> 是否包含 <code>options.kimi</code>——因为 <code>kimi</code> 在 <code>SubmitOptions</code> 中是可选的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7>7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>interface</span> <span class=nx>SubmitOptions</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>opencode?</span>: <span class=kt>boolean</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>claude?</span>: <span class=kt>boolean</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>codex?</span>: <span class=kt>boolean</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ... 省略其他 source
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>kimi?</span>: <span class=kt>boolean</span><span class=p>;</span>      <span class=c1>// ← 可选参数，不传 = undefined
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>since?</span>: <span class=kt>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>cli.ts</code> 调用 <code>submit({...})</code> 时不传 <code>kimi: options.kimi</code>，TypeScript 不报错——不传等于 <code>undefined</code>，<code>hasFilter</code> 不触发，走默认路径。<code>--kimi</code> 参数存在但无效果，零运行时错误。</p><p>前端类似。<code>z.enum</code> 是运行时校验，只在提交 <code>source: "kimi"</code> 时触发。测试只走读取路径（<code>models --kimi --json</code>），不走提交路径，enum 少一项也不会发现。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// source 字段的合法值全部硬编码在此——列表残缺即校验失败
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>source</span>: <span class=kt>z.enum</span><span class=p>([</span><span class=s2>&#34;opencode&#34;</span><span class=p>,</span> <span class=s2>&#34;claude&#34;</span><span class=p>,</span> <span class=s2>&#34;codex&#34;</span><span class=p>,</span> <span class=s2>&#34;gemini&#34;</span><span class=p>,</span> <span class=s2>&#34;cursor&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s2>&#34;amp&#34;</span><span class=p>,</span> <span class=s2>&#34;droid&#34;</span><span class=p>,</span> <span class=s2>&#34;openclaw&#34;</span><span class=p>,</span> <span class=s2>&#34;pi&#34;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl><span class=c1>// ↑ 缺少 &#34;kimi&#34;，测试只走读取路径，从未触发这条校验
</span></span></span></code></pre></td></tr></table></div></div><h3 id=sop-自检-prompt-的失效>SOP 自检 Prompt 的失效<a hidden class=anchor aria-hidden=true href=#sop-自检-prompt-的失效>#</a></h3><p>测试全绿后，第一个直觉是让 AI 自检：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. 代码完成了吗？
</span></span><span class=line><span class=cl>2. 你列的验收列表这里，完成情况如何，包括存量用例运行，以及新增的单元测试等等
</span></span><span class=line><span class=cl>3. 现在还有哪些没完成呢？请你检查下
</span></span></code></pre></td></tr></table></div></div><p>AI 随后启动两个并行 Subagent 跑全量验证：<code>cargo test</code> + <code>cargo clippy</code> + 6 条 CLI 集成测试。结果：0 个结构性遗漏。</p><p>这个 Prompt 为什么失效？AI 的自检逻辑和实现逻辑共享同一个盲区——两者都沿纵向路径检查（能编译吗？测试能跑吗？），而不沿横向路径检查（<code>"kimi"</code> 是否出现在所有 26 个触点？）。用工程术语说，这是「共模失效」（common-mode failure）：审计者和被审计者共享同一套假设。但这不是 AI 能力的上限——换一种 Prompt（基准对比），同一个 AI 就能发现全部 12 处遗漏。问题不在 AI「看不到」，而在于没有外部参照物时，它不知道往哪里看。</p><p>两种模式的对比：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>graph LR
</span></span><span class=line><span class=cl>    subgraph common_mode [&#34;共模失效：AI 自检&#34;]
</span></span><span class=line><span class=cl>        A1[&#34;AI 编码&lt;br/&gt;盲区：TypeScript 可选参数&#34;] --&gt; A2[&#34;AI 自检&lt;br/&gt;盲区：TypeScript 可选参数&#34;]
</span></span><span class=line><span class=cl>        A2 --&gt;|&#34;共享盲区&lt;br/&gt;→ 发现 0 处&#34;| A3[&#34;❌ 遗漏通过&#34;]
</span></span><span class=line><span class=cl>    end
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    subgraph external_ref [&#34;外部参照物：基准对比&#34;]
</span></span><span class=line><span class=cl>        B1[&#34;AI 编码&lt;br/&gt;遗漏 12 处&#34;] --&gt; B2[&#34;Codex 实现&lt;br/&gt;（完整参照物）&#34;]
</span></span><span class=line><span class=cl>        B2 --&gt;|&#34;逐项匹配&lt;br/&gt;→ 发现 12 处&#34;| B3[&#34;✅ 遗漏暴露&#34;]
</span></span><span class=line><span class=cl>    end
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    style common_mode fill:#fff3e0,stroke:#e65100
</span></span><span class=line><span class=cl>    style external_ref fill:#e8f5e9,stroke:#2e7d32
</span></span></code></pre></td></tr></table></div></div><p>可选参数默默缺席、运行时校验从未触发——这两类遗漏需要不同的检测手段。自动化测试和 AI 自检都沿纵向工作：验证已有代码的行为，而非审计应有代码的存在。</p><hr><h2 id=第二层基准对比法以-codex-为镜>第二层：基准对比法——以 Codex 为镜<a hidden class=anchor aria-hidden=true href=#第二层基准对比法以-codex-为镜>#</a></h2><p>Codex 已完整实现，Codex 出现的每个位置，Kimi 也需要出现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Rust 侧由编译器保证，遗漏集中在 TypeScript/Frontend 层</span>
</span></span><span class=line><span class=cl>$ grep -rn <span class=s1>&#39;&#34;codex&#34;&#39;</span> packages/cli/src/ packages/frontend/src/
</span></span></code></pre></td></tr></table></div></div><p>结果：一次性暴露 12 处遗漏。以 <code>validation/submission.ts</code> 为例，修复前后的对比：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// 修复前——z.enum 缺少 &#34;kimi&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>source</span>: <span class=kt>z.enum</span><span class=p>([</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;opencode&#34;</span><span class=p>,</span> <span class=s2>&#34;claude&#34;</span><span class=p>,</span> <span class=s2>&#34;codex&#34;</span><span class=p>,</span> <span class=s2>&#34;gemini&#34;</span><span class=p>,</span> <span class=s2>&#34;cursor&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;amp&#34;</span><span class=p>,</span> <span class=s2>&#34;droid&#34;</span><span class=p>,</span> <span class=s2>&#34;openclaw&#34;</span><span class=p>,</span> <span class=s2>&#34;pi&#34;</span>
</span></span><span class=line><span class=cl><span class=p>]),</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 修复后
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>source</span>: <span class=kt>z.enum</span><span class=p>([</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;opencode&#34;</span><span class=p>,</span> <span class=s2>&#34;claude&#34;</span><span class=p>,</span> <span class=s2>&#34;codex&#34;</span><span class=p>,</span> <span class=s2>&#34;gemini&#34;</span><span class=p>,</span> <span class=s2>&#34;cursor&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;amp&#34;</span><span class=p>,</span> <span class=s2>&#34;droid&#34;</span><span class=p>,</span> <span class=s2>&#34;openclaw&#34;</span><span class=p>,</span> <span class=s2>&#34;pi&#34;</span><span class=p>,</span> <span class=s2>&#34;kimi&#34;</span>   <span class=c1>// ← 修复点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>]),</span>
</span></span></code></pre></td></tr></table></div></div><p>文件中两处 <code>z.enum</code>（<code>SourceContributionSchema</code> 和 <code>DataSummarySchema</code>）都遗漏了 <code>"kimi"</code>——用户提交含 Kimi 数据的报告时，Zod 校验在 <code>source</code> 字段失败，拦截请求或触发 400。其余遗漏分布在 <code>submit.ts</code>（4 处：类型定义、过滤逻辑、数组填充）、前端 <code>types.ts</code>、<code>constants.ts</code>、<code>SourceLogo.tsx</code> 和 README。</p><h3 id=基准对比-prompt-的设计逻辑>基准对比 Prompt 的设计逻辑<a hidden class=anchor aria-hidden=true href=#基准对比-prompt-的设计逻辑>#</a></h3><p>触发这轮发现的 Prompt：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6>6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7>7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8>8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>以 Codex 作为基准，逐项列出所有修改点：
</span></span><span class=line><span class=cl>1. Core 解析链路：模块注册、扫描、计数、汇总
</span></span><span class=line><span class=cl>2. CLI 源类型与过滤：--codex、source union、默认 source 列表
</span></span><span class=line><span class=cl>3. TUI 交互与显示：source 类型、底部来源 badge、快捷键映射
</span></span><span class=line><span class=cl>4. Submit/社交链路：提交侧 source 过滤 + 服务端 schema 验证
</span></span><span class=line><span class=cl>5. 前端展示链路：frontend source type、名称/图标/颜色映射
</span></span><span class=line><span class=cl>6. 文档：来源列表、功能描述、筛选说明、Windows 路径表
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>反推 Kimi 是否一一对应。
</span></span></code></pre></td></tr></table></div></div><p>这条 Prompt 是全流程中 ROI 最高的验收手段（一条指令发现 12 处遗漏）。它引入了外部参照物——Codex 的已有实现——绕过共模失效。「代码完整吗？」是主观判断题，AI 只能依赖自己的认知回答；「Codex 出现在这 6 个位置，Kimi 是否也出现？」是客观匹配题，AI 只需字符串搜索和逐项比对。</p><p>另一个设计细节：预先按功能域划分 6 个类别，而非「搜一下 codex 和 kimi 的对比」。分类框架引导 AI 在每个架构层逐项比对，避免找到几处后就停止搜索。12 处遗漏分布在 Submit、Frontend、Docs 三个功能域——没有分类框架，AI 可能发现 Submit 的 4 处后就报告「已修复」。</p><p>基准对比检测的不是「代码对不对」，而是「代码全不全」——参照物提供了「全」的标准。但它隐含一个假设：Kimi 在某个文件中出现了，就认为该文件完整。下一层打破了这个假设。</p><h3 id=无基准可对照时的替代方案>无基准可对照时的替代方案<a hidden class=anchor aria-hidden=true href=#无基准可对照时的替代方案>#</a></h3><p>没有同类功能可对照时，三种替代思路：</p><ul><li><strong>触点清单驱动</strong>：预先列出新增功能需要出现的所有结构位置（类型定义、枚举值、配置映射、校验规则、文档），要求 AI 对每个位置给出文件路径 + 行号 + 修改片段。清单本身充当参照物。</li><li><strong>结构位搜索</strong>：<code>grep</code> 结构标记——<code>SourceType</code>、<code>z.enum</code>、<code>.option(</code>、<code>Record&lt;</code>——找到所有需要包含新值的代码结构，逐个检查。</li><li><strong>契约对比</strong>：用 OpenAPI schema、TypeScript 接口定义或 Zod schema 作为完整性标准，对齐契约而非实现。</li></ul><p>共同点：为 AI 提供外部参照，避免 AI 用自己的认知定义完整性。</p><hr><h2 id=第三层端到端调用链追踪>第三层：端到端调用链追踪<a hidden class=anchor aria-hidden=true href=#第三层端到端调用链追踪>#</a></h2><p>基准对比修复 12 处后，<code>submit.ts</code> 内部已补齐。但追踪 <code>--kimi</code> 的完整数据流——调用链在中间断了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14>14</a>
</span><span class=lnt id=hl-11-15><a class=lnlinks href=#hl-11-15>15</a>
</span><span class=lnt id=hl-11-16><a class=lnlinks href=#hl-11-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sequenceDiagram
</span></span><span class=line><span class=cl>    participant User as 用户输入
</span></span><span class=line><span class=cl>    participant CLI as cli.ts
</span></span><span class=line><span class=cl>    participant Submit as submit.ts
</span></span><span class=line><span class=cl>    participant API as API 请求
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    User-&gt;&gt;CLI: --kimi
</span></span><span class=line><span class=cl>    Note over CLI: .option(&#34;--kimi&#34;, ...) ✅ 定义正确
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    CLI-&gt;&gt;Submit: submit({ opencode, claude, ..., since })
</span></span><span class=line><span class=cl>    Note over CLI,Submit: ❌ 漏传 kimi: options.kimi
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Note over Submit: if (options.kimi) → undefined&lt;br/&gt;不触发过滤，走默认路径
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Submit-&gt;&gt;API: 全量数据（非 Kimi 过滤）
</span></span><span class=line><span class=cl>    Note over API: --kimi 参数无效果
</span></span></code></pre></td></tr></table></div></div><p>两端各自正确，中段断裂：<code>cli.ts</code> 调用 <code>submit({...})</code> 时未传 <code>kimi: options.kimi</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// cli.ts submit 命令的 action（修复前）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>await</span> <span class=nx>submit</span><span class=p>({</span>
</span></span><span class=line><span class=cl>  <span class=nx>opencode</span>: <span class=kt>options.opencode</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>claude</span>: <span class=kt>options.claude</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>codex</span>: <span class=kt>options.codex</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>gemini</span>: <span class=kt>options.gemini</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>cursor</span>: <span class=kt>options.cursor</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>amp</span>: <span class=kt>options.amp</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>droid</span>: <span class=kt>options.droid</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>openclaw</span>: <span class=kt>options.openclaw</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>pi</span>: <span class=kt>options.pi</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=c1>// kimi: options.kimi,    ← 缺失
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>since</span>: <span class=kt>options.since</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>until</span>: <span class=kt>options.until</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>year</span>: <span class=kt>options.year</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>dryRun</span>: <span class=kt>options.dryRun</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p><code>kimi</code> 在 <code>SubmitOptions</code> 中是可选参数，不传就是 <code>undefined</code>。<code>hasFilter</code> 得到 <code>undefined</code>，不触发过滤，走全量提交路径。功能表面正常，数据能提交，但 <code>--kimi</code> 过滤完全无效。</p><p>为什么基准对比没发现？检查者看到 <code>cli.ts</code> 中已存在 <code>"kimi"</code>（在 <code>.option("--kimi", ...)</code> 中），就认为文件已覆盖，没有追踪同一文件内的其他触点。这是执行粒度问题：<code>grep</code> 退化为文件级扫描（「有 kimi 就算过」）时，行级遗漏漏网。捕获这类问题需要沿数据流逐段追踪，验证每段连通。</p><hr><h2 id=第四层质疑外部数据>第四层：质疑外部数据<a hidden class=anchor aria-hidden=true href=#第四层质疑外部数据>#</a></h2><p>前三层解决的都是代码问题，但还有一类问题藏在代码引用的外部事实中。Tokscale 需要模型定价来计算成本。Kimi CLI 使用 <code>kimi-for-coding</code> 作为模型标识，AI 在 <code>aliases.rs</code> 中映射到定价模型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 推断值——未经官方定价文档核实
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;kimi-for-coding&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;kimi-k2-thinking&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>kimi-k2-thinking</code> 的 output 定价 $2.50/M tokens。不追问的话，没有理由怀疑它。</p><h3 id=一句-prompt-切换-ai-的认知模式>一句 Prompt 切换 AI 的认知模式<a hidden class=anchor aria-hidden=true href=#一句-prompt-切换-ai-的认知模式>#</a></h3><p>追问的 Prompt 是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>代码修改中，像是 kimi 模型成本这种比较细节的问题，
</span></span><span class=line><span class=cl>你是如何获取的呢？你应该只能通过联网的方式获取到这个数据吧？请你自检下
</span></span></code></pre></td></tr></table></div></div><p>AI 坦承这是根据模型命名推断的。联网核实后，实际对应 <code>kimi-k2.5</code>，output 定价 $3.00/M tokens——偏差 20%。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 官方定价页核实：kimi-for-coding → kimi-k2.5，$3.00/M output
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=s>&#34;kimi-for-coding&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;kimi-k2.5&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>改动只有一行，但漏过则所有 Kimi 用户的成本计算偏低 20%。</p><p>这条 Prompt 在四轮验收中单位字数的 ROI 最高——一句话逼出一个隐蔽的事实性错误。</p><p>它没有问「定价对不对？」——那样问，AI 会发现 <code>$2.50</code> 在合理范围内，回答「对的」。它问「你是如何获取的？」——迫使 AI 从「给答案」切换到「评估置信度」：我是从官方文档查到的，还是根据命名规律推断的？一旦进入这个模式，AI 主动暴露推理中的不确定性，而非把不确定性包装成确定答案。</p><p>后半句「你应该只能通过联网的方式获取到这个数据吧？」收窄退路——预设了判断标准：这类数据的唯一可靠来源是联网查询。AI 无法在此前提下声称推断可靠，只能转向联网验证。</p><p>AI 面对不确定的事实时倾向于给出「合理推断」而非拒绝回答。<code>kimi-k2-thinking</code> 和 <code>kimi-k2.5</code> 都属 K2 系列，$2.50 和 $3.00 差距不大，不触发直觉警报。对于定价、API endpoint、版本号等外部事实，追问来源和验证「值合不合理」是两件独立的事。</p><hr><h2 id=从验收兜底到设计预防>从验收兜底到设计预防<a hidden class=anchor aria-hidden=true href=#从验收兜底到设计预防>#</a></h2><p>前四层解决「如何发现遗漏」。能不能让遗漏更难发生？</p><h3 id=工作流预防基准对比前置到设计阶段>工作流预防：基准对比前置到设计阶段<a hidden class=anchor aria-hidden=true href=#工作流预防基准对比前置到设计阶段>#</a></h3><p>对于「新增同类实体」类任务（新增 provider、权限角色、支付方式），写技术方案前先跑两条命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ grep -rn <span class=s1>&#39;&#34;codex&#34;&#39;</span> packages/
</span></span><span class=line><span class=cl>$ grep -rn <span class=s1>&#39;&#34;claude&#34;&#39;</span> packages/
</span></span></code></pre></td></tr></table></div></div><p>两个已有实体的全部出现位置就是新实体的触点清单。用两个参照而非一个，因为不同实体的实现路径不完全重叠——codex 在 submit 路径有触点而 claude 没有，交叉比对更广。清单写进技术方案，AI 拿到的就不是「添加 Kimi 支持」这样的模糊目标，而是精确到文件和行号的 26 个触点清单。编译器保护 8 个，清单保护剩余 18 个，验收漏斗的压力从 12 处降到接近 0。</p><p>同样的 <code>grep</code>，方案阶段跑一次是预防，验收阶段跑一次是修补，成本差一个数量级。不改代码架构，只改工作流顺序。</p><h3 id=代码架构预防让类型系统拦截遗漏>代码架构预防：让类型系统拦截遗漏<a hidden class=anchor aria-hidden=true href=#代码架构预防让类型系统拦截遗漏>#</a></h3><p>差异的根源不在 AI 的注意力，而在类型系统对 absence 的容忍度。Rust 的 <code>match</code> 穷尽检查把「缺失」变成编译错误；TypeScript 的可选参数让「缺失」静默通过。在 TypeScript 侧建立类似的强制约束，编写阶段就能拦截部分遗漏。三个方向：</p><p><strong>单一事实源（Single Source of Truth）</strong>。当前 <code>SourceType</code> 合法值分散在 CLI union、前端 <code>z.enum</code>、<code>constants.ts</code>、<code>submit.ts</code> 等多处，各自独立维护。集中到一个常量，其他位置从常量派生，新增 source 只改一处。26 个触点不会变成 1 个，但字符串字面量收敛为一个源头。</p><p><strong>穷尽映射（Exhaustive Mapping）</strong>。<code>Record&lt;SourceType, T></code> 或 <code>satisfies</code> 可以强制映射每个 source。把颜色配置从 <code>if-else</code> 链改为 <code>Record&lt;SourceType, string></code>，缺一个 source 就类型报错——在 TypeScript 侧复现 Rust <code>match</code> 的穷尽检查，把「横向传播遗漏」从运行时问题变成编译期问题。</p><p><strong>关键路径 E2E 冒烟测试</strong>。本案例中测试只覆盖读取路径（<code>sources</code>、<code>models --kimi</code>），未覆盖提交路径（<code>submit --kimi</code>）。为「新增数据源」建立固定冒烟用例——<code>parse → cli filter → submit → frontend validate</code>——第三层「人工追链」的成本就能转化为自动化测试。</p><p>工作流预防和代码架构预防不替代四层验收漏斗，而是从源头减少漏斗拦截的问题数量。前者改变做事的顺序，后者改变代码的结构——两者共同降低兜底压力。</p><hr><h2 id=闭环四层漏斗模型与-prompt-策略>闭环：四层漏斗模型与 Prompt 策略<a hidden class=anchor aria-hidden=true href=#闭环四层漏斗模型与-prompt-策略>#</a></h2><p>每一层用不同的检测原理过滤不同类型的问题，前一层的假阴性恰好落在后一层的检测范围内。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1> 1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2> 2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3> 3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4> 4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5> 5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6> 6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7> 7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8> 8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9> 9</a>
</span><span class=lnt id=hl-17-10><a class=lnlinks href=#hl-17-10>10</a>
</span><span class=lnt id=hl-17-11><a class=lnlinks href=#hl-17-11>11</a>
</span><span class=lnt id=hl-17-12><a class=lnlinks href=#hl-17-12>12</a>
</span><span class=lnt id=hl-17-13><a class=lnlinks href=#hl-17-13>13</a>
</span><span class=lnt id=hl-17-14><a class=lnlinks href=#hl-17-14>14</a>
</span><span class=lnt id=hl-17-15><a class=lnlinks href=#hl-17-15>15</a>
</span><span class=lnt id=hl-17-16><a class=lnlinks href=#hl-17-16>16</a>
</span><span class=lnt id=hl-17-17><a class=lnlinks href=#hl-17-17>17</a>
</span><span class=lnt id=hl-17-18><a class=lnlinks href=#hl-17-18>18</a>
</span><span class=lnt id=hl-17-19><a class=lnlinks href=#hl-17-19>19</a>
</span><span class=lnt id=hl-17-20><a class=lnlinks href=#hl-17-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>graph TD
</span></span><span class=line><span class=cl>    IN[&#34;AI 交付代码&lt;br/&gt;16 处潜在问题&#34;] --&gt; L1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    L1[&#34;🔬 层 1：自动化测试 + AI 自检&lt;br/&gt;检测原理：纵向逻辑验证&lt;br/&gt;发现：0 处 | 泄漏：16 处&#34;]
</span></span><span class=line><span class=cl>    L1 --&gt;|&#34;16 处泄漏&lt;br/&gt;（横向遗漏全部漏过）&#34;| L2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    L2[&#34;🔍 层 2：基准对比&lt;br/&gt;检测原理：字符串匹配 × 外部参照物&lt;br/&gt;发现：12 处 | 泄漏：4 处&#34;]
</span></span><span class=line><span class=cl>    L2 --&gt;|&#34;4 处泄漏&lt;br/&gt;（行级遗漏 + 外部数据）&#34;| L3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    L3[&#34;🔗 层 3：端到端追踪&lt;br/&gt;检测原理：调用链逐段连通性验证&lt;br/&gt;发现：3 处 | 泄漏：1 处&#34;]
</span></span><span class=line><span class=cl>    L3 --&gt;|&#34;1 处泄漏&lt;br/&gt;（事实性错误）&#34;| L4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    L4[&#34;❓ 层 4：外部数据质疑&lt;br/&gt;检测原理：追问数据来源与置信度&lt;br/&gt;发现：1 处 | 泄漏：0 处&#34;]
</span></span><span class=line><span class=cl>    L4 --&gt; OUT[&#34;✅ 16 处全部修复&#34;]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    style L1 fill:#ffebee,stroke:#c62828
</span></span><span class=line><span class=cl>    style L2 fill:#e8f5e9,stroke:#2e7d32
</span></span><span class=line><span class=cl>    style L3 fill:#e3f2fd,stroke:#1565c0
</span></span><span class=line><span class=cl>    style L4 fill:#fff3e0,stroke:#e65100
</span></span><span class=line><span class=cl>    style OUT fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
</span></span></code></pre></td></tr></table></div></div><p>各层 Prompt 策略与耗时：</p><table><thead><tr><th>层级</th><th>验证手段</th><th>Prompt 策略</th><th>发现</th><th>耗时（估）</th></tr></thead><tbody><tr><td>0</td><td>实现指令</td><td>探索性 Prompt + 详细计划</td><td>—</td><td>~40 min</td></tr><tr><td>1</td><td>自动化测试 + AI 自检</td><td>「完成了吗？请你检查下」</td><td>0（假阴性）</td><td>~5 min</td></tr><tr><td>2</td><td>基准对比</td><td>以 Codex 为参照物，分 6 域逐项比对</td><td>12</td><td>~10 min</td></tr><tr><td>3</td><td>端到端追踪</td><td>人工逐段追踪调用链</td><td>3</td><td>~15 min</td></tr><tr><td>4</td><td>外部数据质疑</td><td>「这个数据你是如何获取的？」</td><td>1</td><td>~2 min</td></tr></tbody></table><p>各层检测原理不同，形成互补：纵向逻辑验证 → 字符串匹配 → 调用链追踪 → 数据源头验证。理论上某一层粒度足够细时可以覆盖下一层的部分范围，但实际操作中每层倾向于在自身的抽象粒度上工作，层间互补因此成立。</p><p>ROI 最高的是层 2（10 分钟，12 处）和层 4（2 分钟，1 处致命错误）。层 1 投入产出为零但仍是必要的准入门槛。层 3 耗时最长、发现最少，却捕获了跨文件参数传递断裂。</p><h3 id=三条原则>三条原则<a hidden class=anchor aria-hidden=true href=#三条原则>#</a></h3><ol><li><strong>不要让 AI 批改自己的试卷</strong>。自检 Prompt 导致共模失效——审计者和被审计者共享盲区。你写完文章自己检查三遍看不到错别字，朋友 30 秒就圈出来——不是朋友更仔细，而是你的大脑在用写作时的同一套预期做审查。AI 自检同理。验收引入外部参照物（已有实现、触点清单、官方文档），把主观判断题转换为客观匹配题。</li><li><strong>问「怎么来的」而非「对不对」</strong>。前者攻击推理链条，迫使 AI 暴露不确定性；后者让 AI 辩护结果。古罗马验收石桥不审查图纸，而是让工程师站在桥下——追问过程比审查结论有效得多。涉及外部事实的代码（定价、API、版本号），这是唯一可靠的检测手段。</li><li><strong>absence 不报错，所以要主动搜索 absence</strong>。测试验证「已有代码做了什么」，而非「应有代码是否存在」。泰坦尼克号的检查员逐项核查了锅炉、铆钉、电报机，全部通过——但没有检查表要求核验「救生艇数量是否匹配乘客总数」。遗漏的检查项不会自己举手。在弱约束语言层中，<code>grep</code> + 参照物主动搜索「应出现但没出现」的值，比等运行时报错高效得多。</li></ol><h3 id=实践清单>实践清单<a hidden class=anchor aria-hidden=true href=#实践清单>#</a></h3><p><strong>层 1：自动化验证做基线</strong></p><p>运行全量测试和 <code>lint</code>，确认未引入回归。绿色结果 = 已有功能未被破坏。</p><p><strong>层 2：基准对比做横向覆盖</strong></p><p>选同类功能作参照，按功能域逐项比对：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1>1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2>2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3>3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4>4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5>5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6>6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>以 [已有功能] 作为基准，逐项列出所有修改点：
</span></span><span class=line><span class=cl>1. [功能域1]：[具体检查项]
</span></span><span class=line><span class=cl>2. [功能域2]：[具体检查项]
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>对每个位置，给出：文件路径、行号、当前代码片段。
</span></span><span class=line><span class=cl>反推 [新增功能] 是否一一对应。未对齐的逐条列出。
</span></span><span class=line><span class=cl>所有功能域检查完毕后再给出总结。
</span></span></code></pre></td></tr></table></div></div><p>按功能域分类避免 AI 过早停止搜索；要求「文件路径 + 行号」防止文件级扫描退化。</p><p><strong>层 3：端到端追踪做连通性</strong></p><p>沿调用链从用户输入追踪到最终输出，逐段验证参数传递。重点关注可选参数（<code>?</code> 和 <code>Option&lt;T></code>）。每个新增参数追踪三段：定义处 → 传递处 → 使用处。</p><p><strong>层 4：外部数据追问来源</strong></p><p>对涉及外部事实（定价、API endpoint、版本号）的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1>1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2>2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[具体代码位置] 中的 [具体值]，你是如何获取的？
</span></span><span class=line><span class=cl>是从官方文档查到的，还是根据命名规律推断的？
</span></span><span class=line><span class=cl>如果是推断，请联网核实后给出修正。
</span></span></code></pre></td></tr></table></div></div><hr><p>169 个测试、0 个失败——这是起点。三条原则、四层漏斗、16 处修复——这是设计预防、验收手段和提问策略共同填补的距离。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://miss-you.github.io/tags/ai/>AI</a></li><li><a href=https://miss-you.github.io/tags/prompt-engineering/>Prompt Engineering</a></li><li><a href=https://miss-you.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/>软件工程</a></li><li><a href=https://miss-you.github.io/tags/%E6%B5%8B%E8%AF%95/>测试</a></li><li><a href=https://miss-you.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/>代码审查</a></li><li><a href=https://miss-you.github.io/tags/rust/>Rust</a></li><li><a href=https://miss-you.github.io/tags/typescript/>TypeScript</a></li></ul><nav class=paginav><a class=next href=https://miss-you.github.io/posts/20260217-websocket-to-four-components/><span class=title>下一页 »</span><br><span>从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘 on x" href="https://x.com/intent/tweet/?text=%e4%b8%8d%e8%a6%81%e8%ae%a9%20AI%20%e6%89%b9%e6%94%b9%e8%87%aa%e5%b7%b1%e7%9a%84%e8%af%95%e5%8d%b7%20%e2%80%94%e2%80%94%20%e4%b8%80%e6%ac%a1%2016%20%e5%a4%84%e9%81%97%e6%bc%8f%e7%9a%84%e5%8d%8f%e4%bd%9c%e5%a4%8d%e7%9b%98&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f&amp;hashtags=AI%2cPromptEngineering%2c%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%2c%e6%b5%8b%e8%af%95%2c%e4%bb%a3%e7%a0%81%e5%ae%a1%e6%9f%a5%2cRust%2cTypeScript"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f&amp;title=%e4%b8%8d%e8%a6%81%e8%ae%a9%20AI%20%e6%89%b9%e6%94%b9%e8%87%aa%e5%b7%b1%e7%9a%84%e8%af%95%e5%8d%b7%20%e2%80%94%e2%80%94%20%e4%b8%80%e6%ac%a1%2016%20%e5%a4%84%e9%81%97%e6%bc%8f%e7%9a%84%e5%8d%8f%e4%bd%9c%e5%a4%8d%e7%9b%98&amp;summary=%e4%b8%8d%e8%a6%81%e8%ae%a9%20AI%20%e6%89%b9%e6%94%b9%e8%87%aa%e5%b7%b1%e7%9a%84%e8%af%95%e5%8d%b7%20%e2%80%94%e2%80%94%20%e4%b8%80%e6%ac%a1%2016%20%e5%a4%84%e9%81%97%e6%bc%8f%e7%9a%84%e5%8d%8f%e4%bd%9c%e5%a4%8d%e7%9b%98&amp;source=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f&title=%e4%b8%8d%e8%a6%81%e8%ae%a9%20AI%20%e6%89%b9%e6%94%b9%e8%87%aa%e5%b7%b1%e7%9a%84%e8%af%95%e5%8d%b7%20%e2%80%94%e2%80%94%20%e4%b8%80%e6%ac%a1%2016%20%e5%a4%84%e9%81%97%e6%bc%8f%e7%9a%84%e5%8d%8f%e4%bd%9c%e5%a4%8d%e7%9b%98"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘 on whatsapp" href="https://api.whatsapp.com/send?text=%e4%b8%8d%e8%a6%81%e8%ae%a9%20AI%20%e6%89%b9%e6%94%b9%e8%87%aa%e5%b7%b1%e7%9a%84%e8%af%95%e5%8d%b7%20%e2%80%94%e2%80%94%20%e4%b8%80%e6%ac%a1%2016%20%e5%a4%84%e9%81%97%e6%bc%8f%e7%9a%84%e5%8d%8f%e4%bd%9c%e5%a4%8d%e7%9b%98%20-%20https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘 on telegram" href="https://telegram.me/share/url?text=%e4%b8%8d%e8%a6%81%e8%ae%a9%20AI%20%e6%89%b9%e6%94%b9%e8%87%aa%e5%b7%b1%e7%9a%84%e8%af%95%e5%8d%b7%20%e2%80%94%e2%80%94%20%e4%b8%80%e6%ac%a1%2016%20%e5%a4%84%e9%81%97%e6%bc%8f%e7%9a%84%e5%8d%8f%e4%bd%9c%e5%a4%8d%e7%9b%98&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e4%b8%8d%e8%a6%81%e8%ae%a9%20AI%20%e6%89%b9%e6%94%b9%e8%87%aa%e5%b7%b1%e7%9a%84%e8%af%95%e5%8d%b7%20%e2%80%94%e2%80%94%20%e4%b8%80%e6%ac%a1%2016%20%e5%a4%84%e9%81%97%e6%bc%8f%e7%9a%84%e5%8d%8f%e4%bd%9c%e5%a4%8d%e7%9b%98&u=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260218-ai-collaboration-acceptance-blindspots%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://miss-you.github.io/>Yousa Driven Development | YDD</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>