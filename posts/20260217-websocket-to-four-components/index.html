<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 | Yousa Driven Development | YDD</title><meta name=keywords content="AI,WebSocket,架构,CLI,Kimi,Happy,架构设计"><meta name=description content="从最简方案开始，每遇到一个绕不过去的约束就加一个组件。四层方案逐层淘汰，最终发现四组件是五个硬约束逐层叠加的必然结果。"><meta name=author content="Miss-you"><link rel=canonical href=https://miss-you.github.io/posts/20260217-websocket-to-four-components/><link crossorigin=anonymous href=/assets/css/stylesheet.90ccfe940c2ebacfe29cf6c094281c8c148bd718511cde00be68d330109118be.css integrity="sha256-kMz+lAwuus/inPbAlCgcjBSL1xhRHN4AvmjTMBCRGL4=" rel="preload stylesheet" as=style><link rel=icon href=https://miss-you.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://miss-you.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://miss-you.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://miss-you.github.io/apple-touch-icon.png><link rel=mask-icon href=https://miss-you.github.io/safari-pinned-tab.svg><meta name=theme-color content="#f4f3ee"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://miss-you.github.io/posts/20260217-websocket-to-four-components/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Noto+Serif+SC:wght@400;600;700;900&family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel=stylesheet><meta property="og:url" content="https://miss-you.github.io/posts/20260217-websocket-to-four-components/"><meta property="og:site_name" content="Yousa Driven Development | YDD"><meta property="og:title" content="从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化"><meta property="og:description" content="从最简方案开始，每遇到一个绕不过去的约束就加一个组件。四层方案逐层淘汰，最终发现四组件是五个硬约束逐层叠加的必然结果。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-17T09:50:00+08:00"><meta property="article:modified_time" content="2026-02-17T11:00:37+08:00"><meta property="article:tag" content="AI"><meta property="article:tag" content="WebSocket"><meta property="article:tag" content="架构"><meta property="article:tag" content="CLI"><meta property="article:tag" content="Kimi"><meta property="article:tag" content="Happy"><meta name=twitter:card content="summary"><meta name=twitter:title content="从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化"><meta name=twitter:description content="从最简方案开始，每遇到一个绕不过去的约束就加一个组件。四层方案逐层淘汰，最终发现四组件是五个硬约束逐层叠加的必然结果。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://miss-you.github.io/posts/"},{"@type":"ListItem","position":2,"name":"从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化","item":"https://miss-you.github.io/posts/20260217-websocket-to-four-components/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化","name":"从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化","description":"从最简方案开始，每遇到一个绕不过去的约束就加一个组件。四层方案逐层淘汰，最终发现四组件是五个硬约束逐层叠加的必然结果。","keywords":["AI","WebSocket","架构","CLI","Kimi","Happy","架构设计"],"articleBody":"从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 手机远程操控电脑上的 AI Coding CLI，直觉上只需一个 WebSocket。CLI 在电脑上跑着，手机连上去，发消息，收输出，结束。\nKimi CLI 的 Web UI 做到了这一步。执行 kimi web，本地起一个 HTTP + WebSocket 服务，浏览器打开就能用。底层 Wire 协议（JSON-RPC 2.0）支持多个 WebSocket 客户端同时接入，消息通过 BroadcastQueue 广播给所有订阅者。手机套个 WebView 就行了？\n但 Happy 项目把同样的需求拆成了四个独立组件：CLI、Daemon、Server、App。四个进程，三种 Socket 连接类型，一套 RPC 转发机制，外加端到端加密（E2EE）。\n为什么？\n这篇文章用两个真实项目的源码回答。从最简的直连方案开始，每遇到一个绕不过去的约束就加一个组件。四层方案逐层淘汰，最终会发现：四组件不是过度设计，而是五个硬约束逐层叠加的必然结果。\n读完后能得到：\n每个组件存在的「不可替代的理由」，以及没有它会怎样 Happy 和 Kimi CLI 在消息路由、进程管理、控制权协调上的关键设计细节 一棵决策树，根据自己的场景判断需要几个组件、哪些可以省 现有 Wire 协议哪些能复用、哪些必须新增的分层分析 阅读路线：\n只想知道为什么不是一个 WebSocket → 第 1 节 + 小结 想理解 Happy 的核心机制 → 第 4 节（scope / RPC / 租约 / E2EE）+ 第 5 节（Daemon） 想设计自己的远程操控系统 → 第 6.3 节（五维度扫描）+ 小结决策树 想做协议复用 / 迁移评估 → 第 7 节 1. 五个硬约束 拆解方案之前，先定义检验标准。「手机远程操控电脑上的 AI Coding CLI」拆成五个约束：\n# 约束 含义 C1 跨网可达 手机在 4G/5G，开发机在 NAT 后面，两者能通信 C2 多端一致 手机和电脑看到的会话状态完全一致 C3 控制权互斥 同一时刻只有一个终端控制 Agent C4 会话独立于前端 关掉手机或终端，Agent 继续跑，重新打开能接上 C5 安全 至少有认证，理想情况下 E2EE 为什么是这五个 这张表是逐步证伪得到的，从最简方案开始，每一步找一个打破它的场景，被迫加一个组件，直到没有场景能打破：\n1 2 3 4 5 6 7 8 9 10 11 起点：手机直连电脑（一个 WebSocket） │ ├─ \"手机 4G，电脑在家 WiFi\" → 连不上 → 需要公网中继 │ ├─ \"手机和电脑同时连上\" → 消息顺序不一致 → 中继要理解协议、做排序 │ ├─ \"两个客户端同时发 prompt\" → 谁算数？→ 要有人仲裁控制权 │ ├─ \"关掉终端窗口\" → Agent 跟着死了 → 需要独立的常驻进程 │ └─ \"在电脑上也想交互式操作\" → 常驻进程没有 TTY → 需要额外的交互前端 这个拆解有三个性质：\n每个约束都有反例。删掉任何一个，都能构造一个具体的故障场景，后面四节逐一展示。 约束之间有依赖序。讨论「控制权互斥」的前提是「多端已连上」，讨论「多端连接」的前提是「网络可达」。链条是：网络可达 → 多端共存 → 多端冲突 → 进程生命周期 → 交互模式分离。每一层的问题，只有前一层解决后才会暴露。 每个约束恰好淘汰一种方案。没有两个约束淘汰同一种方案，没有冗余。 「从最简开始，被失败逼着加组件」的方法有一个跨越八百年的同构案例：英国普通法。不是一次性写出完美法典，而是每次新型案件暴露旧规则的不足，法官被迫创造新判例。每条规则指向一次真实的失败，和每个组件指向一个具体的约束是同一套逻辑。更贴身的版本：搬进新家三个月，家里每件东西都对应一个真实的不便，没有一件多余。\n后面每种方案都用这五个约束打分。\n2. 第一层：App 直连 Web UI 2.1 Kimi CLI 的现有能力 Kimi CLI 已具备外部 UI 接入的基础设施。执行 kimi web，本地起一个 FastAPI 服务，浏览器通过 WebSocket 连接 Wire 协议与 Agent 内核交互。\n底层消息分发采用 SPMC（Single Producer, Multiple Consumer）广播队列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # kimi-cli/src/kimi_cli/utils/broadcast.py class BroadcastQueue[T]: def __init__(self) -\u003e None: self._queues: set[Queue[T]] = set() def subscribe(self) -\u003e Queue[T]: queue: Queue[T] = Queue() self._queues.add(queue) return queue def publish_nowait(self, item: T) -\u003e None: for queue in self._queues: queue.put_nowait(item) 每个 WebSocket 客户端调用 subscribe() 获得自己的队列，Agent 内核每产生一条消息就通过 publish_nowait 广播给所有订阅者。多个客户端可以同时观看同一个会话的输出。\n新客户端中途加入时，SessionProcess 用缓冲机制衔接历史回放和实时消息：\n1 2 3 4 5 6 7 8 9 10 11 12 # kimi-cli/src/kimi_cli/web/runner/process.py:526-538 async def _broadcast(self, message: str) -\u003e None: async with self._ws_lock: to_send: list[WebSocket] = [] for ws in self._websockets: buffer = self._replay_buffers.get(ws) if buffer is not None: buffer.append(message) # 正在回放历史：缓冲实时消息 else: to_send.append(ws) # 已进入实时：直接发送 for ws in to_send: await ws.send_text(message) 正在回放 wire.jsonl 历史的客户端，实时消息暂存到 _replay_buffers。回放结束后 flush 缓冲区，无缝切到实时流，保证中途加入不丢消息。\n2.2 卡在哪里 C1 跨网失败。Web 服务默认绑定 127.0.0.1，加 --network 后绑 0.0.0.0，但开发机仍在 NAT 后面。手机在 4G 网络上找不到这台机器。用户需要自己搞 Tailscale 或 ngrok，不是产品化方案。\nC3 控制权失败。Wire 协议的请求响应是 1:1 的。Agent 发出 ApprovalRequest 时，请求放进一个全局字典：\n1 2 3 # kimi-cli/src/kimi_cli/wire/server.py:75-76 self._pending_requests: dict[str, Request] = {} \"\"\"Maps JSON RPC message IDs to pending Requests.\"\"\" 这正是 C3 失败的根源：字典没有客户端隔离。两个 WebSocket 同时连接时，都能看到同一个 ApprovalRequest，都能响应，谁先回复谁生效。两个客户端还可以在会话空闲时同时发 prompt，is_busy 检查不起作用。\nC4 会话独立失败。Worker 子进程的生命周期绑定在 FastAPI 服务上：\n1 2 3 4 5 6 7 8 9 10 # kimi-cli/src/kimi_cli/web/app.py:168-186 @asynccontextmanager async def lifespan(app: FastAPI): runner = KimiCLIRunner() app.state.runner = runner runner.start() try: yield finally: await runner.stop() # Web 服务关闭 → 所有 Worker 子进程被杀 关掉终端窗口，Web 服务退出，runner.stop() 杀死所有 Worker 子进程，会话丢失。\n约束 直连方案 C1 跨网 ❌ C2 多端一致 ⚠️ 广播可用，无协调 C3 控制权 ❌ C4 会话独立 ❌ C5 安全 ⚠️ Token，无 E2EE 3. 第二层：Web UI + Gateway 最直觉的补救：在 Web UI 前加一层反向代理（Caddy、nginx、Cloudflare Tunnel），解决网络可达和 TLS 终止。\n1 iPhone ──HTTPS/WSS──▶ Gateway（公网） ──HTTP/WS──▶ 开发机 kimi web C1 跨网解决了，C5 传输层加密有了。但 Gateway 只是管道，不理解 Wire 协议语义：\nC2 多端一致：Gateway 透明转发，没有人协调消息顺序 C3 控制权：Gateway 不知道谁是控制端，两个客户端仍可同时发 prompt C4 会话独立：Worker 仍绑在 Web 服务进程上，Gateway 管不了进程生命周期 两个客户端通过 Gateway 同时连接时的冲突场景：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sequenceDiagram participant 手机 as 手机 participant GW as Gateway participant Agent as Agent Agent-\u003e\u003eGW: ApprovalRequest (rm -rf /tmp/build) GW-\u003e\u003e手机: ApprovalRequest GW-\u003e\u003e终端: ApprovalRequest 手机-\u003e\u003eGW: approve ✓ 终端-\u003e\u003eGW: approve ✓ (晚 200ms) GW-\u003e\u003eAgent: approve (手机的先到，生效) GW-\u003e\u003eAgent: approve (终端的后到，被丢弃) Note over 手机,终端: 两个用户都以为是自己批准的 Note over Agent: session 变为空闲 手机-\u003e\u003eGW: prompt \"run tests\" 终端-\u003e\u003eGW: prompt \"deploy to prod\" GW-\u003e\u003eAgent: 两个 prompt 同时到达 Note over Agent: 都通过 is_busy 检查先到的执行，后到的被忽略→ 一个用户：我发了命令，为什么没反应？ Gateway 忠实转发了每条消息，但它不知道谁该说话、谁该等待。\nGateway 部署在第三方时，它作为中间人能看到所有明文，代码、对话、工具调用参数对第三方完全透明。\n约束 直连 +Gateway C1 跨网 ❌ ✅ C2 多端一致 ⚠️ ❌ C3 控制权 ❌ ❌ C4 会话独立 ❌ ❌ C5 安全 ⚠️ ⚠️ TLS only 常见替代方案为什么不够：\n方案 解决了什么 没解决什么 代价 SSH 隧道 + tmux C1 跨网、C4 会话独立 C2 多端协调、C3 控制权仲裁 手机上没有 SSH 终端体验；需暴露 SSH 端口 VPN（Tailscale） C1 跨网 C2-C5 全部 退回直连方案，只解决网络层 WebRTC P2P C1 跨网（打洞） C4 无常驻进程管理 打洞成功率不稳定；TURN fallback 等于回到 Server 方案 每种方案都只解决约束链的一两环，剩下的约束不会消失，只是被推迟。\n4. 第三层：有状态的 Server 把 Gateway 升级为「理解业务语义的 Server」。这是 Happy 架构中最重量级的组件。\n4.1 三种 Socket Scope Happy Server 不是简单地广播消息给所有连接。每个 Socket.IO 连接在握手时声明类型，Server 按类型分发：\n1 2 3 4 5 // happy-server/sources/app/api/socket.ts:37-40 const clientType = socket.handshake.auth.clientType as 'session-scoped' | 'user-scoped' | 'machine-scoped' | undefined; const sessionId = socket.handshake.auth.sessionId as string | undefined; const machineId = socket.handshake.auth.machineId as string | undefined; 验证通过后，Server 按 clientType 构建连接对象并注册到 eventRouter：\n1 2 3 4 5 6 7 8 9 // happy-server/sources/app/api/socket.ts:78-100 if (metadata.clientType === 'session-scoped' \u0026\u0026 sessionId) { connection = { connectionType: 'session-scoped', socket, userId, sessionId }; } else if (metadata.clientType === 'machine-scoped' \u0026\u0026 machineId) { connection = { connectionType: 'machine-scoped', socket, userId, machineId }; } else { connection = { connectionType: 'user-scoped', socket, userId }; } eventRouter.addConnection(userId, connection); 三种 scope 各有职责：\nScope 使用者 接收 发送 user-scoped App / Web 全局更新（会话列表、机器状态） ping、usage 上报 session-scoped CLI 会话进程 特定会话的消息更新 消息、状态变更 machine-scoped Daemon 机器级指令、RPC 请求 心跳、在线状态 手机打开某个会话时只订阅该会话的流，不会收到其他会话的消息。比 Kimi Web UI 的「所有消息广播给所有客户端」精细得多。\n4.2 RPC：为什么消息流不够 消息流是 fire-and-forget 的，Server 推 update 给订阅者，不等回复。但有些操作需要同步等待响应：中止当前 turn、批准权限请求、远程执行 bash 命令并拿到输出。\nHappy 在 Socket.IO 上实现了一套 RPC 转发，核心链路三步：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 sequenceDiagram participant App as App (手机) participant Server as Server (公网) participant CLI as CLI (开发机) Note over CLI,Server: 1. 注册 CLI-\u003e\u003eServer: rpc-register({method: \"session-abc:bash\"}) Note over App,CLI: 2. 转发 App-\u003e\u003eServer: rpc-call({method: \"session-abc:bash\", params: encrypted}) Server-\u003e\u003eCLI: rpc-request({method, params}) Note over App,CLI: 3. 执行 + 返回 CLI--\u003e\u003eCLI: decrypt → handler(params) → encrypt CLI-\u003e\u003eServer: response (encrypted) Server-\u003e\u003eApp: callback({ok: true, result: encrypted}) Server 全程只做 socket 到 socket 的盲转发，看不到 params 和 result 的明文。\n注册。CLI 会话启动时，通过 RpcHandlerManager 向 Server 注册能处理的方法：\n1 2 3 4 5 6 7 8 9 10 // happy-cli/src/api/rpc/RpcHandlerManager.ts:36-47 registerHandler\u003cTRequest, TResponse\u003e( method: string, handler: RpcHandler\u003cTRequest, TResponse\u003e ): void { const prefixedMethod = this.getPrefixedMethod(method); this.handlers.set(prefixedMethod, handler); if (this.socket) { this.socket.emit('rpc-register', { method: prefixedMethod }); } } 方法名带 sessionId 前缀（如 session-abc:bash），Server 用它路由。\n转发。App 发 rpc-call，Server 查找目标 socket 并转发：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // happy-server/sources/app/api/socket/rpcHandler.ts:67-114（简化） socket.on('rpc-call', async (data, callback) =\u003e { const { method, params } = data; const targetSocket = rpcListeners.get(method); if (!targetSocket || !targetSocket.connected) { callback({ ok: false, error: 'RPC method not available' }); return; } if (targetSocket === socket) { callback({ ok: false, error: 'Cannot call RPC on the same socket' }); return; } const response = await targetSocket.timeout(30000) .emitWithAck('rpc-request', { method, params }); callback({ ok: true, result: response }); }); 执行。CLI 侧解密参数、调用 handler、加密响应返回：\n1 2 3 4 5 6 7 8 9 // happy-cli/src/api/rpc/RpcHandlerManager.ts:55-79（简化） async handleRequest(request: RpcRequest): Promise\u003cany\u003e { const handler = this.handlers.get(request.method); const decryptedParams = decrypt(this.encryptionKey, this.encryptionVariant, decodeBase64(request.params)); const result = await handler(decryptedParams); return encodeBase64(encrypt(this.encryptionKey, this.encryptionVariant, result)); } params 和返回值都是加密的 base64 字符串，即使 Server 被攻破，攻击者拿到的也只是密文。\nE2EE 的保护边界：\n被保护 未被保护 内容 对话文本、代码、工具调用参数、Agent 输出 — 元数据 — 谁连了谁、session ID、消息时间戳和大小 前提 密钥由客户端生成，不经过 Server 设备被入侵后密钥泄露；登录凭证被盗后的会话劫持 E2EE 保护的是「Server 被攻破时的内容机密性」，不保护客户端本身被攻破的场景，也不隐藏流量模式。\n4.3 乐观并发控制 多个客户端同时修改会话状态时，Happy 用乐观并发防止互相覆盖：\n1 2 3 4 5 6 7 8 9 10 11 // happy-cli/src/api/apiSession.ts:553-575（简化） const answer = await this.socket.emitWithAck('update-state', { sid: this.sessionId, expectedVersion: this.agentStateVersion, agentState: encodeBase64(encrypt(this.encryptionKey, this.encryptionVariant, updated)) }); if (answer.result === 'version-mismatch') { this.agentStateVersion = answer.version; throw new Error('version mismatch'); // 触发 backoff 重试 } 客户端更新时带上 expectedVersion，Server 检查版本一致性，不一致就拒绝，客户端拿到最新版本后重试。\nHappy 追求观察一致（observational consistency）：所有端在任意时刻查询同一个会话，看到的 agentState 相同。不是最终一致（不容忍短暂不一致窗口），也不是强一致（不需要分布式事务）。OCC 的 expectedVersion 是实现手段，写操作带版本号，Server 做单点仲裁，冲突时拒绝而非合并。选观察一致而非最终一致，是因为 AI Coding 场景下，两个用户看到不同的 Agent 状态会直接导致操作冲突。\n4.4 控制权租约 多端连上 Server 后，谁发 prompt、谁批准 ApprovalRequest？Happy 用控制权租约解决。\n状态机：\n1 2 3 4 5 6 stateDiagram-v2 [*] --\u003e idle idle --\u003e leased: acquire_lease（成功） idle --\u003e idle: acquire_lease（被拒绝，已有控制端） leased --\u003e leased: renew_lease（续租） leased --\u003e idle: release_lease / lease_expired 规则：\n同一会话同一时刻只有一个 lease 控制端 lease 有超时，靠心跳续租。控制端断线后自动过期 非控制端只能观看输出，不能发 prompt 或响应 ApprovalRequest 控制端可主动释放，让另一个客户端获取控制权 客户端行为：\n场景 控制端 非控制端 Agent 输出 正常显示 正常显示 ApprovalRequest 弹出批准 UI 显示「等待控制端批准」 想发 prompt 正常发送 提示「先获取控制权」 断线 lease 超时后自动释放 不影响 边界情况：split-brain。网络分区时，控制端和 Server 断连，但本地仍认为自己持有 lease。Server 侧 lease 超时后释放，另一个客户端可以获取。原控制端重连后发现 lease 已失效，需重新获取。关键原则：Server 是唯一仲裁者，客户端本地的 lease 状态只是缓存，Server 的判定才算数。\n4.5 Server 还缺什么 Server 解决了 C1（跨网）、C2（单一数据源 + 版本化）、C3（控制权租约）、C5（E2EE + 盲转发）。\n但 C4 仍然失败。问题在开发机那端：谁管 Agent 进程？用户关掉终端窗口，CLI 退出，会话断了。Server 协调了多端通信，但管不了远端机器上的进程生命周期。需要一个在开发机上常驻的进程。\n5. 第四层：Daemon + CLI 分离 5.1 Daemon 的三个职责 Daemon 是 Happy 在开发机上的常驻后台进程，不做 AI 推理，只做三件事：\n管理会话子进程。维护 pidToTrackedSession Map，跟踪每个会话的 PID、sessionId、启动方式。 接收远程 spawn。手机点「新建会话」，Server 转发，Daemon 启动 CLI 子进程。 维护机器身份。通过 machine-scoped Socket 保持心跳，上报在线状态。 Daemon 启动时的初始化逻辑体现了这三个职责：\n1 2 3 4 5 6 7 // happy-cli/src/daemon/run.ts:145-168 const daemonLockHandle = await acquireDaemonLock(5, 200); if (!daemonLockHandle) { process.exit(0); // 已有 Daemon 在运行 } const { credentials, machineId } = await authAndSetupMachineIfNeeded(); const pidToTrackedSession = new Map\u003cnumber, TrackedSession\u003e(); 先获取排他锁（唯一性），再建立机器身份（职责 3），最后初始化会话跟踪表（职责 1）。\n5.2 排他锁 一台机器只能有一个 Daemon。Happy 用文件系统原子操作实现排他锁：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // happy-cli/src/persistence.ts:556-597（简化） async function acquireDaemonLock(maxAttempts, delayIncrementMs) { for (let attempt = 1; attempt \u003c= maxAttempts; attempt++) { try { const fileHandle = await open(configuration.daemonLockFile, constants.O_CREAT | constants.O_EXCL | constants.O_WRONLY); await fileHandle.writeFile(String(process.pid)); return fileHandle; } catch (error) { if (error.code === 'EEXIST') { const lockPid = readFileSync(configuration.daemonLockFile, 'utf-8'); try { process.kill(Number(lockPid), 0); // 信号 0：只检查进程是否存在 } catch { unlinkSync(configuration.daemonLockFile); // 进程已死，清理 continue; } } await new Promise(r =\u003e setTimeout(r, attempt * delayIncrementMs)); } } return null; } O_CREAT | O_EXCL 在文件系统层面原子，不存在 TOCTOU 竞态。锁文件写 PID，用 kill(pid, 0) 检测死进程，信号 0 不杀进程，只验证是否存在。\n5.3 Control Server：本地 IPC Daemon 在 127.0.0.1 上起一个 HTTP 服务，端口号写入 daemon.state.json。CLI 读取这个文件找到 Daemon：\n端点 用途 POST /session-started CLI 会话启动后上报 sessionId POST /list 列出所有活跃会话 POST /spawn-session 创建新会话（手机远程触发） POST /stop 优雅关闭 Daemon CLI 和 Daemon 通过 HTTP 解耦，不共享内存，不做进程间直接调用。\n5.4 为什么 CLI 和 Daemon 不能合并 这是最容易引发困惑的拆分。根源在于进程模型不兼容：\n特征 CLI Daemon 生命周期 敲一次命令，跑完退出 开机启动，永久常驻 stdio 需要 TTY（键盘输入 + 终端渲染） 无 TTY（detached, stdio: ignore） 并发 一次一个会话 同时管理多个会话 启动方式 用户手动执行 自动启动（launchd / systemd） Socket scope session-scoped machine-scoped 让 CLI 常驻意味着放弃 TTY，但本地交互需要 TTY 读键盘、渲染 UI。让 CLI 后台 fork 自己，stdin/stdout 断裂，本地交互无法继续。\nHappy 让 CLI 首次运行时自动 spawn Daemon：\n1 2 3 4 5 6 7 8 9 // happy-cli/src/index.ts:327-334 if (!(await isDaemonRunningCurrentlyInstalledHappyVersion())) { const daemonProcess = spawnHappyCLI(['daemon', 'start-sync'], { detached: true, // 独立于 CLI stdio: 'ignore', // 不继承 TTY env: process.env }); daemonProcess.unref(); // CLI 退出后 Daemon 继续活着 } detached: true + stdio: 'ignore' + unref()：三行配置把 Daemon 变成独立后台进程。CLI 保持「敲一次命令跑完就退」的 Unix 哲学。\n5.5 全部满足 约束 直连 +Gateway +Server +Daemon C1 跨网 ❌ ✅ ✅ ✅ C2 多端一致 ⚠️ ❌ ✅ ✅ C3 控制权 ❌ ❌ ✅ ✅ C4 会话独立 ❌ ❌ ❌ ✅ C5 安全 ⚠️ ⚠️ ✅ ✅ 四组件的完整拓扑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 graph TB subgraph 手机 App[App] end subgraph 公网 Server[Server] end subgraph 开发机 Daemon[Daemon] CLI1[CLI 会话 1] CLI2[CLI 会话 2] end App \u003c--\u003e|\"user-scoped Socket全局状态 + RPC 调用\"| Server CLI1 \u003c--\u003e|\"session-scoped Socket会话消息 + 状态变更\"| Server CLI2 \u003c--\u003e|\"session-scoped Socket\"| Server Daemon \u003c--\u003e|\"machine-scoped Socket心跳 + 远程 spawn\"| Server Daemon ---|\"HTTP 127.0.0.1daemon.state.json\"| CLI1 Daemon ---|\"HTTP 127.0.0.1\"| CLI2 三种 Socket scope 各走各的通道：App 通过 user-scoped 看全局、发 RPC，CLI 通过 session-scoped 收发会话消息，Daemon 通过 machine-scoped 维持心跳和接收远程 spawn。CLI 和 Daemon 之间通过本地 HTTP 解耦。\n6. 架构师视角：从零设计会怎样 6.1 三组件方案 只针对 Kimi CLI（单一 Provider）时，四组件可以缩减为三个：\n1 2 3 4 5 Client（iOS / Web） ↕ WSS + E2EE Relay Server（路由 + 认证 + 存储） ↕ WSS + E2EE Agent（开发机常驻 = Daemon + Provider Wrapper） 把 CLI 和 Daemon 合并成一个二进制：\nkimi-remote agent start → 常驻进程（Daemon 角色） kimi-remote agent attach → 终端 attach 到某个会话（CLI 角色） Happy 拆出独立 CLI 是因为要统一封装 Claude Code、Codex、Gemini 三种 Provider，每种输出格式不同，需要映射层转成统一的 9 种事件。Kimi CLI 只有一个 Provider，这层封装可以内嵌。\n但三组件方案还有一个更根本的问题：实际使用中，开发者在一台机器上同时开很多个 CLI，一个 task 一个 CLI。重构一个模块、跑测试、写文档，三件事并行，三个终端窗口各跑一个会话。合并后的 Agent 二进制要么只能同时处理一个任务（不可接受），要么需要在内部管理 N 个并发会话子进程——本质上重新实现了 Daemon 的进程管理职责。kimi-remote agent attach 也需要找到正确的会话再接入，这和 CLI 通过 daemon.state.json 找 Daemon 是同一套机制。\n换句话说，即使解决了 Provider 统一封装的问题，多实例并发的使用习惯仍然会把「合并后的 Agent」逼回 Daemon + CLI 的分离结构。Happy 的四组件不只是因为多 Provider 才拆分，而是因为 CLI 的生命周期（一个任务一个进程，用完即走）和 Daemon 的生命周期（常驻，管理所有活跃会话）在本质上不同。\n6.2 不可省略的部分 无论怎么简化：\nServer 不可省。它解决物理约束：NAT 穿透和多端一致性。只要手机和开发机不在同一网络，就需要双方都能访问的中继。 Daemon 不可省。它解决进程约束：会话生命周期独立于前端。只要「关掉终端后 Agent 继续跑」是需求，就需要常驻进程。 组件数量是约束数量的函数。放宽约束可以减少组件：\n放宽的约束 可省略 代价 不需要跨网 Server 失去公网可达 不需要本地终端交互 CLI（合并到 Agent） 回到电脑时无法在终端继续 只有一个 Provider Provider 封装层 不影响功能 Server 自己部署 E2EE 安全性自己负责 6.3 约束推导方法：五维度扫描 上面的约束列表怎么推导出来的？靠一个固定的扫描清单。\n面对任何远程操控场景，画出最简架构（两个节点一条线），按五个维度依次提问：\n维度 问的问题 答案为「是」时产生的约束 网络 A 能直接找到 B 吗？ 跨网可达 一致性 多个观察者看到的状态一样吗？ 多端状态一致 并发 多个操作者同时动手会冲突吗？ 控制权互斥 生命周期 UI 挂了，后台任务也死吗？ 会话独立于前端 交互模式 所有用户用同一种界面吗？ CLI / Daemon 分离 五个维度从物理层到应用层排列，先解决低层问题再考虑高层。每个维度用同一个问题检验：不处理的话，能构造出什么灾难场景？ 能构造出来 → 硬约束。构造不出来 → 软偏好，可以延后。\n以「控制权互斥」为例：多端连上后，能不能不做互斥，让用户先后操控？可以，lease 机制本质上就在实现「先后操控」。但谁来保证先后？没有 Server 维护 lease，两个客户端都认为自己是控制端，同时发 prompt，Agent 收到矛盾指令。约束不是「要不要互斥」，而是「谁来仲裁」。\n这个方法的原型是航空业的起飞前检查清单。1935 年，波音 Model 299（B-17 原型）试飞坠毁，原因是试飞员忘记释放升降舵锁，飞机太复杂，超出了一个人的记忆力极限。波音发明了检查清单。五维度扫描解决同一个问题：不是给新手用的拐杖，是给专家用的认知外骨骼。\n日常版本：旅行前拍脑袋收拾行李，带三件外套却忘充电器。架构设计中「WebSocket 能不能连上」是外套，「关掉终端后会话还在不在」是充电器。\n延伸练习 把这个方法用在一个新场景上：设计一个「手机远程操控家里电脑 Docker 容器」的系统，手机上启动/停止容器、查看日志、执行命令。\n画出最简架构 按五个维度扫描，每个维度构造一个灾难场景 对每个灾难场景决定加什么组件 和 Happy 的四组件对比：哪些一样？哪些不需要？为什么？ 写不出灾难场景的维度，恰好说明那个约束在这个场景下不存在，这本身就是有价值的结论。\n7. Wire 协议能复用吗：分层拆解 Kimi CLI 的 Web UI 已有 Wire 协议（JSON-RPC 2.0）和 BroadcastQueue，远程方案能直接复用还是推翻重来？\n答案是按层看。\n7.1 三层拆解 把 Wire 协议拆成三层，逐层评估：\n层 包含什么 能复用吗 理由 应用语义层 17 种事件类型 + 2 种请求类型 + WireMessageEnvelope 格式 ✅ 100% 复用 消息的含义不因传输方式改变 会话管理层 客户端身份、消息排序、请求匹配、控制权、心跳 ❌ 需要新增 本地方案没有这一层 传输层 stdio 管道、localhost WebSocket ⚠️ 替换 从本地换成公网 WSS + 中继 关键发现：Wire 协议目前只有两层（应用语义 + 传输），会话管理层是空的。这不是设计缺陷，本地场景不需要，但远程场景必须补上。\n7.2 应用语义层：直接搬 Wire 定义的事件类型是纯业务语义，不绑定传输假设：TurnBegin/TurnEnd 标记对话边界，ContentPart 承载流式输出，ToolCall/ToolResult 处理工具调用，ApprovalRequest 请求用户批准。无论走 stdio、localhost WebSocket 还是公网 WSS 中继，这些消息格式都不需要改。\nBroadcastQueue 的 SPMC 模式也可复用。Server 收到 Agent 消息后，用同样的「一个生产者、多个消费者」模式广播给同一会话的所有订阅者。\n7.3 会话管理层：必须新增 这是最大的工作量。本地方案有三个隐含假设，远程场景下全部失效：\n假设 1：只有一个客户端。_pending_requests 是全局字典，没有客户端隔离：\n1 2 # wire/server.py — 当前 self._pending_requests: dict[str, Request] = {} 远程场景需要按会话隔离，同一个 ApprovalRequest 只能由当前控制端响应。\n假设 2：消息天然有序。stdio 是单流，到达顺序就是发送顺序。公网 WebSocket 经中继后可能乱序。需要在每条消息上加 seq：\n1 2 # 远程方案需要 {\"seq\": 42, \"session_id\": \"abc\", \"message\": {...}} Happy 的 CoreUpdateContainer 正是这样做的，每条 update 带 id（去重）和 seq（排序）。\n假设 3：连接不会断。stdio 管道在进程活着时永远不断。公网连接随时可能断（WebSocket 断开、App 后台挂起、Server 重启），需要心跳检测和断线重连后的状态同步。\n最小可用的重连策略：客户端维护 lastSeenSeq，重连后发送 {\"resume\": true, \"lastSeenSeq\": 41}，Server 从事件日志中找到 seq \u003e 41 的消息重放。事件日志已滚动时，回退到全量快照 + 从快照版本订阅增量。去重靠 seq 单调递增，客户端忽略 seq ≤ lastSeenSeq 的消息。Wire 的 JSONL 文件格式可以作为回放源，Kimi CLI 的 _replay_buffers 机制可以复用。\n「会话管理层」工作量最大的原因在此：不只是加几个字段，而是一套完整的断线恢复协议。\n7.4 传输层：整体替换 从 stdio 管道换成 WSS + 中继 Server，这是基础设施变更。asyncio.Future（本地等待请求响应）不能跨网络传递，需要替换为带超时的回调机制。Happy 的 emitWithAck + 30 秒超时就是一种实现。\n7.5 结论：六成复用，四成新增 工作项 工作量 复用率 消息类型定义（17 + 2） 零 100% 序列化格式（JSON-RPC 2.0） 零 100% BroadcastQueue / 回放机制 小 80% 会话管理（身份 / 排序 / 心跳） 大 0%（新增） 控制权租约 中 0%（新增） 传输层替换（stdio → WSS） 中 0%（替换） 不需要推翻重来，也不能原样照搬。应用语义层完整复用，会话管理层从零新增，传输层整体替换。\n7.6 分层复用的 mindset 上面的分析用的思维方式是按层拆解，逐层判断。面对「现有系统迁移到新环境」，不陷入「推翻重来」和「原样复用」的二元争论，而是拆成层，每层独立评估。\n这个方法有一个跨越 150 年的同构案例：明治维新。不是全盘西化，也不是完全拒绝。伊藤博文按层拆解：军事技术层→全面引进西方模式（传输层替换）。行政制度层→选择性改造，学普鲁士而非英法，因为普鲁士的君主立宪更兼容天皇制（会话管理层重新设计）。文化认同层→保留天皇制和神道教（应用语义层复用）。\n日常版本：换城市工作。衣服直接搬，不绑定城市。健身房重新办卡，会员绑定旧的地理位置。朋友关系继续维护，但方式从线下聚餐变为线上联系，复用关系本身，替换承载渠道。\n小结 回到开篇：手机远程操控 AI Coding CLI，为什么不是「一个 WebSocket」就能搞定？\n五个约束逐层叠加，每个淘汰一种更简单的方案：\nNAT 穿透淘汰了直连。手机找不到 NAT 后面的开发机，必须有公网中继（Server） 多端一致性淘汰了无状态 Gateway。Gateway 只转发不协调，两端状态可能不一致 控制权互斥要求 Server 理解协议语义。Gateway 不知道谁是控制端 会话独立于前端要求常驻进程。关掉终端不能杀死 Agent（Daemon） 本地 + 远程并存让 CLI 和 Daemon 无法合并。TTY 需求和 detached 后台进程模型冲突，且实际使用中一台机器同时跑多个 CLI（一个任务一个进程），Daemon 必须作为独立进程管理这些并发会话 Happy 的四组件恰好对应这五个约束。场景更简单时可以缩减到三组件，但 Server 和 Daemon 不可省，它们解决的是物理约束，不是设计偏好。\n判断自己需要几个组件（Mermaid 图略，同前文）\n协议层面，Wire 协议不需要推翻：应用语义层 100% 复用，会话管理层从零新增，传输层整体替换。\n文章用了三个可迁移的思维方法：\n方法 核心动作 远镜类比 近镜类比 逐步证伪法 从最简方案出发，用失败场景逼出组件 英国普通法：每条判例对应一次真实失败 搬新家：每件物品对应一个具体不便 五维度扫描法 按固定清单逐层检查「不处理会怎样」 B-17 坠毁催生飞行检查清单 旅行打包：显眼物品挤占注意力 分层复用分析法 按层拆解，逐层判断复用/扩展/新增 明治维新按层判断西化程度 换城市：衣服搬走、健身房重办、朋友维护 三个方法对应架构设计的三个阶段：发现约束、梳理约束、迁移方案。\n","wordCount":"2188","inLanguage":"zh","datePublished":"2026-02-17T09:50:00+08:00","dateModified":"2026-02-17T11:00:37+08:00","author":{"@type":"Person","name":"Miss-you"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://miss-you.github.io/posts/20260217-websocket-to-four-components/"},"publisher":{"@type":"Organization","name":"Yousa Driven Development | YDD","logo":{"@type":"ImageObject","url":"https://miss-you.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://miss-you.github.io/ accesskey=h title="Yousa Driven Development | YDD (Alt + H)">Yousa Driven Development | YDD</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://miss-you.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://miss-you.github.io/archives title=归档><span>归档</span></a></li><li><a href=https://miss-you.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://miss-you.github.io/tools/ title=工具><span>工具</span></a></li><li><a href=https://miss-you.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://github.com/Miss-you title=GitHub><span>GitHub</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://miss-you.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://miss-you.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化</h1><div class=post-description>从最简方案开始，每遇到一个绕不过去的约束就加一个组件。四层方案逐层淘汰，最终发现四组件是五个硬约束逐层叠加的必然结果。</div><div class=post-meta><span title='2026-02-17 09:50:00 +0800 +0800'>二月 17, 2026</span>&nbsp;·&nbsp;11 分钟&nbsp;·&nbsp;17731 字&nbsp;·&nbsp;Miss-you&nbsp;|&nbsp;<a href=https://github.com/Miss-you/miss-you.github.io/tree/main/content/posts/20260217-websocket-to-four-components/index.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-五个硬约束>1. 五个硬约束</a><ul><li><a href=#为什么是这五个>为什么是这五个</a></li></ul></li><li><a href=#2-第一层app-直连-web-ui>2. 第一层：App 直连 Web UI</a><ul><li><a href=#21-kimi-cli-的现有能力>2.1 Kimi CLI 的现有能力</a></li><li><a href=#22-卡在哪里>2.2 卡在哪里</a></li></ul></li><li><a href=#3-第二层web-ui--gateway>3. 第二层：Web UI + Gateway</a></li><li><a href=#4-第三层有状态的-server>4. 第三层：有状态的 Server</a><ul><li><a href=#41-三种-socket-scope>4.1 三种 Socket Scope</a></li><li><a href=#42-rpc为什么消息流不够>4.2 RPC：为什么消息流不够</a></li><li><a href=#43-乐观并发控制>4.3 乐观并发控制</a></li><li><a href=#44-控制权租约>4.4 控制权租约</a></li><li><a href=#45-server-还缺什么>4.5 Server 还缺什么</a></li></ul></li><li><a href=#5-第四层daemon--cli-分离>5. 第四层：Daemon + CLI 分离</a><ul><li><a href=#51-daemon-的三个职责>5.1 Daemon 的三个职责</a></li><li><a href=#52-排他锁>5.2 排他锁</a></li><li><a href=#53-control-server本地-ipc>5.3 Control Server：本地 IPC</a></li><li><a href=#54-为什么-cli-和-daemon-不能合并>5.4 为什么 CLI 和 Daemon 不能合并</a></li><li><a href=#55-全部满足>5.5 全部满足</a></li></ul></li><li><a href=#6-架构师视角从零设计会怎样>6. 架构师视角：从零设计会怎样</a><ul><li><a href=#61-三组件方案>6.1 三组件方案</a></li><li><a href=#62-不可省略的部分>6.2 不可省略的部分</a></li><li><a href=#63-约束推导方法五维度扫描>6.3 约束推导方法：五维度扫描</a></li><li><a href=#延伸练习>延伸练习</a></li></ul></li><li><a href=#7-wire-协议能复用吗分层拆解>7. Wire 协议能复用吗：分层拆解</a><ul><li><a href=#71-三层拆解>7.1 三层拆解</a></li><li><a href=#72-应用语义层直接搬>7.2 应用语义层：直接搬</a></li><li><a href=#73-会话管理层必须新增>7.3 会话管理层：必须新增</a></li><li><a href=#74-传输层整体替换>7.4 传输层：整体替换</a></li><li><a href=#75-结论六成复用四成新增>7.5 结论：六成复用，四成新增</a></li><li><a href=#76-分层复用的-mindset>7.6 分层复用的 mindset</a></li></ul></li><li><a href=#小结>小结</a></li></ul></nav></div></details></div><div class=post-content><h1 id=从一个-websocket-到四个组件多端操控-ai-coding-cli-的架构演化>从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化<a hidden class=anchor aria-hidden=true href=#从一个-websocket-到四个组件多端操控-ai-coding-cli-的架构演化>#</a></h1><p>手机远程操控电脑上的 AI Coding CLI，直觉上只需一个 WebSocket。CLI 在电脑上跑着，手机连上去，发消息，收输出，结束。</p><p>Kimi CLI 的 Web UI 做到了这一步。执行 <code>kimi web</code>，本地起一个 HTTP + WebSocket 服务，浏览器打开就能用。底层 Wire 协议（JSON-RPC 2.0）支持多个 WebSocket 客户端同时接入，消息通过 <code>BroadcastQueue</code> 广播给所有订阅者。手机套个 WebView 就行了？</p><p>但 Happy 项目把同样的需求拆成了四个独立组件：CLI、Daemon、Server、App。四个进程，三种 Socket 连接类型，一套 RPC 转发机制，外加端到端加密（E2EE）。</p><p>为什么？</p><p>这篇文章用两个真实项目的源码回答。从最简的直连方案开始，每遇到一个绕不过去的约束就加一个组件。四层方案逐层淘汰，最终会发现：四组件不是过度设计，而是五个硬约束逐层叠加的必然结果。</p><p>读完后能得到：</p><ol><li>每个组件存在的「不可替代的理由」，以及没有它会怎样</li><li>Happy 和 Kimi CLI 在消息路由、进程管理、控制权协调上的关键设计细节</li><li>一棵决策树，根据自己的场景判断需要几个组件、哪些可以省</li><li>现有 Wire 协议哪些能复用、哪些必须新增的分层分析</li></ol><p><strong>阅读路线</strong>：</p><ul><li>只想知道为什么不是一个 WebSocket → 第 1 节 + 小结</li><li>想理解 Happy 的核心机制 → 第 4 节（scope / RPC / 租约 / E2EE）+ 第 5 节（Daemon）</li><li>想设计自己的远程操控系统 → 第 6.3 节（五维度扫描）+ 小结决策树</li><li>想做协议复用 / 迁移评估 → 第 7 节</li></ul><hr><h2 id=1-五个硬约束>1. 五个硬约束<a hidden class=anchor aria-hidden=true href=#1-五个硬约束>#</a></h2><p>拆解方案之前，先定义检验标准。「手机远程操控电脑上的 AI Coding CLI」拆成五个约束：</p><table><thead><tr><th>#</th><th>约束</th><th>含义</th></tr></thead><tbody><tr><td>C1</td><td>跨网可达</td><td>手机在 4G/5G，开发机在 NAT 后面，两者能通信</td></tr><tr><td>C2</td><td>多端一致</td><td>手机和电脑看到的会话状态完全一致</td></tr><tr><td>C3</td><td>控制权互斥</td><td>同一时刻只有一个终端控制 Agent</td></tr><tr><td>C4</td><td>会话独立于前端</td><td>关掉手机或终端，Agent 继续跑，重新打开能接上</td></tr><tr><td>C5</td><td>安全</td><td>至少有认证，理想情况下 E2EE</td></tr></tbody></table><h3 id=为什么是这五个>为什么是这五个<a hidden class=anchor aria-hidden=true href=#为什么是这五个>#</a></h3><p>这张表是<strong>逐步证伪</strong>得到的，从最简方案开始，每一步找一个打破它的场景，被迫加一个组件，直到没有场景能打破：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>起点：手机直连电脑（一个 WebSocket）
</span></span><span class=line><span class=cl>  │
</span></span><span class=line><span class=cl>  ├─ &#34;手机 4G，电脑在家 WiFi&#34; → 连不上 → 需要公网中继
</span></span><span class=line><span class=cl>  │
</span></span><span class=line><span class=cl>  ├─ &#34;手机和电脑同时连上&#34; → 消息顺序不一致 → 中继要理解协议、做排序
</span></span><span class=line><span class=cl>  │
</span></span><span class=line><span class=cl>  ├─ &#34;两个客户端同时发 prompt&#34; → 谁算数？→ 要有人仲裁控制权
</span></span><span class=line><span class=cl>  │
</span></span><span class=line><span class=cl>  ├─ &#34;关掉终端窗口&#34; → Agent 跟着死了 → 需要独立的常驻进程
</span></span><span class=line><span class=cl>  │
</span></span><span class=line><span class=cl>  └─ &#34;在电脑上也想交互式操作&#34; → 常驻进程没有 TTY → 需要额外的交互前端
</span></span></code></pre></td></tr></table></div></div><p>这个拆解有三个性质：</p><ol><li><strong>每个约束都有反例</strong>。删掉任何一个，都能构造一个具体的故障场景，后面四节逐一展示。</li><li><strong>约束之间有依赖序</strong>。讨论「控制权互斥」的前提是「多端已连上」，讨论「多端连接」的前提是「网络可达」。链条是：网络可达 → 多端共存 → 多端冲突 → 进程生命周期 → 交互模式分离。每一层的问题，只有前一层解决后才会暴露。</li><li><strong>每个约束恰好淘汰一种方案</strong>。没有两个约束淘汰同一种方案，没有冗余。</li></ol><p>「从最简开始，被失败逼着加组件」的方法有一个跨越八百年的同构案例：英国普通法。不是一次性写出完美法典，而是每次新型案件暴露旧规则的不足，法官被迫创造新判例。每条规则指向一次真实的失败，和每个组件指向一个具体的约束是同一套逻辑。更贴身的版本：搬进新家三个月，家里每件东西都对应一个真实的不便，没有一件多余。</p><p>后面每种方案都用这五个约束打分。</p><hr><h2 id=2-第一层app-直连-web-ui>2. 第一层：App 直连 Web UI<a hidden class=anchor aria-hidden=true href=#2-第一层app-直连-web-ui>#</a></h2><h3 id=21-kimi-cli-的现有能力>2.1 Kimi CLI 的现有能力<a hidden class=anchor aria-hidden=true href=#21-kimi-cli-的现有能力>#</a></h3><p>Kimi CLI 已具备外部 UI 接入的基础设施。执行 <code>kimi web</code>，本地起一个 FastAPI 服务，浏览器通过 WebSocket 连接 Wire 协议与 Agent 内核交互。</p><p>底层消息分发采用 SPMC（Single Producer, Multiple Consumer）广播队列：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># kimi-cli/src/kimi_cli/utils/broadcast.py</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BroadcastQueue</span><span class=p>[</span><span class=n>T</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_queues</span><span class=p>:</span> <span class=nb>set</span><span class=p>[</span><span class=n>Queue</span><span class=p>[</span><span class=n>T</span><span class=p>]]</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>subscribe</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Queue</span><span class=p>[</span><span class=n>T</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>queue</span><span class=p>:</span> <span class=n>Queue</span><span class=p>[</span><span class=n>T</span><span class=p>]</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_queues</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>queue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>publish_nowait</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>item</span><span class=p>:</span> <span class=n>T</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>queue</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>_queues</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>queue</span><span class=o>.</span><span class=n>put_nowait</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>每个 WebSocket 客户端调用 <code>subscribe()</code> 获得自己的队列，Agent 内核每产生一条消息就通过 <code>publish_nowait</code> 广播给所有订阅者。多个客户端可以同时观看同一个会话的输出。</p><p>新客户端中途加入时，<code>SessionProcess</code> 用缓冲机制衔接历史回放和实时消息：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># kimi-cli/src/kimi_cli/web/runner/process.py:526-538</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>_broadcast</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>message</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ws_lock</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>to_send</span><span class=p>:</span> <span class=nb>list</span><span class=p>[</span><span class=n>WebSocket</span><span class=p>]</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>ws</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>_websockets</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>buffer</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_replay_buffers</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>ws</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>buffer</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>buffer</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>message</span><span class=p>)</span>   <span class=c1># 正在回放历史：缓冲实时消息</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>to_send</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>ws</span><span class=p>)</span>       <span class=c1># 已进入实时：直接发送</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>ws</span> <span class=ow>in</span> <span class=n>to_send</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=n>ws</span><span class=o>.</span><span class=n>send_text</span><span class=p>(</span><span class=n>message</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>正在回放 <code>wire.jsonl</code> 历史的客户端，实时消息暂存到 <code>_replay_buffers</code>。回放结束后 flush 缓冲区，无缝切到实时流，保证中途加入不丢消息。</p><h3 id=22-卡在哪里>2.2 卡在哪里<a hidden class=anchor aria-hidden=true href=#22-卡在哪里>#</a></h3><p><strong>C1 跨网失败</strong>。Web 服务默认绑定 <code>127.0.0.1</code>，加 <code>--network</code> 后绑 <code>0.0.0.0</code>，但开发机仍在 NAT 后面。手机在 4G 网络上找不到这台机器。用户需要自己搞 Tailscale 或 ngrok，不是产品化方案。</p><p><strong>C3 控制权失败</strong>。Wire 协议的请求响应是 1:1 的。Agent 发出 <code>ApprovalRequest</code> 时，请求放进一个全局字典：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># kimi-cli/src/kimi_cli/wire/server.py:75-76</span>
</span></span><span class=line><span class=cl><span class=bp>self</span><span class=o>.</span><span class=n>_pending_requests</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Request</span><span class=p>]</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;Maps JSON RPC message IDs to pending Requests.&#34;&#34;&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>这正是 C3 失败的根源：字典没有客户端隔离。两个 WebSocket 同时连接时，都能看到同一个 <code>ApprovalRequest</code>，都能响应，谁先回复谁生效。两个客户端还可以在会话空闲时同时发 prompt，<code>is_busy</code> 检查不起作用。</p><p><strong>C4 会话独立失败</strong>。Worker 子进程的生命周期绑定在 FastAPI 服务上：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># kimi-cli/src/kimi_cli/web/app.py:168-186</span>
</span></span><span class=line><span class=cl><span class=nd>@asynccontextmanager</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>lifespan</span><span class=p>(</span><span class=n>app</span><span class=p>:</span> <span class=n>FastAPI</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>runner</span> <span class=o>=</span> <span class=n>KimiCLIRunner</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>app</span><span class=o>.</span><span class=n>state</span><span class=o>.</span><span class=n>runner</span> <span class=o>=</span> <span class=n>runner</span>
</span></span><span class=line><span class=cl>    <span class=n>runner</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>yield</span>
</span></span><span class=line><span class=cl>    <span class=k>finally</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=n>runner</span><span class=o>.</span><span class=n>stop</span><span class=p>()</span>  <span class=c1># Web 服务关闭 → 所有 Worker 子进程被杀</span>
</span></span></code></pre></td></tr></table></div></div><p>关掉终端窗口，Web 服务退出，<code>runner.stop()</code> 杀死所有 Worker 子进程，会话丢失。</p><table><thead><tr><th>约束</th><th style=text-align:center>直连方案</th></tr></thead><tbody><tr><td>C1 跨网</td><td style=text-align:center>❌</td></tr><tr><td>C2 多端一致</td><td style=text-align:center>⚠️ 广播可用，无协调</td></tr><tr><td>C3 控制权</td><td style=text-align:center>❌</td></tr><tr><td>C4 会话独立</td><td style=text-align:center>❌</td></tr><tr><td>C5 安全</td><td style=text-align:center>⚠️ Token，无 E2EE</td></tr></tbody></table><hr><h2 id=3-第二层web-ui--gateway>3. 第二层：Web UI + Gateway<a hidden class=anchor aria-hidden=true href=#3-第二层web-ui--gateway>#</a></h2><p>最直觉的补救：在 Web UI 前加一层反向代理（Caddy、nginx、Cloudflare Tunnel），解决网络可达和 TLS 终止。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>iPhone ──HTTPS/WSS──▶ Gateway（公网） ──HTTP/WS──▶ 开发机 kimi web
</span></span></code></pre></td></tr></table></div></div><p>C1 跨网解决了，C5 传输层加密有了。但 Gateway 只是管道，不理解 Wire 协议语义：</p><ul><li><strong>C2 多端一致</strong>：Gateway 透明转发，没有人协调消息顺序</li><li><strong>C3 控制权</strong>：Gateway 不知道谁是控制端，两个客户端仍可同时发 prompt</li><li><strong>C4 会话独立</strong>：Worker 仍绑在 Web 服务进程上，Gateway 管不了进程生命周期</li></ul><p>两个客户端通过 Gateway 同时连接时的冲突场景：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sequenceDiagram
</span></span><span class=line><span class=cl>    participant 手机 as 手机
</span></span><span class=line><span class=cl>    participant GW as Gateway
</span></span><span class=line><span class=cl>    participant Agent as Agent
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Agent-&gt;&gt;GW: ApprovalRequest (rm -rf /tmp/build)
</span></span><span class=line><span class=cl>    GW-&gt;&gt;手机: ApprovalRequest
</span></span><span class=line><span class=cl>    GW-&gt;&gt;终端: ApprovalRequest
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    手机-&gt;&gt;GW: approve ✓
</span></span><span class=line><span class=cl>    终端-&gt;&gt;GW: approve ✓ (晚 200ms)
</span></span><span class=line><span class=cl>    GW-&gt;&gt;Agent: approve (手机的先到，生效)
</span></span><span class=line><span class=cl>    GW-&gt;&gt;Agent: approve (终端的后到，被丢弃)
</span></span><span class=line><span class=cl>    Note over 手机,终端: 两个用户都以为是自己批准的
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Note over Agent: session 变为空闲
</span></span><span class=line><span class=cl>    手机-&gt;&gt;GW: prompt &#34;run tests&#34;
</span></span><span class=line><span class=cl>    终端-&gt;&gt;GW: prompt &#34;deploy to prod&#34;
</span></span><span class=line><span class=cl>    GW-&gt;&gt;Agent: 两个 prompt 同时到达
</span></span><span class=line><span class=cl>    Note over Agent: 都通过 is_busy 检查&lt;br/&gt;先到的执行，后到的被忽略&lt;br/&gt;→ 一个用户：我发了命令，为什么没反应？
</span></span></code></pre></td></tr></table></div></div><p>Gateway 忠实转发了每条消息，但它不知道谁该说话、谁该等待。</p><p>Gateway 部署在第三方时，它作为中间人能看到所有明文，代码、对话、工具调用参数对第三方完全透明。</p><table><thead><tr><th>约束</th><th style=text-align:center>直连</th><th style=text-align:center>+Gateway</th></tr></thead><tbody><tr><td>C1 跨网</td><td style=text-align:center>❌</td><td style=text-align:center>✅</td></tr><tr><td>C2 多端一致</td><td style=text-align:center>⚠️</td><td style=text-align:center>❌</td></tr><tr><td>C3 控制权</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td></tr><tr><td>C4 会话独立</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td></tr><tr><td>C5 安全</td><td style=text-align:center>⚠️</td><td style=text-align:center>⚠️ TLS only</td></tr></tbody></table><p><strong>常见替代方案为什么不够</strong>：</p><table><thead><tr><th>方案</th><th>解决了什么</th><th>没解决什么</th><th>代价</th></tr></thead><tbody><tr><td>SSH 隧道 + tmux</td><td>C1 跨网、C4 会话独立</td><td>C2 多端协调、C3 控制权仲裁</td><td>手机上没有 SSH 终端体验；需暴露 SSH 端口</td></tr><tr><td>VPN（Tailscale）</td><td>C1 跨网</td><td>C2-C5 全部</td><td>退回直连方案，只解决网络层</td></tr><tr><td>WebRTC P2P</td><td>C1 跨网（打洞）</td><td>C4 无常驻进程管理</td><td>打洞成功率不稳定；TURN fallback 等于回到 Server 方案</td></tr></tbody></table><p>每种方案都只解决约束链的一两环，剩下的约束不会消失，只是被推迟。</p><hr><h2 id=4-第三层有状态的-server>4. 第三层：有状态的 Server<a hidden class=anchor aria-hidden=true href=#4-第三层有状态的-server>#</a></h2><p>把 Gateway 升级为「理解业务语义的 Server」。这是 Happy 架构中最重量级的组件。</p><h3 id=41-三种-socket-scope>4.1 三种 Socket Scope<a hidden class=anchor aria-hidden=true href=#41-三种-socket-scope>#</a></h3><p>Happy Server 不是简单地广播消息给所有连接。每个 Socket.IO 连接在握手时声明类型，Server 按类型分发：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-server/sources/app/api/socket.ts:37-40
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>clientType</span> <span class=o>=</span> <span class=nx>socket</span><span class=p>.</span><span class=nx>handshake</span><span class=p>.</span><span class=nx>auth</span><span class=p>.</span><span class=nx>clientType</span>
</span></span><span class=line><span class=cl>    <span class=kr>as</span> <span class=s1>&#39;session-scoped&#39;</span> <span class=o>|</span> <span class=s1>&#39;user-scoped&#39;</span> <span class=o>|</span> <span class=s1>&#39;machine-scoped&#39;</span> <span class=o>|</span> <span class=kc>undefined</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>sessionId</span> <span class=o>=</span> <span class=nx>socket</span><span class=p>.</span><span class=nx>handshake</span><span class=p>.</span><span class=nx>auth</span><span class=p>.</span><span class=nx>sessionId</span> <span class=kr>as</span> <span class=kt>string</span> <span class=o>|</span> <span class=kc>undefined</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>machineId</span> <span class=o>=</span> <span class=nx>socket</span><span class=p>.</span><span class=nx>handshake</span><span class=p>.</span><span class=nx>auth</span><span class=p>.</span><span class=nx>machineId</span> <span class=kr>as</span> <span class=kt>string</span> <span class=o>|</span> <span class=kc>undefined</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>验证通过后，Server 按 <code>clientType</code> 构建连接对象并注册到 <code>eventRouter</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7>7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8>8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-server/sources/app/api/socket.ts:78-100
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nx>metadata</span><span class=p>.</span><span class=nx>clientType</span> <span class=o>===</span> <span class=s1>&#39;session-scoped&#39;</span> <span class=o>&amp;&amp;</span> <span class=nx>sessionId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>connection</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>connectionType</span><span class=o>:</span> <span class=s1>&#39;session-scoped&#39;</span><span class=p>,</span> <span class=nx>socket</span><span class=p>,</span> <span class=nx>userId</span><span class=p>,</span> <span class=nx>sessionId</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>metadata</span><span class=p>.</span><span class=nx>clientType</span> <span class=o>===</span> <span class=s1>&#39;machine-scoped&#39;</span> <span class=o>&amp;&amp;</span> <span class=nx>machineId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>connection</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>connectionType</span><span class=o>:</span> <span class=s1>&#39;machine-scoped&#39;</span><span class=p>,</span> <span class=nx>socket</span><span class=p>,</span> <span class=nx>userId</span><span class=p>,</span> <span class=nx>machineId</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>connection</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>connectionType</span><span class=o>:</span> <span class=s1>&#39;user-scoped&#39;</span><span class=p>,</span> <span class=nx>socket</span><span class=p>,</span> <span class=nx>userId</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>eventRouter</span><span class=p>.</span><span class=nx>addConnection</span><span class=p>(</span><span class=nx>userId</span><span class=p>,</span> <span class=nx>connection</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>三种 scope 各有职责：</p><table><thead><tr><th>Scope</th><th>使用者</th><th>接收</th><th>发送</th></tr></thead><tbody><tr><td>user-scoped</td><td>App / Web</td><td>全局更新（会话列表、机器状态）</td><td>ping、usage 上报</td></tr><tr><td>session-scoped</td><td>CLI 会话进程</td><td>特定会话的消息更新</td><td>消息、状态变更</td></tr><tr><td>machine-scoped</td><td>Daemon</td><td>机器级指令、RPC 请求</td><td>心跳、在线状态</td></tr></tbody></table><p>手机打开某个会话时只订阅该会话的流，不会收到其他会话的消息。比 Kimi Web UI 的「所有消息广播给所有客户端」精细得多。</p><h3 id=42-rpc为什么消息流不够>4.2 RPC：为什么消息流不够<a hidden class=anchor aria-hidden=true href=#42-rpc为什么消息流不够>#</a></h3><p>消息流是 fire-and-forget 的，Server 推 update 给订阅者，不等回复。但有些操作需要同步等待响应：中止当前 turn、批准权限请求、远程执行 bash 命令并拿到输出。</p><p>Happy 在 Socket.IO 上实现了一套 RPC 转发，核心链路三步：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sequenceDiagram
</span></span><span class=line><span class=cl>    participant App as App (手机)
</span></span><span class=line><span class=cl>    participant Server as Server (公网)
</span></span><span class=line><span class=cl>    participant CLI as CLI (开发机)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Note over CLI,Server: 1. 注册
</span></span><span class=line><span class=cl>    CLI-&gt;&gt;Server: rpc-register({method: &#34;session-abc:bash&#34;})
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Note over App,CLI: 2. 转发
</span></span><span class=line><span class=cl>    App-&gt;&gt;Server: rpc-call({method: &#34;session-abc:bash&#34;, params: encrypted})
</span></span><span class=line><span class=cl>    Server-&gt;&gt;CLI: rpc-request({method, params})
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Note over App,CLI: 3. 执行 + 返回
</span></span><span class=line><span class=cl>    CLI--&gt;&gt;CLI: decrypt → handler(params) → encrypt
</span></span><span class=line><span class=cl>    CLI-&gt;&gt;Server: response (encrypted)
</span></span><span class=line><span class=cl>    Server-&gt;&gt;App: callback({ok: true, result: encrypted})
</span></span></code></pre></td></tr></table></div></div><p>Server 全程只做 socket 到 socket 的盲转发，看不到 <code>params</code> 和 <code>result</code> 的明文。</p><p><strong>注册</strong>。CLI 会话启动时，通过 <code>RpcHandlerManager</code> 向 Server 注册能处理的方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-cli/src/api/rpc/RpcHandlerManager.ts:36-47
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>registerHandler</span><span class=p>&lt;</span><span class=nt>TRequest</span><span class=p>,</span> <span class=na>TResponse</span><span class=p>&gt;(</span>
</span></span><span class=line><span class=cl>    <span class=nx>method</span>: <span class=kt>string</span><span class=p>,</span> <span class=nx>handler</span>: <span class=kt>RpcHandler</span><span class=p>&lt;</span><span class=nt>TRequest</span><span class=p>,</span> <span class=na>TResponse</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>)</span><span class=o>:</span> <span class=k>void</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>prefixedMethod</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>getPrefixedMethod</span><span class=p>(</span><span class=nx>method</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>handlers</span><span class=p>.</span><span class=kr>set</span><span class=p>(</span><span class=nx>prefixedMethod</span><span class=p>,</span> <span class=nx>handler</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>socket</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>socket</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;rpc-register&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>method</span>: <span class=kt>prefixedMethod</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>方法名带 <code>sessionId</code> 前缀（如 <code>session-abc:bash</code>），Server 用它路由。</p><p><strong>转发</strong>。App 发 <code>rpc-call</code>，Server 查找目标 socket 并转发：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14>14</a>
</span><span class=lnt id=hl-11-15><a class=lnlinks href=#hl-11-15>15</a>
</span><span class=lnt id=hl-11-16><a class=lnlinks href=#hl-11-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-server/sources/app/api/socket/rpcHandler.ts:67-114（简化）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>socket</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;rpc-call&#39;</span><span class=p>,</span> <span class=kr>async</span> <span class=p>(</span><span class=nx>data</span><span class=p>,</span> <span class=nx>callback</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=p>{</span> <span class=nx>method</span><span class=p>,</span> <span class=nx>params</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>targetSocket</span> <span class=o>=</span> <span class=nx>rpcListeners</span><span class=p>.</span><span class=kr>get</span><span class=p>(</span><span class=nx>method</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>targetSocket</span> <span class=o>||</span> <span class=o>!</span><span class=nx>targetSocket</span><span class=p>.</span><span class=nx>connected</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>callback</span><span class=p>({</span> <span class=nx>ok</span>: <span class=kt>false</span><span class=p>,</span> <span class=nx>error</span><span class=o>:</span> <span class=s1>&#39;RPC method not available&#39;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>targetSocket</span> <span class=o>===</span> <span class=nx>socket</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>callback</span><span class=p>({</span> <span class=nx>ok</span>: <span class=kt>false</span><span class=p>,</span> <span class=nx>error</span><span class=o>:</span> <span class=s1>&#39;Cannot call RPC on the same socket&#39;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>response</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>targetSocket</span><span class=p>.</span><span class=nx>timeout</span><span class=p>(</span><span class=mi>30000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=nx>emitWithAck</span><span class=p>(</span><span class=s1>&#39;rpc-request&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>method</span><span class=p>,</span> <span class=nx>params</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=nx>callback</span><span class=p>({</span> <span class=nx>ok</span>: <span class=kt>true</span><span class=p>,</span> <span class=nx>result</span>: <span class=kt>response</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>执行</strong>。CLI 侧解密参数、调用 handler、加密响应返回：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4>4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5>5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6>6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7>7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8>8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-cli/src/api/rpc/RpcHandlerManager.ts:55-79（简化）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>async</span> <span class=nx>handleRequest</span><span class=p>(</span><span class=nx>request</span>: <span class=kt>RpcRequest</span><span class=p>)</span><span class=o>:</span> <span class=nx>Promise</span><span class=p>&lt;</span><span class=nt>any</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>handler</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>handlers</span><span class=p>.</span><span class=kr>get</span><span class=p>(</span><span class=nx>request</span><span class=p>.</span><span class=nx>method</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>decryptedParams</span> <span class=o>=</span> <span class=nx>decrypt</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>encryptionKey</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>encryptionVariant</span><span class=p>,</span> <span class=nx>decodeBase64</span><span class=p>(</span><span class=nx>request</span><span class=p>.</span><span class=nx>params</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>handler</span><span class=p>(</span><span class=nx>decryptedParams</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>encodeBase64</span><span class=p>(</span><span class=nx>encrypt</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>encryptionKey</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>encryptionVariant</span><span class=p>,</span> <span class=nx>result</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>params</code> 和返回值都是加密的 base64 字符串，即使 Server 被攻破，攻击者拿到的也只是密文。</p><p><strong>E2EE 的保护边界</strong>：</p><table><thead><tr><th></th><th>被保护</th><th>未被保护</th></tr></thead><tbody><tr><td>内容</td><td>对话文本、代码、工具调用参数、Agent 输出</td><td>—</td></tr><tr><td>元数据</td><td>—</td><td>谁连了谁、<code>session</code> ID、消息时间戳和大小</td></tr><tr><td>前提</td><td>密钥由客户端生成，不经过 Server</td><td>设备被入侵后密钥泄露；登录凭证被盗后的会话劫持</td></tr></tbody></table><p>E2EE 保护的是「Server 被攻破时的内容机密性」，不保护客户端本身被攻破的场景，也不隐藏流量模式。</p><h3 id=43-乐观并发控制>4.3 乐观并发控制<a hidden class=anchor aria-hidden=true href=#43-乐观并发控制>#</a></h3><p>多个客户端同时修改会话状态时，Happy 用乐观并发防止互相覆盖：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-cli/src/api/apiSession.ts:553-575（简化）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>answer</span> <span class=o>=</span> <span class=k>await</span> <span class=k>this</span><span class=p>.</span><span class=nx>socket</span><span class=p>.</span><span class=nx>emitWithAck</span><span class=p>(</span><span class=s1>&#39;update-state&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sid</span>: <span class=kt>this.sessionId</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>expectedVersion</span>: <span class=kt>this.agentStateVersion</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>agentState</span>: <span class=kt>encodeBase64</span><span class=p>(</span><span class=nx>encrypt</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>encryptionKey</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>encryptionVariant</span><span class=p>,</span> <span class=nx>updated</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nx>answer</span><span class=p>.</span><span class=nx>result</span> <span class=o>===</span> <span class=s1>&#39;version-mismatch&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>agentStateVersion</span> <span class=o>=</span> <span class=nx>answer</span><span class=p>.</span><span class=nx>version</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;version mismatch&#39;</span><span class=p>);</span> <span class=c1>// 触发 backoff 重试
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>客户端更新时带上 <code>expectedVersion</code>，Server 检查版本一致性，不一致就拒绝，客户端拿到最新版本后重试。</p><p>Happy 追求<strong>观察一致</strong>（observational consistency）：所有端在任意时刻查询同一个会话，看到的 <code>agentState</code> 相同。不是最终一致（不容忍短暂不一致窗口），也不是强一致（不需要分布式事务）。OCC 的 <code>expectedVersion</code> 是实现手段，写操作带版本号，Server 做单点仲裁，冲突时拒绝而非合并。选观察一致而非最终一致，是因为 AI Coding 场景下，两个用户看到不同的 Agent 状态会直接导致操作冲突。</p><h3 id=44-控制权租约>4.4 控制权租约<a hidden class=anchor aria-hidden=true href=#44-控制权租约>#</a></h3><p>多端连上 Server 后，谁发 prompt、谁批准 <code>ApprovalRequest</code>？Happy 用控制权租约解决。</p><p><strong>状态机</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3>3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4>4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5>5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stateDiagram-v2
</span></span><span class=line><span class=cl>    [*] --&gt; idle
</span></span><span class=line><span class=cl>    idle --&gt; leased: acquire_lease（成功）
</span></span><span class=line><span class=cl>    idle --&gt; idle: acquire_lease（被拒绝，已有控制端）
</span></span><span class=line><span class=cl>    leased --&gt; leased: renew_lease（续租）
</span></span><span class=line><span class=cl>    leased --&gt; idle: release_lease / lease_expired
</span></span></code></pre></td></tr></table></div></div><p><strong>规则</strong>：</p><ul><li>同一会话同一时刻只有一个 <code>lease</code> 控制端</li><li><code>lease</code> 有超时，靠心跳续租。控制端断线后自动过期</li><li>非控制端只能观看输出，不能发 prompt 或响应 <code>ApprovalRequest</code></li><li>控制端可主动释放，让另一个客户端获取控制权</li></ul><p><strong>客户端行为</strong>：</p><table><thead><tr><th>场景</th><th>控制端</th><th>非控制端</th></tr></thead><tbody><tr><td>Agent 输出</td><td>正常显示</td><td>正常显示</td></tr><tr><td>ApprovalRequest</td><td>弹出批准 UI</td><td>显示「等待控制端批准」</td></tr><tr><td>想发 prompt</td><td>正常发送</td><td>提示「先获取控制权」</td></tr><tr><td>断线</td><td><code>lease</code> 超时后自动释放</td><td>不影响</td></tr></tbody></table><p><strong>边界情况：split-brain</strong>。网络分区时，控制端和 Server 断连，但本地仍认为自己持有 <code>lease</code>。Server 侧 <code>lease</code> 超时后释放，另一个客户端可以获取。原控制端重连后发现 <code>lease</code> 已失效，需重新获取。关键原则：<strong>Server 是唯一仲裁者</strong>，客户端本地的 <code>lease</code> 状态只是缓存，Server 的判定才算数。</p><h3 id=45-server-还缺什么>4.5 Server 还缺什么<a hidden class=anchor aria-hidden=true href=#45-server-还缺什么>#</a></h3><p>Server 解决了 C1（跨网）、C2（单一数据源 + 版本化）、C3（控制权租约）、C5（E2EE + 盲转发）。</p><p>但 C4 仍然失败。问题在开发机那端：谁管 Agent 进程？用户关掉终端窗口，CLI 退出，会话断了。Server 协调了多端通信，但管不了远端机器上的进程生命周期。需要一个在开发机上<strong>常驻</strong>的进程。</p><hr><h2 id=5-第四层daemon--cli-分离>5. 第四层：Daemon + CLI 分离<a hidden class=anchor aria-hidden=true href=#5-第四层daemon--cli-分离>#</a></h2><h3 id=51-daemon-的三个职责>5.1 Daemon 的三个职责<a hidden class=anchor aria-hidden=true href=#51-daemon-的三个职责>#</a></h3><p>Daemon 是 Happy 在开发机上的常驻后台进程，不做 AI 推理，只做三件事：</p><ol><li><strong>管理会话子进程</strong>。维护 <code>pidToTrackedSession</code> Map，跟踪每个会话的 PID、<code>sessionId</code>、启动方式。</li><li><strong>接收远程 spawn</strong>。手机点「新建会话」，Server 转发，Daemon 启动 CLI 子进程。</li><li><strong>维护机器身份</strong>。通过 machine-scoped Socket 保持心跳，上报在线状态。</li></ol><p>Daemon 启动时的初始化逻辑体现了这三个职责：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4>4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5>5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6>6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-cli/src/daemon/run.ts:145-168
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>daemonLockHandle</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>acquireDaemonLock</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mi>200</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>daemonLockHandle</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>process</span><span class=p>.</span><span class=nx>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// 已有 Daemon 在运行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=p>{</span> <span class=nx>credentials</span><span class=p>,</span> <span class=nx>machineId</span> <span class=p>}</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>authAndSetupMachineIfNeeded</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>pidToTrackedSession</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>&lt;</span><span class=nt>number</span><span class=p>,</span> <span class=na>TrackedSession</span><span class=p>&gt;();</span>
</span></span></code></pre></td></tr></table></div></div><p>先获取排他锁（唯一性），再建立机器身份（职责 3），最后初始化会话跟踪表（职责 1）。</p><h3 id=52-排他锁>5.2 排他锁<a hidden class=anchor aria-hidden=true href=#52-排他锁>#</a></h3><p>一台机器只能有一个 Daemon。Happy 用文件系统原子操作实现排他锁：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span><span class=lnt id=hl-16-12><a class=lnlinks href=#hl-16-12>12</a>
</span><span class=lnt id=hl-16-13><a class=lnlinks href=#hl-16-13>13</a>
</span><span class=lnt id=hl-16-14><a class=lnlinks href=#hl-16-14>14</a>
</span><span class=lnt id=hl-16-15><a class=lnlinks href=#hl-16-15>15</a>
</span><span class=lnt id=hl-16-16><a class=lnlinks href=#hl-16-16>16</a>
</span><span class=lnt id=hl-16-17><a class=lnlinks href=#hl-16-17>17</a>
</span><span class=lnt id=hl-16-18><a class=lnlinks href=#hl-16-18>18</a>
</span><span class=lnt id=hl-16-19><a class=lnlinks href=#hl-16-19>19</a>
</span><span class=lnt id=hl-16-20><a class=lnlinks href=#hl-16-20>20</a>
</span><span class=lnt id=hl-16-21><a class=lnlinks href=#hl-16-21>21</a>
</span><span class=lnt id=hl-16-22><a class=lnlinks href=#hl-16-22>22</a>
</span><span class=lnt id=hl-16-23><a class=lnlinks href=#hl-16-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-cli/src/persistence.ts:556-597（简化）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>async</span> <span class=kd>function</span> <span class=nx>acquireDaemonLock</span><span class=p>(</span><span class=nx>maxAttempts</span><span class=p>,</span> <span class=nx>delayIncrementMs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>attempt</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>attempt</span> <span class=o>&lt;=</span> <span class=nx>maxAttempts</span><span class=p>;</span> <span class=nx>attempt</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kr>const</span> <span class=nx>fileHandle</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>open</span><span class=p>(</span><span class=nx>configuration</span><span class=p>.</span><span class=nx>daemonLockFile</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>constants</span><span class=p>.</span><span class=nx>O_CREAT</span> <span class=o>|</span> <span class=nx>constants</span><span class=p>.</span><span class=nx>O_EXCL</span> <span class=o>|</span> <span class=nx>constants</span><span class=p>.</span><span class=nx>O_WRONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>await</span> <span class=nx>fileHandle</span><span class=p>.</span><span class=nx>writeFile</span><span class=p>(</span><span class=nb>String</span><span class=p>(</span><span class=nx>process</span><span class=p>.</span><span class=nx>pid</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>fileHandle</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nx>error</span><span class=p>.</span><span class=nx>code</span> <span class=o>===</span> <span class=s1>&#39;EEXIST&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kr>const</span> <span class=nx>lockPid</span> <span class=o>=</span> <span class=nx>readFileSync</span><span class=p>(</span><span class=nx>configuration</span><span class=p>.</span><span class=nx>daemonLockFile</span><span class=p>,</span> <span class=s1>&#39;utf-8&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>process</span><span class=p>.</span><span class=nx>kill</span><span class=p>(</span><span class=nb>Number</span><span class=p>(</span><span class=nx>lockPid</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// 信号 0：只检查进程是否存在
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>}</span> <span class=k>catch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>unlinkSync</span><span class=p>(</span><span class=nx>configuration</span><span class=p>.</span><span class=nx>daemonLockFile</span><span class=p>);</span> <span class=c1>// 进程已死，清理
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>await</span> <span class=k>new</span> <span class=nx>Promise</span><span class=p>(</span><span class=nx>r</span> <span class=o>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(</span><span class=nx>r</span><span class=p>,</span> <span class=nx>attempt</span> <span class=o>*</span> <span class=nx>delayIncrementMs</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>O_CREAT | O_EXCL</code> 在文件系统层面原子，不存在 TOCTOU 竞态。锁文件写 PID，用 <code>kill(pid, 0)</code> 检测死进程，信号 0 不杀进程，只验证是否存在。</p><h3 id=53-control-server本地-ipc>5.3 Control Server：本地 IPC<a hidden class=anchor aria-hidden=true href=#53-control-server本地-ipc>#</a></h3><p>Daemon 在 <code>127.0.0.1</code> 上起一个 HTTP 服务，端口号写入 <code>daemon.state.json</code>。CLI 读取这个文件找到 Daemon：</p><table><thead><tr><th>端点</th><th>用途</th></tr></thead><tbody><tr><td><code>POST /session-started</code></td><td>CLI 会话启动后上报 <code>sessionId</code></td></tr><tr><td><code>POST /list</code></td><td>列出所有活跃会话</td></tr><tr><td><code>POST /spawn-session</code></td><td>创建新会话（手机远程触发）</td></tr><tr><td><code>POST /stop</code></td><td>优雅关闭 Daemon</td></tr></tbody></table><p>CLI 和 Daemon 通过 HTTP 解耦，不共享内存，不做进程间直接调用。</p><h3 id=54-为什么-cli-和-daemon-不能合并>5.4 为什么 CLI 和 Daemon 不能合并<a hidden class=anchor aria-hidden=true href=#54-为什么-cli-和-daemon-不能合并>#</a></h3><p>这是最容易引发困惑的拆分。根源在于进程模型不兼容：</p><table><thead><tr><th>特征</th><th>CLI</th><th>Daemon</th></tr></thead><tbody><tr><td>生命周期</td><td>敲一次命令，跑完退出</td><td>开机启动，永久常驻</td></tr><tr><td>stdio</td><td>需要 TTY（键盘输入 + 终端渲染）</td><td>无 TTY（detached, stdio: ignore）</td></tr><tr><td>并发</td><td>一次一个会话</td><td>同时管理多个会话</td></tr><tr><td>启动方式</td><td>用户手动执行</td><td>自动启动（launchd / systemd）</td></tr><tr><td>Socket scope</td><td>session-scoped</td><td>machine-scoped</td></tr></tbody></table><p>让 CLI 常驻意味着放弃 TTY，但本地交互需要 TTY 读键盘、渲染 UI。让 CLI 后台 fork 自己，stdin/stdout 断裂，本地交互无法继续。</p><p>Happy 让 CLI 首次运行时自动 spawn Daemon：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2>2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3>3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4>4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5>5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6>6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7>7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8>8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-cli/src/index.ts:327-334
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=k>await</span> <span class=nx>isDaemonRunningCurrentlyInstalledHappyVersion</span><span class=p>()))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>daemonProcess</span> <span class=o>=</span> <span class=nx>spawnHappyCLI</span><span class=p>([</span><span class=s1>&#39;daemon&#39;</span><span class=p>,</span> <span class=s1>&#39;start-sync&#39;</span><span class=p>],</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>detached</span>: <span class=kt>true</span><span class=p>,</span>    <span class=c1>// 独立于 CLI
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>stdio</span><span class=o>:</span> <span class=s1>&#39;ignore&#39;</span><span class=p>,</span>   <span class=c1>// 不继承 TTY
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>env</span>: <span class=kt>process.env</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=nx>daemonProcess</span><span class=p>.</span><span class=nx>unref</span><span class=p>();</span> <span class=c1>// CLI 退出后 Daemon 继续活着
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>detached: true</code> + <code>stdio: 'ignore'</code> + <code>unref()</code>：三行配置把 Daemon 变成独立后台进程。CLI 保持「敲一次命令跑完就退」的 Unix 哲学。</p><h3 id=55-全部满足>5.5 全部满足<a hidden class=anchor aria-hidden=true href=#55-全部满足>#</a></h3><table><thead><tr><th>约束</th><th style=text-align:center>直连</th><th style=text-align:center>+Gateway</th><th style=text-align:center>+Server</th><th style=text-align:center>+Daemon</th></tr></thead><tbody><tr><td>C1 跨网</td><td style=text-align:center>❌</td><td style=text-align:center>✅</td><td style=text-align:center>✅</td><td style=text-align:center>✅</td></tr><tr><td>C2 多端一致</td><td style=text-align:center>⚠️</td><td style=text-align:center>❌</td><td style=text-align:center>✅</td><td style=text-align:center>✅</td></tr><tr><td>C3 控制权</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td><td style=text-align:center>✅</td><td style=text-align:center>✅</td></tr><tr><td>C4 会话独立</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td><td style=text-align:center>✅</td></tr><tr><td>C5 安全</td><td style=text-align:center>⚠️</td><td style=text-align:center>⚠️</td><td style=text-align:center>✅</td><td style=text-align:center>✅</td></tr></tbody></table><p>四组件的完整拓扑：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14>14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15>15</a>
</span><span class=lnt id=hl-18-16><a class=lnlinks href=#hl-18-16>16</a>
</span><span class=lnt id=hl-18-17><a class=lnlinks href=#hl-18-17>17</a>
</span><span class=lnt id=hl-18-18><a class=lnlinks href=#hl-18-18>18</a>
</span><span class=lnt id=hl-18-19><a class=lnlinks href=#hl-18-19>19</a>
</span><span class=lnt id=hl-18-20><a class=lnlinks href=#hl-18-20>20</a>
</span><span class=lnt id=hl-18-21><a class=lnlinks href=#hl-18-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>graph TB
</span></span><span class=line><span class=cl>    subgraph 手机
</span></span><span class=line><span class=cl>        App[App]
</span></span><span class=line><span class=cl>    end
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    subgraph 公网
</span></span><span class=line><span class=cl>        Server[Server]
</span></span><span class=line><span class=cl>    end
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    subgraph 开发机
</span></span><span class=line><span class=cl>        Daemon[Daemon]
</span></span><span class=line><span class=cl>        CLI1[CLI 会话 1]
</span></span><span class=line><span class=cl>        CLI2[CLI 会话 2]
</span></span><span class=line><span class=cl>    end
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    App &lt;--&gt;|&#34;user-scoped Socket&lt;br/&gt;全局状态 + RPC 调用&#34;| Server
</span></span><span class=line><span class=cl>    CLI1 &lt;--&gt;|&#34;session-scoped Socket&lt;br/&gt;会话消息 + 状态变更&#34;| Server
</span></span><span class=line><span class=cl>    CLI2 &lt;--&gt;|&#34;session-scoped Socket&#34;| Server
</span></span><span class=line><span class=cl>    Daemon &lt;--&gt;|&#34;machine-scoped Socket&lt;br/&gt;心跳 + 远程 spawn&#34;| Server
</span></span><span class=line><span class=cl>    Daemon ---|&#34;HTTP 127.0.0.1&lt;br/&gt;daemon.state.json&#34;| CLI1
</span></span><span class=line><span class=cl>    Daemon ---|&#34;HTTP 127.0.0.1&#34;| CLI2
</span></span></code></pre></td></tr></table></div></div><p>三种 Socket scope 各走各的通道：App 通过 user-scoped 看全局、发 RPC，CLI 通过 session-scoped 收发会话消息，Daemon 通过 machine-scoped 维持心跳和接收远程 spawn。CLI 和 Daemon 之间通过本地 HTTP 解耦。</p><hr><h2 id=6-架构师视角从零设计会怎样>6. 架构师视角：从零设计会怎样<a hidden class=anchor aria-hidden=true href=#6-架构师视角从零设计会怎样>#</a></h2><h3 id=61-三组件方案>6.1 三组件方案<a hidden class=anchor aria-hidden=true href=#61-三组件方案>#</a></h3><p>只针对 Kimi CLI（单一 Provider）时，四组件可以缩减为三个：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1>1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2>2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3>3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4>4</a>
</span><span class=lnt id=hl-19-5><a class=lnlinks href=#hl-19-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Client（iOS / Web）
</span></span><span class=line><span class=cl>    ↕ WSS + E2EE
</span></span><span class=line><span class=cl>Relay Server（路由 + 认证 + 存储）
</span></span><span class=line><span class=cl>    ↕ WSS + E2EE
</span></span><span class=line><span class=cl>Agent（开发机常驻 = Daemon + Provider Wrapper）
</span></span></code></pre></td></tr></table></div></div><p>把 CLI 和 Daemon 合并成一个二进制：</p><ul><li><code>kimi-remote agent start</code> → 常驻进程（Daemon 角色）</li><li><code>kimi-remote agent attach</code> → 终端 attach 到某个会话（CLI 角色）</li></ul><p>Happy 拆出独立 CLI 是因为要统一封装 Claude Code、Codex、Gemini 三种 Provider，每种输出格式不同，需要映射层转成统一的 9 种事件。Kimi CLI 只有一个 Provider，这层封装可以内嵌。</p><p>但三组件方案还有一个更根本的问题：<strong>实际使用中，开发者在一台机器上同时开很多个 CLI，一个 task 一个 CLI</strong>。重构一个模块、跑测试、写文档，三件事并行，三个终端窗口各跑一个会话。合并后的 Agent 二进制要么只能同时处理一个任务（不可接受），要么需要在内部管理 N 个并发会话子进程——本质上重新实现了 Daemon 的进程管理职责。<code>kimi-remote agent attach</code> 也需要找到正确的会话再接入，这和 CLI 通过 <code>daemon.state.json</code> 找 Daemon 是同一套机制。</p><p>换句话说，即使解决了 Provider 统一封装的问题，多实例并发的使用习惯仍然会把「合并后的 Agent」逼回 Daemon + CLI 的分离结构。Happy 的四组件不只是因为多 Provider 才拆分，而是因为 CLI 的生命周期（一个任务一个进程，用完即走）和 Daemon 的生命周期（常驻，管理所有活跃会话）在本质上不同。</p><h3 id=62-不可省略的部分>6.2 不可省略的部分<a hidden class=anchor aria-hidden=true href=#62-不可省略的部分>#</a></h3><p>无论怎么简化：</p><ul><li><strong>Server 不可省</strong>。它解决物理约束：NAT 穿透和多端一致性。只要手机和开发机不在同一网络，就需要双方都能访问的中继。</li><li><strong>Daemon 不可省</strong>。它解决进程约束：会话生命周期独立于前端。只要「关掉终端后 Agent 继续跑」是需求，就需要常驻进程。</li></ul><p>组件数量是约束数量的函数。放宽约束可以减少组件：</p><table><thead><tr><th>放宽的约束</th><th>可省略</th><th>代价</th></tr></thead><tbody><tr><td>不需要跨网</td><td>Server</td><td>失去公网可达</td></tr><tr><td>不需要本地终端交互</td><td>CLI（合并到 Agent）</td><td>回到电脑时无法在终端继续</td></tr><tr><td>只有一个 Provider</td><td>Provider 封装层</td><td>不影响功能</td></tr><tr><td>Server 自己部署</td><td>E2EE</td><td>安全性自己负责</td></tr></tbody></table><h3 id=63-约束推导方法五维度扫描>6.3 约束推导方法：五维度扫描<a hidden class=anchor aria-hidden=true href=#63-约束推导方法五维度扫描>#</a></h3><p>上面的约束列表怎么推导出来的？靠一个固定的扫描清单。</p><p>面对任何远程操控场景，画出最简架构（两个节点一条线），按五个维度依次提问：</p><table><thead><tr><th>维度</th><th>问的问题</th><th>答案为「是」时产生的约束</th></tr></thead><tbody><tr><td>网络</td><td>A 能直接找到 B 吗？</td><td>跨网可达</td></tr><tr><td>一致性</td><td>多个观察者看到的状态一样吗？</td><td>多端状态一致</td></tr><tr><td>并发</td><td>多个操作者同时动手会冲突吗？</td><td>控制权互斥</td></tr><tr><td>生命周期</td><td>UI 挂了，后台任务也死吗？</td><td>会话独立于前端</td></tr><tr><td>交互模式</td><td>所有用户用同一种界面吗？</td><td>CLI / Daemon 分离</td></tr></tbody></table><p>五个维度从物理层到应用层排列，先解决低层问题再考虑高层。每个维度用同一个问题检验：<strong>不处理的话，能构造出什么灾难场景？</strong> 能构造出来 → 硬约束。构造不出来 → 软偏好，可以延后。</p><p>以「控制权互斥」为例：多端连上后，能不能不做互斥，让用户先后操控？可以，<code>lease</code> 机制本质上就在实现「先后操控」。但<strong>谁来保证先后</strong>？没有 Server 维护 <code>lease</code>，两个客户端都认为自己是控制端，同时发 prompt，Agent 收到矛盾指令。约束不是「要不要互斥」，而是「谁来仲裁」。</p><p>这个方法的原型是航空业的起飞前检查清单。1935 年，波音 Model 299（B-17 原型）试飞坠毁，原因是试飞员忘记释放升降舵锁，飞机太复杂，超出了一个人的记忆力极限。波音发明了检查清单。五维度扫描解决同一个问题：不是给新手用的拐杖，是给专家用的认知外骨骼。</p><p>日常版本：旅行前拍脑袋收拾行李，带三件外套却忘充电器。架构设计中「WebSocket 能不能连上」是外套，「关掉终端后会话还在不在」是充电器。</p><h3 id=延伸练习>延伸练习<a hidden class=anchor aria-hidden=true href=#延伸练习>#</a></h3><p>把这个方法用在一个新场景上：<strong>设计一个「手机远程操控家里电脑 Docker 容器」的系统</strong>，手机上启动/停止容器、查看日志、执行命令。</p><ol><li>画出最简架构</li><li>按五个维度扫描，每个维度构造一个灾难场景</li><li>对每个灾难场景决定加什么组件</li><li>和 Happy 的四组件对比：哪些一样？哪些不需要？为什么？</li></ol><p>写不出灾难场景的维度，恰好说明那个约束在这个场景下不存在，这本身就是有价值的结论。</p><hr><h2 id=7-wire-协议能复用吗分层拆解>7. Wire 协议能复用吗：分层拆解<a hidden class=anchor aria-hidden=true href=#7-wire-协议能复用吗分层拆解>#</a></h2><p>Kimi CLI 的 Web UI 已有 Wire 协议（JSON-RPC 2.0）和 <code>BroadcastQueue</code>，远程方案能直接复用还是推翻重来？</p><p>答案是<strong>按层看</strong>。</p><h3 id=71-三层拆解>7.1 三层拆解<a hidden class=anchor aria-hidden=true href=#71-三层拆解>#</a></h3><p>把 Wire 协议拆成三层，逐层评估：</p><table><thead><tr><th>层</th><th>包含什么</th><th>能复用吗</th><th>理由</th></tr></thead><tbody><tr><td>应用语义层</td><td>17 种事件类型 + 2 种请求类型 + WireMessageEnvelope 格式</td><td>✅ 100% 复用</td><td>消息的含义不因传输方式改变</td></tr><tr><td>会话管理层</td><td>客户端身份、消息排序、请求匹配、控制权、心跳</td><td>❌ 需要新增</td><td>本地方案没有这一层</td></tr><tr><td>传输层</td><td>stdio 管道、localhost WebSocket</td><td>⚠️ 替换</td><td>从本地换成公网 WSS + 中继</td></tr></tbody></table><p>关键发现：Wire 协议目前<strong>只有两层</strong>（应用语义 + 传输），会话管理层是空的。这不是设计缺陷，本地场景不需要，但远程场景必须补上。</p><h3 id=72-应用语义层直接搬>7.2 应用语义层：直接搬<a hidden class=anchor aria-hidden=true href=#72-应用语义层直接搬>#</a></h3><p>Wire 定义的事件类型是纯业务语义，不绑定传输假设：<code>TurnBegin</code>/<code>TurnEnd</code> 标记对话边界，<code>ContentPart</code> 承载流式输出，<code>ToolCall</code>/<code>ToolResult</code> 处理工具调用，<code>ApprovalRequest</code> 请求用户批准。无论走 stdio、localhost WebSocket 还是公网 WSS 中继，这些消息格式都不需要改。</p><p><code>BroadcastQueue</code> 的 SPMC 模式也可复用。Server 收到 Agent 消息后，用同样的「一个生产者、多个消费者」模式广播给同一会话的所有订阅者。</p><h3 id=73-会话管理层必须新增>7.3 会话管理层：必须新增<a hidden class=anchor aria-hidden=true href=#73-会话管理层必须新增>#</a></h3><p>这是最大的工作量。本地方案有三个隐含假设，远程场景下全部失效：</p><p><strong>假设 1：只有一个客户端</strong>。<code>_pending_requests</code> 是全局字典，没有客户端隔离：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1>1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># wire/server.py — 当前</span>
</span></span><span class=line><span class=cl><span class=bp>self</span><span class=o>.</span><span class=n>_pending_requests</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Request</span><span class=p>]</span> <span class=o>=</span> <span class=p>{}</span>
</span></span></code></pre></td></tr></table></div></div><p>远程场景需要按会话隔离，同一个 <code>ApprovalRequest</code> 只能由当前控制端响应。</p><p><strong>假设 2：消息天然有序</strong>。stdio 是单流，到达顺序就是发送顺序。公网 WebSocket 经中继后可能乱序。需要在每条消息上加 <code>seq</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1>1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 远程方案需要</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=s2>&#34;seq&#34;</span><span class=p>:</span> <span class=mi>42</span><span class=p>,</span> <span class=s2>&#34;session_id&#34;</span><span class=p>:</span> <span class=s2>&#34;abc&#34;</span><span class=p>,</span> <span class=s2>&#34;message&#34;</span><span class=p>:</span> <span class=p>{</span><span class=o>...</span><span class=p>}}</span>
</span></span></code></pre></td></tr></table></div></div><p>Happy 的 <code>CoreUpdateContainer</code> 正是这样做的，每条 update 带 <code>id</code>（去重）和 <code>seq</code>（排序）。</p><p><strong>假设 3：连接不会断</strong>。stdio 管道在进程活着时永远不断。公网连接随时可能断（WebSocket 断开、App 后台挂起、Server 重启），需要心跳检测和断线重连后的状态同步。</p><p><strong>最小可用的重连策略</strong>：客户端维护 <code>lastSeenSeq</code>，重连后发送 <code>{"resume": true, "lastSeenSeq": 41}</code>，Server 从事件日志中找到 <code>seq</code> > 41 的消息重放。事件日志已滚动时，回退到全量快照 + 从快照版本订阅增量。去重靠 <code>seq</code> 单调递增，客户端忽略 <code>seq</code> ≤ <code>lastSeenSeq</code> 的消息。Wire 的 JSONL 文件格式可以作为回放源，Kimi CLI 的 <code>_replay_buffers</code> 机制可以复用。</p><p>「会话管理层」工作量最大的原因在此：不只是加几个字段，而是一套完整的断线恢复协议。</p><h3 id=74-传输层整体替换>7.4 传输层：整体替换<a hidden class=anchor aria-hidden=true href=#74-传输层整体替换>#</a></h3><p>从 stdio 管道换成 WSS + 中继 Server，这是基础设施变更。<code>asyncio.Future</code>（本地等待请求响应）不能跨网络传递，需要替换为带超时的回调机制。Happy 的 <code>emitWithAck</code> + 30 秒超时就是一种实现。</p><h3 id=75-结论六成复用四成新增>7.5 结论：六成复用，四成新增<a hidden class=anchor aria-hidden=true href=#75-结论六成复用四成新增>#</a></h3><table><thead><tr><th>工作项</th><th>工作量</th><th>复用率</th></tr></thead><tbody><tr><td>消息类型定义（17 + 2）</td><td>零</td><td>100%</td></tr><tr><td>序列化格式（JSON-RPC 2.0）</td><td>零</td><td>100%</td></tr><tr><td><code>BroadcastQueue</code> / 回放机制</td><td>小</td><td>80%</td></tr><tr><td>会话管理（身份 / 排序 / 心跳）</td><td>大</td><td>0%（新增）</td></tr><tr><td>控制权租约</td><td>中</td><td>0%（新增）</td></tr><tr><td>传输层替换（stdio → WSS）</td><td>中</td><td>0%（替换）</td></tr></tbody></table><p>不需要推翻重来，也不能原样照搬。应用语义层完整复用，会话管理层从零新增，传输层整体替换。</p><h3 id=76-分层复用的-mindset>7.6 分层复用的 mindset<a hidden class=anchor aria-hidden=true href=#76-分层复用的-mindset>#</a></h3><p>上面的分析用的思维方式是<strong>按层拆解，逐层判断</strong>。面对「现有系统迁移到新环境」，不陷入「推翻重来」和「原样复用」的二元争论，而是拆成层，每层独立评估。</p><p>这个方法有一个跨越 150 年的同构案例：明治维新。不是全盘西化，也不是完全拒绝。伊藤博文按层拆解：军事技术层→全面引进西方模式（传输层替换）。行政制度层→选择性改造，学普鲁士而非英法，因为普鲁士的君主立宪更兼容天皇制（会话管理层重新设计）。文化认同层→保留天皇制和神道教（应用语义层复用）。</p><p>日常版本：换城市工作。衣服直接搬，不绑定城市。健身房重新办卡，会员绑定旧的地理位置。朋友关系继续维护，但方式从线下聚餐变为线上联系，复用关系本身，替换承载渠道。</p><hr><h2 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h2><p>回到开篇：手机远程操控 AI Coding CLI，为什么不是「一个 WebSocket」就能搞定？</p><p>五个约束逐层叠加，每个淘汰一种更简单的方案：</p><ol><li><strong>NAT 穿透</strong>淘汰了直连。手机找不到 NAT 后面的开发机，必须有公网中继（Server）</li><li><strong>多端一致性</strong>淘汰了无状态 Gateway。Gateway 只转发不协调，两端状态可能不一致</li><li><strong>控制权互斥</strong>要求 Server 理解协议语义。Gateway 不知道谁是控制端</li><li><strong>会话独立于前端</strong>要求常驻进程。关掉终端不能杀死 Agent（Daemon）</li><li><strong>本地 + 远程并存</strong>让 CLI 和 Daemon 无法合并。TTY 需求和 detached 后台进程模型冲突，且实际使用中一台机器同时跑多个 CLI（一个任务一个进程），Daemon 必须作为独立进程管理这些并发会话</li></ol><p>Happy 的四组件恰好对应这五个约束。场景更简单时可以缩减到三组件，但 Server 和 Daemon 不可省，它们解决的是物理约束，不是设计偏好。</p><p><strong>判断自己需要几个组件</strong>（Mermaid 图略，同前文）</p><p>协议层面，Wire 协议不需要推翻：应用语义层 100% 复用，会话管理层从零新增，传输层整体替换。</p><p>文章用了三个可迁移的思维方法：</p><table><thead><tr><th>方法</th><th>核心动作</th><th>远镜类比</th><th>近镜类比</th></tr></thead><tbody><tr><td>逐步证伪法</td><td>从最简方案出发，用失败场景逼出组件</td><td>英国普通法：每条判例对应一次真实失败</td><td>搬新家：每件物品对应一个具体不便</td></tr><tr><td>五维度扫描法</td><td>按固定清单逐层检查「不处理会怎样」</td><td>B-17 坠毁催生飞行检查清单</td><td>旅行打包：显眼物品挤占注意力</td></tr><tr><td>分层复用分析法</td><td>按层拆解，逐层判断复用/扩展/新增</td><td>明治维新按层判断西化程度</td><td>换城市：衣服搬走、健身房重办、朋友维护</td></tr></tbody></table><p>三个方法对应架构设计的三个阶段：发现约束、梳理约束、迁移方案。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://miss-you.github.io/tags/ai/>AI</a></li><li><a href=https://miss-you.github.io/tags/websocket/>WebSocket</a></li><li><a href=https://miss-you.github.io/tags/%E6%9E%B6%E6%9E%84/>架构</a></li><li><a href=https://miss-you.github.io/tags/cli/>CLI</a></li><li><a href=https://miss-you.github.io/tags/kimi/>Kimi</a></li><li><a href=https://miss-you.github.io/tags/happy/>Happy</a></li><li><a href=https://miss-you.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/>架构设计</a></li></ul><nav class=paginav><a class=prev href=https://miss-you.github.io/posts/20260218-ai-collaboration-acceptance-blindspots/><span class=title>« 上一页</span><br><span>不要让 AI 批改自己的试卷 —— 一次 16 处遗漏的协作复盘</span>
</a><a class=next href=https://miss-you.github.io/posts/20260216-swift-kimi-cli-console/><span class=title>下一页 »</span><br><span>用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 on x" href="https://x.com/intent/tweet/?text=%e4%bb%8e%e4%b8%80%e4%b8%aa%20WebSocket%20%e5%88%b0%e5%9b%9b%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9a%e5%a4%9a%e7%ab%af%e6%93%8d%e6%8e%a7%20AI%20Coding%20CLI%20%e7%9a%84%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8c%96&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f&amp;hashtags=AI%2cWebSocket%2c%e6%9e%b6%e6%9e%84%2cCLI%2cKimi%2cHappy%2c%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f&amp;title=%e4%bb%8e%e4%b8%80%e4%b8%aa%20WebSocket%20%e5%88%b0%e5%9b%9b%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9a%e5%a4%9a%e7%ab%af%e6%93%8d%e6%8e%a7%20AI%20Coding%20CLI%20%e7%9a%84%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8c%96&amp;summary=%e4%bb%8e%e4%b8%80%e4%b8%aa%20WebSocket%20%e5%88%b0%e5%9b%9b%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9a%e5%a4%9a%e7%ab%af%e6%93%8d%e6%8e%a7%20AI%20Coding%20CLI%20%e7%9a%84%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8c%96&amp;source=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f&title=%e4%bb%8e%e4%b8%80%e4%b8%aa%20WebSocket%20%e5%88%b0%e5%9b%9b%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9a%e5%a4%9a%e7%ab%af%e6%93%8d%e6%8e%a7%20AI%20Coding%20CLI%20%e7%9a%84%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8c%96"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 on whatsapp" href="https://api.whatsapp.com/send?text=%e4%bb%8e%e4%b8%80%e4%b8%aa%20WebSocket%20%e5%88%b0%e5%9b%9b%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9a%e5%a4%9a%e7%ab%af%e6%93%8d%e6%8e%a7%20AI%20Coding%20CLI%20%e7%9a%84%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8c%96%20-%20https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 on telegram" href="https://telegram.me/share/url?text=%e4%bb%8e%e4%b8%80%e4%b8%aa%20WebSocket%20%e5%88%b0%e5%9b%9b%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9a%e5%a4%9a%e7%ab%af%e6%93%8d%e6%8e%a7%20AI%20Coding%20CLI%20%e7%9a%84%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8c%96&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e4%bb%8e%e4%b8%80%e4%b8%aa%20WebSocket%20%e5%88%b0%e5%9b%9b%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9a%e5%a4%9a%e7%ab%af%e6%93%8d%e6%8e%a7%20AI%20Coding%20CLI%20%e7%9a%84%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8c%96&u=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://miss-you.github.io/>Yousa Driven Development | YDD</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
  
  
  const isDarkMode = () => {
    return document.body.classList.contains('dark');
  };
  
  
  const mermaidKeywords = [
    'graph ', 'graph TB', 'graph TD', 'graph LR', 'graph RL', 'graph BT',
    'flowchart ', 'flowchart TB', 'flowchart TD', 'flowchart LR', 'flowchart RL', 'flowchart BT',
    'sequenceDiagram', 'classDiagram', 'stateDiagram', 'stateDiagram-v2',
    'erDiagram', 'journey', 'gantt', 'pie', 'requirementDiagram',
    'gitGraph', 'mindmap', 'timeline', 'sankey'
  ];
  
  const isMermaidCode = (code) => {
    const trimmed = code.trim();
    return mermaidKeywords.some(keyword => trimmed.startsWith(keyword));
  };
  
  
  const getColors = () => {
    if (isDarkMode()) {
      return {
        
        bg: '#1d1e20',
        surface: '#2d2e30',
        border: '#444',
        text: '#dadaeb',
        secondary: '#9c9d9e',
        line: '#9c9d9e',
        
        accent1: '#5a7a96',  
        accent2: '#6b8e6b',  
        accent3: '#b8a87c',  
      };
    }
    
    return {
      bg: '#f4f3ee',        
      surface: '#faf9f5',   
      border: '#2c2c2c',    
      text: '#1f1f1f',      
      secondary: '#6c6c6c', 
      line: '#4a4a4a',      
      
      accent1: '#8fb8d4',   
      accent2: '#a8c6a8',   
      accent3: '#d4c59a',   
    };
  };
  
  
  if (!document.getElementById('mermaid-virgil-font')) {
    const style = document.createElement('style');
    style.id = 'mermaid-virgil-font';
    style.textContent = `
      @font-face {
        font-family: "Virgil";
        src: url("https://excalidraw.nyc3.cdn.digitaloceanspaces.com/fonts/Virgil.woff2") format("woff2");
        font-display: swap;
      }
    `;
    document.head.appendChild(style);
  }

  const initMermaid = () => {
    const c = getColors();
    
    mermaid.initialize({
      startOnLoad: false,
      theme: 'base',
      themeVariables: {
        
        fontFamily: '"Virgil", "Noto Serif SC", Georgia, serif',
        fontSize: '16px',           
        
        
        background: c.bg,
        mainBkg: c.surface,
        
        
        primaryColor: c.surface,
        primaryTextColor: c.text,
        primaryBorderColor: c.border,
        
        
        secondaryColor: c.accent1,
        tertiaryColor: c.accent2,
        
        
        lineColor: c.line,
        nodeBorder: c.border,
        clusterBkg: c.bg,
        clusterBorder: c.border,
        
        
        textColor: c.text,
        titleColor: c.text,
        nodeTextColor: c.text,
        labelColor: c.text,
        
        
        edgeLabelBackground: c.bg,
        
        
        actorBorder: c.border,
        actorBkg: c.surface,
        actorTextColor: c.text,
        actorLineColor: c.border,
        signalColor: c.line,
        signalTextColor: c.text,
        
        
        stateBorder: c.border,
        stateBkg: c.surface,
        
        
        cScale0: c.surface,
        cScale1: c.accent1,
        cScale2: c.accent2,
        cScale3: c.accent3,
        cScale4: c.surface,
        cScale5: c.accent1,
      },
      
      
      flowchart: {
        useMaxWidth: true,
        htmlLabels: true,
        curve: 'basis',
        padding: 20,
        nodeSpacing: 50,
        rankSpacing: 60,
      },
      
      
      sequence: {
        useMaxWidth: true,
        diagramMarginX: 50,
        diagramMarginY: 20,
        actorMargin: 60,
        width: 160,
        height: 70,
        boxMargin: 15,
        boxTextMargin: 8,
        noteMargin: 15,
        messageMargin: 40,
        mirrorActors: true,
        bottomMarginAdj: 1,
        rightAngles: false,
        showSequenceNumbers: false,
        
        actorFontSize: '16px',
        noteFontSize: '15px',
        messageFontSize: '15px',
      },
      
      
      state: {
        useMaxWidth: true,
        padding: 15,
        fontSize: '16px',
      },
      
      
      class: {
        useMaxWidth: true,
        fontSize: '15px',
      },
      
      
      er: {
        useMaxWidth: true,
        fontSize: '15px',
      },
      
      
      gantt: {
        useMaxWidth: true,
        fontSize: '14px',
      },
      
      
      look: 'handDrawn',
    });
  };
  
  const renderMermaidDiagrams = async () => {
    const allCodeBlocks = document.querySelectorAll('pre code');
    const mermaidBlocks = [];
    
    allCodeBlocks.forEach(block => {
      const code = block.textContent;
      if (isMermaidCode(code)) {
        mermaidBlocks.push(block);
      }
    });
    
    if (mermaidBlocks.length === 0) return;
    
    initMermaid();
    const c = getColors();
    
    for (const block of mermaidBlocks) {
      const pre = block.parentElement;
      const code = block.textContent.trim();
      
      
      const wrapper = document.createElement('div');
      wrapper.className = 'mermaid-diagram';
      wrapper.style.cssText = `
        margin: 2em 0;
        padding: 24px;
        background: ${c.bg};
        border: 1px solid ${c.border}30;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        overflow-x: auto;
      `;
      
      
      const container = document.createElement('div');
      container.style.cssText = `
        display: flex;
        justify-content: center;
        min-width: fit-content;
      `;
      
      const mermaidDiv = document.createElement('div');
      mermaidDiv.className = 'mermaid';
      mermaidDiv.textContent = code;
      container.appendChild(mermaidDiv);
      wrapper.appendChild(container);
      
      pre.parentNode.replaceChild(wrapper, pre);
      
      try {
        await mermaid.run({ querySelector: '.mermaid' });
      } catch (error) {
        console.error('Mermaid error:', error);
      }
    }
  };
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', renderMermaidDiagrams);
  } else {
    renderMermaidDiagrams();
  }
  
  
  let timeout;
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === 'class') {
        clearTimeout(timeout);
        timeout = setTimeout(() => location.reload(), 300);
      }
    });
  });
  observer.observe(document.body, { attributes: true });
</script><style>.mermaid-diagram{font-family:virgil,noto serif sc,Georgia,serif}.mermaid-diagram .mermaid{display:flex;justify-content:center}.mermaid-diagram svg{max-width:100% !important;height:auto !important;font-family:virgil,noto serif sc,Georgia,serif !important}.mermaid-diagram svg text,.mermaid-diagram svg .label,.mermaid-diagram svg .nodeLabel,.mermaid-diagram svg .edgeLabel,.mermaid-diagram svg .messageText,.mermaid-diagram svg .actor text,.mermaid-diagram svg .participant text{fill:#1f1f1f !important;font-family:virgil,noto serif sc,Georgia,serif !important;font-size:15px !important;font-weight:500 !important}.dark .mermaid-diagram svg text,.dark .mermaid-diagram svg .label,.dark .mermaid-diagram svg .nodeLabel,.dark .mermaid-diagram svg .edgeLabel,.dark .mermaid-diagram svg .messageText,.dark .mermaid-diagram svg .actor text,.dark .mermaid-diagram svg .participant text{fill:#dadaeb !important}.mermaid-diagram svg .sequenceDiagram text{font-size:16px !important}.mermaid-diagram svg .actor{font-size:16px !important}.mermaid-diagram svg .messageText{font-size:15px !important}.mermaid-diagram svg .node rect,.mermaid-diagram svg .node circle,.mermaid-diagram svg .node ellipse,.mermaid-diagram svg .node polygon{stroke-width:2px !important}.mermaid-diagram svg{filter:drop-shadow(0 1px 3px rgba(0,0,0,8%))}.dark .mermaid-diagram{background:#1d1e20 !important;border-color:#444 !important;box-shadow:0 2px 8px rgba(0,0,0,.2) !important}@media(max-width:768px){.mermaid-diagram{padding:16px !important;margin:1.5em 0 !important}.mermaid-diagram svg text{font-size:14px !important}}.mermaid-diagram{opacity:0;animation:fadeIn .4s ease-out forwards}@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}</style><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>