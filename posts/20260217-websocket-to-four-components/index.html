<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 | Yousa Driven Development | YDD</title><meta name=keywords content="AI,WebSocket,架构,CLI,Kimi,Happy,架构设计"><meta name=description content="从最简方案开始，每遇到一个绕不过去的约束，就加一个组件。四层方案逐层淘汰，最终发现四组件是五个硬约束逐层叠加的必然结果。"><meta name=author content="Miss-you"><link rel=canonical href=https://miss-you.github.io/posts/20260217-websocket-to-four-components/><link crossorigin=anonymous href=/assets/css/stylesheet.90ccfe940c2ebacfe29cf6c094281c8c148bd718511cde00be68d330109118be.css integrity="sha256-kMz+lAwuus/inPbAlCgcjBSL1xhRHN4AvmjTMBCRGL4=" rel="preload stylesheet" as=style><link rel=icon href=https://miss-you.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://miss-you.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://miss-you.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://miss-you.github.io/apple-touch-icon.png><link rel=mask-icon href=https://miss-you.github.io/safari-pinned-tab.svg><meta name=theme-color content="#f4f3ee"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://miss-you.github.io/posts/20260217-websocket-to-four-components/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Noto+Serif+SC:wght@400;600;700;900&family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel=stylesheet><meta property="og:url" content="https://miss-you.github.io/posts/20260217-websocket-to-four-components/"><meta property="og:site_name" content="Yousa Driven Development | YDD"><meta property="og:title" content="从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化"><meta property="og:description" content="从最简方案开始，每遇到一个绕不过去的约束，就加一个组件。四层方案逐层淘汰，最终发现四组件是五个硬约束逐层叠加的必然结果。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-17T09:50:00+08:00"><meta property="article:modified_time" content="2026-02-17T09:51:42+08:00"><meta property="article:tag" content="AI"><meta property="article:tag" content="WebSocket"><meta property="article:tag" content="架构"><meta property="article:tag" content="CLI"><meta property="article:tag" content="Kimi"><meta property="article:tag" content="Happy"><meta name=twitter:card content="summary"><meta name=twitter:title content="从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化"><meta name=twitter:description content="从最简方案开始，每遇到一个绕不过去的约束，就加一个组件。四层方案逐层淘汰，最终发现四组件是五个硬约束逐层叠加的必然结果。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://miss-you.github.io/posts/"},{"@type":"ListItem","position":2,"name":"从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化","item":"https://miss-you.github.io/posts/20260217-websocket-to-four-components/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化","name":"从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化","description":"从最简方案开始，每遇到一个绕不过去的约束，就加一个组件。四层方案逐层淘汰，最终发现四组件是五个硬约束逐层叠加的必然结果。","keywords":["AI","WebSocket","架构","CLI","Kimi","Happy","架构设计"],"articleBody":"从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 手机远程操控电脑上的 AI Coding CLI，直觉上只需要一个 WebSocket 连接。CLI 在电脑上跑着，手机连上去，发消息，收输出，结束。\nKimi CLI 的 Web UI 做到了这一步。执行 kimi web，本地起一个 HTTP + WebSocket 服务，浏览器打开就能用。底层的 Wire 协议（JSON-RPC 2.0）支持多个 WebSocket 客户端同时接入，消息通过 BroadcastQueue 广播给所有订阅者。手机套个 WebView 就行了？\n但 Happy 项目把同样的需求拆成了四个独立组件：CLI、Daemon、Server、App。四个进程，三种 Socket 连接类型，一套 RPC 转发机制，外加端到端加密（E2EE, End-to-End Encryption）。\n为什么？\n这篇文章用两个真实项目的源码来回答。从最简单的直连方案开始，每遇到一个绕不过去的约束，就加一个组件。四层方案逐层淘汰，最终会发现：四组件不是过度设计，而是五个硬约束逐层叠加的必然结果。\n读完后能得到四样东西：\n每个组件存在的「不可替代的理由」，以及没有它会怎样 Happy 和 Kimi CLI 在消息路由、进程管理、控制权协调上的关键设计细节 一棵决策树，根据自己的场景判断需要几个组件、哪些可以省 现有 Wire 协议哪些能复用、哪些必须新增的分层分析 1. 五个硬约束 在拆解方案之前，先定义检验标准。「手机远程操控电脑上的 AI Coding CLI」这个需求拆成五个约束：\n# 约束 含义 C1 跨网可达 手机在 4G/5G，开发机在 NAT 后面，两者能通信 C2 多端一致 手机和电脑看到的会话状态完全一致 C3 控制权互斥 同一时刻只有一个终端在控制 Agent C4 会话独立于前端 关掉手机或终端，Agent 继续跑，重新打开能接上 C5 安全 至少有认证，理想情况下端到端加密 为什么是这五个 这张表不是头脑风暴列出来的，而是逐步证伪得到的——从最简方案开始，每一步找一个打破它的具体场景，被迫加一个组件，直到没有场景能打破：\n1 2 3 4 5 6 7 8 9 10 11 起点：手机直连电脑（一个 WebSocket） │ ├─ \"手机 4G，电脑在家 WiFi\" → 连不上 → 需要公网中继 │ ├─ \"手机和电脑同时连上\" → 消息顺序不一致 → 中继要理解协议、做排序 │ ├─ \"两个客户端同时发 prompt\" → 谁算数？→ 要有人仲裁控制权 │ ├─ \"关掉终端窗口\" → Agent 跟着死了 → 需要独立的常驻进程 │ └─ \"在电脑上也想交互式操作\" → 常驻进程没有 TTY → 需要额外的交互前端 这个拆解有三个性质：\n每个约束都有反例。删掉任何一个，都能构造一个具体的故障场景——后面四节逐一展示。 约束之间有依赖序。讨论「控制权互斥」的前提是「多端已经连上」，讨论「多端连接」的前提是「网络可达」。链条是：网络可达 → 多端共存 → 多端冲突 → 进程生命周期 → 交互模式分离。每一层的问题，只有在前一层被解决后才会暴露。 每个约束恰好淘汰一种方案。没有两个约束淘汰同一种方案，没有冗余。 这套「从最简开始，被失败逼着加组件」的方法有一个跨越八百年的同构案例：英国普通法。不是某位国王召集法学家写出完美法典，而是从亨利二世时期最简单的「派巡回法官解决纠纷」开始，每次新型案件暴露旧规则的不足，法官被迫创造一条新判例。每条规则都指向一次真实的失败——和我们的每个组件指向一个具体的约束是同一套逻辑。更贴身的版本：搬进新家，第一天只有一个行李箱。没有晾衣架就买晾衣架，地板湿滑就买防滑垫。三个月后家里每件东西都对应一个真实的不便，没有一件多余。如果你的架构中某个组件说不出它对应的失败场景，它大概率是过度设计。\n后面每种方案都用这五个约束打分。\n2. 第一层：App 直连 Web UI 2.1 Kimi CLI 的现有能力 Kimi CLI 已经具备外部 UI 接入的基础设施。执行 kimi web，本地起一个 FastAPI 服务，浏览器通过 WebSocket 连接 Wire 协议与 Agent 内核交互。\n底层消息分发采用 SPMC（Single Producer, Multiple Consumer）广播队列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # kimi-cli/src/kimi_cli/utils/broadcast.py class BroadcastQueue[T]: def __init__(self) -\u003e None: self._queues: set[Queue[T]] = set() def subscribe(self) -\u003e Queue[T]: queue: Queue[T] = Queue() self._queues.add(queue) return queue def publish_nowait(self, item: T) -\u003e None: for queue in self._queues: queue.put_nowait(item) 每个 WebSocket 客户端调用 subscribe() 获得自己的队列，Agent 内核每产生一条消息就通过 publish_nowait 广播给所有订阅者。多个客户端可以同时观看同一个会话的输出。\n新客户端中途加入时，SessionProcess 用缓冲机制衔接历史回放和实时消息：\n1 2 3 4 5 6 7 8 9 10 11 12 # kimi-cli/src/kimi_cli/web/runner/process.py:526-538 async def _broadcast(self, message: str) -\u003e None: async with self._ws_lock: to_send: list[WebSocket] = [] for ws in self._websockets: buffer = self._replay_buffers.get(ws) if buffer is not None: buffer.append(message) # 正在回放历史：缓冲实时消息 else: to_send.append(ws) # 已进入实时：直接发送 for ws in to_send: await ws.send_text(message) 正在回放 wire.jsonl 历史的客户端，实时消息暂存到 _replay_buffers。回放结束后 flush 缓冲区，无缝切换到实时流，解决了「中途加入不丢消息」的问题。\n2.2 卡在哪里 用五个约束检验这个方案：\nC1 跨网失败。Web 服务默认绑定 127.0.0.1，加 --network 后绑定 0.0.0.0，但开发机仍然在 NAT 后面。手机在 4G 网络上找不到这台机器。用户需要自己搞 Tailscale 或 ngrok，不是产品化方案。\nC3 控制权失败。Wire 协议的请求响应是 1:1 的。Agent 发出 ApprovalRequest（请求用户批准某个工具调用）时，请求放进一个全局字典：\n1 2 3 # kimi-cli/src/kimi_cli/wire/server.py:75-76 self._pending_requests: dict[str, Request] = {} \"\"\"Maps JSON RPC message IDs to pending Requests.\"\"\" 这个字典没有客户端隔离。两个 WebSocket 同时连接时，都能看到同一个 ApprovalRequest，都能响应它，谁先回复谁生效。两个客户端还可以在 session 空闲时同时发 prompt，is_busy 检查在 session 空闲时不起作用。\nC4 会话独立失败。Worker 子进程的生命周期绑定在 FastAPI Web 服务器上：\n1 2 3 4 5 6 7 8 9 10 # kimi-cli/src/kimi_cli/web/app.py:168-186 @asynccontextmanager async def lifespan(app: FastAPI): runner = KimiCLIRunner() app.state.runner = runner runner.start() try: yield finally: await runner.stop() # Web 服务关闭 → 所有 Worker 子进程被杀 关掉终端窗口，Web 服务退出，runner.stop() 杀死所有 Worker 子进程，会话丢失。\n打分：\n约束 直连方案 C1 跨网 ❌ C2 多端一致 ⚠️ 广播可用，无协调 C3 控制权 ❌ C4 会话独立 ❌ C5 安全 ⚠️ Token，无 E2EE 直连方案适合「同一张桌子上多开一个屏幕看输出」。要跨网、要多端、要产品化，得继续往上叠。\n3. 第二层：Web UI + Gateway 最直觉的补救：在 Web UI 前面加一层反向代理（Caddy、nginx、Cloudflare Tunnel），解决网络可达和 TLS 终止。\n1 iPhone ──HTTPS/WSS──▶ Gateway（公网） ──HTTP/WS──▶ 开发机 kimi web C1 跨网解决了，C5 传输层加密有了。但 Gateway 只是一根管道，不理解 Wire 协议的语义：\nC2 多端一致：Gateway 透明转发，两个客户端各自和 Web UI 通信，没有人协调消息顺序 C3 控制权：Gateway 不知道谁是控制端，两个客户端仍然可以同时发 prompt C4 会话独立：Worker 仍然绑在 Web 服务进程上，Gateway 管不了进程生命周期 如果 Gateway 部署在第三方（比如 Cloudflare），它作为中间人能看到所有明文，代码、对话、工具调用参数对第三方完全透明。\n约束 直连 +Gateway C1 跨网 ❌ ✅ C2 多端一致 ⚠️ ❌ C3 控制权 ❌ ❌ C4 会话独立 ❌ ❌ C5 安全 ⚠️ ⚠️ TLS only Gateway 解决了「网络管道」，但「谁说了算」需要一个理解协议的中间层。\n4. 第三层：有状态的 Server 把 Gateway 升级为「理解业务语义的 Server」。这是 Happy 架构中最重量级的组件。\n4.1 三种 Socket Scope Happy Server 不是简单地广播消息给所有连接。每个 Socket.IO 连接在握手时声明自己的类型，Server 按类型分发：\n1 2 3 4 5 // happy-server/sources/app/api/socket.ts:37-40 const clientType = socket.handshake.auth.clientType as 'session-scoped' | 'user-scoped' | 'machine-scoped' | undefined; const sessionId = socket.handshake.auth.sessionId as string | undefined; const machineId = socket.handshake.auth.machineId as string | undefined; 验证通过后，Server 根据 clientType 构建连接对象并注册到 eventRouter：\n1 2 3 4 5 6 7 8 9 // happy-server/sources/app/api/socket.ts:78-100 if (metadata.clientType === 'session-scoped' \u0026\u0026 sessionId) { connection = { connectionType: 'session-scoped', socket, userId, sessionId }; } else if (metadata.clientType === 'machine-scoped' \u0026\u0026 machineId) { connection = { connectionType: 'machine-scoped', socket, userId, machineId }; } else { connection = { connectionType: 'user-scoped', socket, userId }; } eventRouter.addConnection(userId, connection); 三种 scope 各有职责：\nScope 使用者 接收 发送 user-scoped App / Web 全局更新（会话列表、机器状态） ping、usage 上报 session-scoped CLI 会话进程 特定会话的消息更新 消息、状态变更 machine-scoped Daemon 机器级指令、RPC 请求 心跳、在线状态 手机打开某个 session 时只订阅该 session 的流，不会收到其他 session 的消息。这比 Kimi Web UI 的「所有消息广播给所有客户端」精细得多。\n4.2 RPC：为什么消息流不够 仅靠消息广播做不了交互式操作。消息流是 fire-and-forget 的，Server 推 update 给订阅者，不等回复。但有些操作需要同步等待响应：中止当前 turn、批准权限请求、在远程执行 bash 命令并拿到输出。\nHappy 在 Socket.IO 上实现了一套 RPC 转发，核心链路分三步：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 sequenceDiagram participant App as App (手机) participant Server as Server (公网) participant CLI as CLI (开发机) Note over CLI,Server: 1. 注册 CLI-\u003e\u003eServer: rpc-register({method: \"session-abc:bash\"}) Note over App,CLI: 2. 转发 App-\u003e\u003eServer: rpc-call({method: \"session-abc:bash\", params: encrypted}) Server-\u003e\u003eCLI: rpc-request({method, params}) Note over App,CLI: 3. 执行 + 返回 CLI--\u003e\u003eCLI: decrypt → handler(params) → encrypt CLI-\u003e\u003eServer: response (encrypted) Server-\u003e\u003eApp: callback({ok: true, result: encrypted}) Server 全程只做 socket 到 socket 的盲转发，看不到 params 和 result 的明文。\n注册。CLI 会话启动时，通过 RpcHandlerManager 向 Server 注册能处理的方法：\n1 2 3 4 5 6 7 8 9 10 // happy-cli/src/api/rpc/RpcHandlerManager.ts:36-47 registerHandler\u003cTRequest, TResponse\u003e( method: string, handler: RpcHandler\u003cTRequest, TResponse\u003e ): void { const prefixedMethod = this.getPrefixedMethod(method); this.handlers.set(prefixedMethod, handler); if (this.socket) { this.socket.emit('rpc-register', { method: prefixedMethod }); } } 方法名带 sessionId 前缀（如 session-abc:bash），Server 用这个前缀做路由。\n转发。App 发送 rpc-call，Server 查找目标 socket 并转发：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // happy-server/sources/app/api/socket/rpcHandler.ts:67-114（简化） socket.on('rpc-call', async (data, callback) =\u003e { const { method, params } = data; const targetSocket = rpcListeners.get(method); if (!targetSocket || !targetSocket.connected) { callback({ ok: false, error: 'RPC method not available' }); return; } if (targetSocket === socket) { callback({ ok: false, error: 'Cannot call RPC on the same socket' }); return; } const response = await targetSocket.timeout(30000) .emitWithAck('rpc-request', { method, params }); callback({ ok: true, result: response }); }); 执行。CLI 侧解密参数、调用 handler、加密响应返回：\n1 2 3 4 5 6 7 8 9 // happy-cli/src/api/rpc/RpcHandlerManager.ts:55-79（简化） async handleRequest(request: RpcRequest): Promise\u003cany\u003e { const handler = this.handlers.get(request.method); const decryptedParams = decrypt(this.encryptionKey, this.encryptionVariant, decodeBase64(request.params)); const result = await handler(decryptedParams); return encodeBase64(encrypt(this.encryptionKey, this.encryptionVariant, result)); } params 和返回值都是加密的 base64 字符串。Server 只做 socket 到 socket 的盲转发，看不到明文。即使 Server 被攻破，攻击者拿到的也只是密文。\n4.3 乐观并发控制 多个客户端同时修改会话状态时，Happy 用乐观并发防止互相覆盖：\n1 2 3 4 5 6 7 8 9 10 11 // happy-cli/src/api/apiSession.ts:553-575（简化） const answer = await this.socket.emitWithAck('update-state', { sid: this.sessionId, expectedVersion: this.agentStateVersion, agentState: encodeBase64(encrypt(this.encryptionKey, this.encryptionVariant, updated)) }); if (answer.result === 'version-mismatch') { this.agentStateVersion = answer.version; throw new Error('version mismatch'); // 触发 backoff 重试 } 客户端发送更新时带上 expectedVersion，Server 检查版本是否一致，不一致就拒绝。客户端拿到最新版本后重试。\n4.4 Server 还缺什么 Server 解决了 C1（跨网）、C2（单一数据源 + 版本化）、C3（控制权租约）、C5（E2EE + 盲转发）。\n但 C4 仍然失败。问题出在开发机那端：谁来管 Agent 进程？用户关掉终端窗口，CLI 进程退出，会话断了。Server 协调了多端通信，但管不了远端机器上的进程生命周期。需要一个在开发机上常驻的进程。\n5. 第四层：Daemon + CLI 分离 5.1 Daemon 的三个职责 Daemon 是 Happy 在开发机上的常驻后台进程，不做 AI 推理，只做三件事：\n管理 Session 子进程。维护一个 pidToTrackedSession Map，跟踪每个会话的 PID、sessionId、启动方式。 接收远程 spawn。手机点「新建会话」，Server 转发，Daemon 启动 CLI 子进程。 维护机器身份。通过 machine-scoped Socket 保持心跳，上报在线状态。 1 2 3 4 5 6 7 // happy-cli/src/daemon/run.ts:145-168 const daemonLockHandle = await acquireDaemonLock(5, 200); if (!daemonLockHandle) { process.exit(0); // 已有 Daemon 在运行 } const { credentials, machineId } = await authAndSetupMachineIfNeeded(); const pidToTrackedSession = new Map\u003cnumber, TrackedSession\u003e(); 5.2 排他锁 一台机器只能有一个 Daemon。Happy 用文件系统原子操作实现排他锁：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // happy-cli/src/persistence.ts:556-597（简化） async function acquireDaemonLock(maxAttempts, delayIncrementMs) { for (let attempt = 1; attempt \u003c= maxAttempts; attempt++) { try { const fileHandle = await open(configuration.daemonLockFile, constants.O_CREAT | constants.O_EXCL | constants.O_WRONLY); await fileHandle.writeFile(String(process.pid)); return fileHandle; } catch (error) { if (error.code === 'EEXIST') { const lockPid = readFileSync(configuration.daemonLockFile, 'utf-8'); try { process.kill(Number(lockPid), 0); // 信号 0：只检查进程是否存在 } catch { unlinkSync(configuration.daemonLockFile); // 进程已死，清理 continue; } } await new Promise(r =\u003e setTimeout(r, attempt * delayIncrementMs)); } } return null; } O_CREAT | O_EXCL 在文件系统层面是原子的，不存在 TOCTOU 竞态。锁文件里写 PID，用 kill(pid, 0) 检测死进程，信号 0 不杀进程，只验证进程是否存在。\n5.3 Control Server：本地 IPC Daemon 在 127.0.0.1 上起一个 HTTP 服务，端口号写入 daemon.state.json。CLI 读取这个文件找到 Daemon：\n端点 用途 POST /session-started CLI 会话启动后上报 sessionId POST /list 列出所有活跃会话 POST /spawn-session 创建新会话（手机远程触发） POST /stop 优雅关闭 Daemon CLI 和 Daemon 通过 HTTP 解耦：CLI 不需要知道 Daemon 的内部状态，不共享内存，不做进程间的直接调用。\n5.4 为什么 CLI 和 Daemon 不能合并 这是最容易引发困惑的拆分。答案在于进程模型不兼容：\n特征 CLI Daemon 生命周期 敲一次命令，跑完退出 开机启动，永久常驻 stdio 需要 TTY（键盘输入 + 终端渲染） 无 TTY（detached, stdio: ignore） 并发 一次一个会话 同时管理多个会话 启动方式 用户手动执行 自动启动（launchd / systemd） Socket scope session-scoped machine-scoped 让 CLI 常驻意味着放弃 TTY，但本地交互模式需要 TTY 来读键盘、渲染 UI。让 CLI 后台 fork 自己，stdin/stdout 断裂，本地交互无法继续。\nHappy 让 CLI 首次运行时自动 spawn Daemon：\n1 2 3 4 5 6 7 8 9 // happy-cli/src/index.ts:327-334 if (!(await isDaemonRunningCurrentlyInstalledHappyVersion())) { const daemonProcess = spawnHappyCLI(['daemon', 'start-sync'], { detached: true, // 独立于 CLI stdio: 'ignore', // 不继承 TTY env: process.env }); daemonProcess.unref(); // CLI 退出后 Daemon 继续活着 } detached: true + stdio: 'ignore' + unref()：三行配置把 Daemon 变成独立后台进程。CLI 保持了「敲一次命令跑完就退」的 Unix 哲学。\n5.5 全部满足 约束 直连 +Gateway +Server +Daemon C1 跨网 ❌ ✅ ✅ ✅ C2 多端一致 ⚠️ ❌ ✅ ✅ C3 控制权 ❌ ❌ ✅ ✅ C4 会话独立 ❌ ❌ ❌ ✅ C5 安全 ⚠️ ⚠️ ✅ ✅ 每多加一个组件，恰好解决上一层遗留的那一个不可绕过的约束。\n四组件的完整拓扑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 graph TB subgraph 手机 App[App] end subgraph 公网 Server[Server] end subgraph 开发机 Daemon[Daemon] CLI1[CLI 会话 1] CLI2[CLI 会话 2] end App \u003c--\u003e|\"user-scoped Socket全局状态 + RPC 调用\"| Server CLI1 \u003c--\u003e|\"session-scoped Socket会话消息 + 状态变更\"| Server CLI2 \u003c--\u003e|\"session-scoped Socket\"| Server Daemon \u003c--\u003e|\"machine-scoped Socket心跳 + 远程 spawn\"| Server Daemon ---|\"HTTP 127.0.0.1daemon.state.json\"| CLI1 Daemon ---|\"HTTP 127.0.0.1\"| CLI2 三种 Socket scope 各走各的通道：App 通过 user-scoped 看全局、发 RPC，CLI 通过 session-scoped 收发会话消息，Daemon 通过 machine-scoped 维持心跳和接收远程 spawn 指令。CLI 和 Daemon 之间通过本地 HTTP 解耦。\n6. 架构师视角：从零设计会怎样 6.1 三组件方案 如果只针对 Kimi CLI（单一 Provider），四组件可以缩减为三个：\n1 2 3 4 5 Client（iOS / Web） ↕ WSS + E2EE Relay Server（路由 + 认证 + 存储） ↕ WSS + E2EE Agent（开发机常驻 = Daemon + Provider Wrapper） 把 CLI 和 Daemon 合并成一个二进制：\nkimi-remote agent start → 常驻进程（Daemon 角色） kimi-remote agent attach → 终端 attach 到某个会话（CLI 角色） Happy 拆出独立 CLI 是因为要统一封装 Claude Code、Codex、Gemini 三种 Provider，每种输出格式不同，需要映射层转成统一的 9 种事件。Kimi CLI 只有一个 Provider，这层封装可以内嵌。\n6.2 不可省略的部分 无论怎么简化：\nServer 不可省。它解决的是物理约束：NAT 穿透和多端一致性。只要手机和开发机不在同一网络，就需要一个双方都能访问的中继。 Daemon 不可省。它解决的是进程约束：会话生命周期独立于前端。只要「关掉终端后 Agent 继续跑」是需求，就需要常驻进程。 组件数量是约束数量的函数。放宽约束可以减少组件：\n放宽的约束 可省略 代价 不需要跨网 Server 失去公网可达 不需要本地终端交互 CLI（合并到 Agent） 回到电脑时无法在终端继续 只有一个 Provider Provider 封装层 不影响功能 Server 自己部署 E2EE 安全性自己负责 6.3 约束推导方法：五维度扫描 上面的约束列表是怎么推导出来的？不是靠经验枚举，而是靠一个固定的扫描清单。\n面对任何远程操控场景，画出最简架构（两个节点之间一条线），然后按五个维度依次提问：\n维度 问的问题 答案为「是」时产生的约束 网络 A 能直接找到 B 吗？ 跨网可达 一致性 多个观察者看到的状态一样吗？ 多端状态一致 并发 多个操作者同时动手会冲突吗？ 控制权互斥 生命周期 UI 挂了，后台任务也死吗？ 会话独立于前端 交互模式 所有用户用同一种界面吗？ CLI / Daemon 分离 这五个维度的顺序对应从物理层到应用层的分层——和 OSI 模型的思路一样，先解决低层问题，再考虑高层。每个维度用同一个问题检验：不处理的话，能构造出什么灾难场景？ 能构造出来 → 硬约束，必须解决。构造不出来 → 软偏好，可以延后。\n以「控制权互斥」为例：多端连上后，能不能不做互斥，让用户先后操控？可以，lease 机制本质上就是在实现「先后操控」。但问题是谁来保证先后——如果没有 Server 维护 lease，两个客户端都认为自己是当前控制者，同时发 prompt，Agent 收到矛盾指令。约束不是「要不要互斥」，而是「谁来仲裁」。\n这个方法的原型是航空业的起飞前检查清单。1935 年，波音 Model 299（B-17 轰炸机原型）试飞坠毁，原因是首席试飞员忘记释放升降舵锁——飞机太复杂，超出了一个人的记忆力极限。波音的应对不是简化飞机，而是发明了一张清单：从燃油到襟翼到升降舵到仪表，逐层检查。五维度扫描法和它解决的是同一个问题：不是给新手用的拐杖，是给专家用的认知外骨骼。B-17 的试飞员是波音首席试飞员，不是菜鸟。\n日常版本：旅行前拍脑袋收拾行李，你会带三件外套却忘充电器。衣服是「看得见的维度」，充电器是「用到才想起的维度」。架构设计中「WebSocket 能不能连上」是衣服，「关掉终端后会话还在不在」是充电器。\n延伸练习 把这个方法用在一个新场景上：设计一个「手机远程操控家里电脑 Docker 容器」的系统——手机上启动/停止容器、查看日志、执行命令。\n画出最简架构 按五个维度扫描，每个维度构造一个灾难场景 对每个灾难场景决定加什么组件 和 Happy 的四组件对比：哪些一样？哪些不需要？为什么？ 关键不是答案对不对，而是每个维度能不能写出具体场景。写不出来的维度，恰好说明那个约束在这个场景下不存在——这本身就是一个有价值的结论。\n7. Wire 协议能复用吗：分层拆解 一个自然的问题：Kimi CLI 的 Web UI 已经有了 Wire 协议（JSON-RPC 2.0）和 BroadcastQueue，远程方案能直接复用吗？还是推翻重来设计一套新协议？\n答案不是「能」或「不能」，而是按层看。\n7.1 三层拆解 把 Wire 协议拆成三层，逐层评估：\n层 包含什么 能复用吗 理由 应用语义层 17 种事件类型 + 2 种请求类型 + WireMessageEnvelope 格式 ✅ 100% 复用 消息的含义不因传输方式改变 会话管理层 客户端身份、消息排序、请求匹配、控制权、心跳 ❌ 需要新增 本地方案没有这一层 传输层 stdio 管道、localhost WebSocket ⚠️ 替换 从本地换成公网 WSS + 中继 关键发现：Wire 协议目前只有两层（应用语义 + 传输），中间的会话管理层是空的。这不是设计缺陷——本地场景不需要。但远程场景必须补上。\n7.2 应用语义层：直接搬 Wire 定义的事件类型是纯业务语义，不绑定传输假设：TurnBegin/TurnEnd 标记对话边界，ContentPart 承载流式输出，ToolCall/ToolResult 处理工具调用，ApprovalRequest 请求用户批准。这些消息的格式和含义，无论走 stdio、localhost WebSocket 还是公网 WSS 中继，都不需要改。\nBroadcastQueue 的 SPMC 模式也可以复用——Server 中继收到 Agent 的消息后，用同样的「一个生产者、多个消费者」模式广播给同一个 session 的所有订阅者。\n7.3 会话管理层：必须新增 这是最大的工作量。本地方案有三个隐含假设，远程场景下全部失效：\n假设 1：只有一个客户端。_pending_requests 是全局字典，没有客户端隔离：\n1 2 # wire/server.py — 当前 self._pending_requests: dict[str, Request] = {} 远程场景需要按 session 隔离，并且同一个 ApprovalRequest 只能由当前 controller 响应，不能所有客户端都能回复。\n假设 2：消息天然有序。stdio 是单流，消息到达顺序就是发送顺序。公网 WebSocket 经过中继后，可能乱序到达。需要在每条消息上加 seq：\n1 2 # 远程方案需要 {\"seq\": 42, \"session_id\": \"abc\", \"message\": {...}} Happy 的 CoreUpdateContainer 正是这样做的——每条 update 带 id（用于去重）和 seq（用于排序）。\n假设 3：连接不会断。stdio 管道在进程活着时永远不断。公网连接随时可能断，需要心跳检测和断线重连后的状态同步。Wire 文件格式（JSONL）本身可以作为重连后的回放源——这部分 Kimi CLI 的 _replay_buffers 机制可以直接复用。\n7.4 传输层：整体替换 从 stdio 管道换成 WSS + 中继 Server，这是基础设施变更。另外 asyncio.Future（用于本地等待请求响应）不能跨网络传递，需要替换为带超时的回调机制——Happy 的 emitWithAck + 30 秒超时就是一种实现。\n7.5 结论：六成复用，四成新增 工作项 工作量 复用率 消息类型定义（17 + 2） 零 100% 序列化格式（JSON-RPC 2.0） 零 100% BroadcastQueue / 回放机制 小 80% 会话管理（身份 / 排序 / 心跳） 大 0%（新增） 控制权租约 中 0%（新增） 传输层替换（stdio → WSS） 中 0%（替换） 不需要推翻重来，也不能原样照搬。应用语义层完整复用，会话管理层从零新增，传输层整体替换。\n7.6 分层复用的 mindset 上面的分析用的思维方式是：按层拆解，逐层判断。面对「现有系统迁移到新环境」，不陷入「推翻重来」和「原样复用」的二元争论，而是拆成层，每一层独立评估。\n这个方法有一个跨越 150 年的同构案例：明治维新。不是全盘西化，也不是完全拒绝。伊藤博文按层拆解：军事技术层→全面引进西方模式（传输层替换）；行政制度层→选择性改造，学普鲁士而非英法，因为普鲁士的君主立宪更兼容天皇制（会话管理层重新设计）；文化认同层→保留天皇制和神道教（应用语义层复用）。同期清朝洋务运动的失败恰恰是层次判断错误：只换了传输层（买军舰），没动会话管理层（制度），甲午战争被「分层正确」的日本击败。\n日常版本：你换了城市工作。衣服直接搬过去——它们不绑定城市。健身房重新办卡——会员绑定了旧的地理位置，原样照搬毫无意义。朋友关系继续维护，但方式从线下聚餐扩展为线上联系——复用关系本身，替换承载关系的渠道。你不会因为换了城市就换掉所有朋友，也不会继续用旧城市的健身房卡。把这个直觉显式化，就是分层复用分析法。\n小结 回到开篇：手机远程操控 AI Coding CLI，为什么不是「一个 WebSocket」就能搞定？\n五个约束逐层叠加，每个约束淘汰一种更简单的方案：\nNAT 穿透淘汰了直连。手机找不到 NAT 后面的开发机，必须有公网中继（Server） 多端一致性淘汰了无状态 Gateway。Gateway 只转发不协调，两端看到的状态可能不一致 控制权互斥要求 Server 理解协议语义。Gateway 不知道谁是控制端 会话独立于前端要求常驻进程。关掉终端不能杀死 Agent（Daemon） 本地 + 远程并存让 CLI 和 Daemon 无法合并。TTY 需求和 detached 后台进程的模型冲突 Happy 的四组件恰好对应这五个约束。如果场景更简单（单 Provider、不需要本地终端交互），可以缩减到三组件。但 Server 和 Daemon 无论如何不可省，它们解决的是物理约束，不是设计偏好。\n判断自己需要几个组件：\n手机和开发机在同一网络？是：不需要 Server 关掉终端后 Agent 要继续跑？否：不需要 Daemon 电脑端也要交互式操控？否：CLI 可并入 Daemon 支持多种 AI Provider？否：封装层可内嵌 Server 自己部署？是：可不做 E2EE 每个「否」省掉一个组件。每个「是」加回来一个不可替代的齿轮。\n协议层面，Kimi CLI 的 Wire 协议不需要推翻——应用语义层（消息类型和格式）100% 复用，会话管理层（身份、排序、租约）从零新增，传输层整体替换。\n文章中用了三个可迁移的思维方法：\n方法 核心动作 远镜类比 近镜类比 逐步证伪法 从最简方案出发，用失败场景逼出组件 英国普通法：每条判例对应一次真实失败 搬新家：每件物品对应一个具体不便 五维度扫描法 按固定清单逐层检查「不处理会怎样」 B-17 坠毁催生飞行检查清单 旅行打包：显眼物品挤占注意力 分层复用分析法 按层拆解，逐层判断复用/扩展/新增 明治维新按层判断西化程度 换城市：衣服搬走、健身房重办、朋友维护 三个方法对应架构设计的三个阶段：发现约束、梳理约束、迁移方案。\n","wordCount":"1902","inLanguage":"zh","datePublished":"2026-02-17T09:50:00+08:00","dateModified":"2026-02-17T09:51:42+08:00","author":{"@type":"Person","name":"Miss-you"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://miss-you.github.io/posts/20260217-websocket-to-four-components/"},"publisher":{"@type":"Organization","name":"Yousa Driven Development | YDD","logo":{"@type":"ImageObject","url":"https://miss-you.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://miss-you.github.io/ accesskey=h title="Yousa Driven Development | YDD (Alt + H)">Yousa Driven Development | YDD</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://miss-you.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://miss-you.github.io/archives title=归档><span>归档</span></a></li><li><a href=https://miss-you.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://miss-you.github.io/tools/ title=工具><span>工具</span></a></li><li><a href=https://miss-you.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://github.com/Miss-you title=GitHub><span>GitHub</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://miss-you.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://miss-you.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化</h1><div class=post-description>从最简方案开始，每遇到一个绕不过去的约束，就加一个组件。四层方案逐层淘汰，最终发现四组件是五个硬约束逐层叠加的必然结果。</div><div class=post-meta><span title='2026-02-17 09:50:00 +0800 +0800'>二月 17, 2026</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;15999 字&nbsp;·&nbsp;Miss-you&nbsp;|&nbsp;<a href=https://github.com/Miss-you/miss-you.github.io/tree/main/content/posts/20260217-websocket-to-four-components/index.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-五个硬约束>1. 五个硬约束</a><ul><li><a href=#为什么是这五个>为什么是这五个</a></li></ul></li><li><a href=#2-第一层app-直连-web-ui>2. 第一层：App 直连 Web UI</a><ul><li><a href=#21-kimi-cli-的现有能力>2.1 Kimi CLI 的现有能力</a></li><li><a href=#22-卡在哪里>2.2 卡在哪里</a></li></ul></li><li><a href=#3-第二层web-ui--gateway>3. 第二层：Web UI + Gateway</a></li><li><a href=#4-第三层有状态的-server>4. 第三层：有状态的 Server</a><ul><li><a href=#41-三种-socket-scope>4.1 三种 Socket Scope</a></li><li><a href=#42-rpc为什么消息流不够>4.2 RPC：为什么消息流不够</a></li><li><a href=#43-乐观并发控制>4.3 乐观并发控制</a></li><li><a href=#44-server-还缺什么>4.4 Server 还缺什么</a></li></ul></li><li><a href=#5-第四层daemon--cli-分离>5. 第四层：Daemon + CLI 分离</a><ul><li><a href=#51-daemon-的三个职责>5.1 Daemon 的三个职责</a></li><li><a href=#52-排他锁>5.2 排他锁</a></li><li><a href=#53-control-server本地-ipc>5.3 Control Server：本地 IPC</a></li><li><a href=#54-为什么-cli-和-daemon-不能合并>5.4 为什么 CLI 和 Daemon 不能合并</a></li><li><a href=#55-全部满足>5.5 全部满足</a></li></ul></li><li><a href=#6-架构师视角从零设计会怎样>6. 架构师视角：从零设计会怎样</a><ul><li><a href=#61-三组件方案>6.1 三组件方案</a></li><li><a href=#62-不可省略的部分>6.2 不可省略的部分</a></li><li><a href=#63-约束推导方法五维度扫描>6.3 约束推导方法：五维度扫描</a></li><li><a href=#延伸练习>延伸练习</a></li></ul></li><li><a href=#7-wire-协议能复用吗分层拆解>7. Wire 协议能复用吗：分层拆解</a><ul><li><a href=#71-三层拆解>7.1 三层拆解</a></li><li><a href=#72-应用语义层直接搬>7.2 应用语义层：直接搬</a></li><li><a href=#73-会话管理层必须新增>7.3 会话管理层：必须新增</a></li><li><a href=#74-传输层整体替换>7.4 传输层：整体替换</a></li><li><a href=#75-结论六成复用四成新增>7.5 结论：六成复用，四成新增</a></li><li><a href=#76-分层复用的-mindset>7.6 分层复用的 mindset</a></li></ul></li><li><a href=#小结>小结</a></li></ul></nav></div></details></div><div class=post-content><h1 id=从一个-websocket-到四个组件多端操控-ai-coding-cli-的架构演化>从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化<a hidden class=anchor aria-hidden=true href=#从一个-websocket-到四个组件多端操控-ai-coding-cli-的架构演化>#</a></h1><p>手机远程操控电脑上的 AI Coding CLI，直觉上只需要一个 WebSocket 连接。CLI 在电脑上跑着，手机连上去，发消息，收输出，结束。</p><p>Kimi CLI 的 Web UI 做到了这一步。执行 <code>kimi web</code>，本地起一个 HTTP + WebSocket 服务，浏览器打开就能用。底层的 Wire 协议（JSON-RPC 2.0）支持多个 WebSocket 客户端同时接入，消息通过 <code>BroadcastQueue</code> 广播给所有订阅者。手机套个 WebView 就行了？</p><p>但 Happy 项目把同样的需求拆成了四个独立组件：CLI、Daemon、Server、App。四个进程，三种 Socket 连接类型，一套 RPC 转发机制，外加端到端加密（E2EE, End-to-End Encryption）。</p><p>为什么？</p><p>这篇文章用两个真实项目的源码来回答。从最简单的直连方案开始，每遇到一个绕不过去的约束，就加一个组件。四层方案逐层淘汰，最终会发现：四组件不是过度设计，而是五个硬约束逐层叠加的必然结果。</p><p>读完后能得到四样东西：</p><ol><li>每个组件存在的「不可替代的理由」，以及没有它会怎样</li><li>Happy 和 Kimi CLI 在消息路由、进程管理、控制权协调上的关键设计细节</li><li>一棵决策树，根据自己的场景判断需要几个组件、哪些可以省</li><li>现有 Wire 协议哪些能复用、哪些必须新增的分层分析</li></ol><hr><h2 id=1-五个硬约束>1. 五个硬约束<a hidden class=anchor aria-hidden=true href=#1-五个硬约束>#</a></h2><p>在拆解方案之前，先定义检验标准。「手机远程操控电脑上的 AI Coding CLI」这个需求拆成五个约束：</p><table><thead><tr><th>#</th><th>约束</th><th>含义</th></tr></thead><tbody><tr><td>C1</td><td>跨网可达</td><td>手机在 4G/5G，开发机在 NAT 后面，两者能通信</td></tr><tr><td>C2</td><td>多端一致</td><td>手机和电脑看到的会话状态完全一致</td></tr><tr><td>C3</td><td>控制权互斥</td><td>同一时刻只有一个终端在控制 Agent</td></tr><tr><td>C4</td><td>会话独立于前端</td><td>关掉手机或终端，Agent 继续跑，重新打开能接上</td></tr><tr><td>C5</td><td>安全</td><td>至少有认证，理想情况下端到端加密</td></tr></tbody></table><h3 id=为什么是这五个>为什么是这五个<a hidden class=anchor aria-hidden=true href=#为什么是这五个>#</a></h3><p>这张表不是头脑风暴列出来的，而是<strong>逐步证伪</strong>得到的——从最简方案开始，每一步找一个打破它的具体场景，被迫加一个组件，直到没有场景能打破：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>起点：手机直连电脑（一个 WebSocket）
</span></span><span class=line><span class=cl>  │
</span></span><span class=line><span class=cl>  ├─ &#34;手机 4G，电脑在家 WiFi&#34; → 连不上 → 需要公网中继
</span></span><span class=line><span class=cl>  │
</span></span><span class=line><span class=cl>  ├─ &#34;手机和电脑同时连上&#34; → 消息顺序不一致 → 中继要理解协议、做排序
</span></span><span class=line><span class=cl>  │
</span></span><span class=line><span class=cl>  ├─ &#34;两个客户端同时发 prompt&#34; → 谁算数？→ 要有人仲裁控制权
</span></span><span class=line><span class=cl>  │
</span></span><span class=line><span class=cl>  ├─ &#34;关掉终端窗口&#34; → Agent 跟着死了 → 需要独立的常驻进程
</span></span><span class=line><span class=cl>  │
</span></span><span class=line><span class=cl>  └─ &#34;在电脑上也想交互式操作&#34; → 常驻进程没有 TTY → 需要额外的交互前端
</span></span></code></pre></td></tr></table></div></div><p>这个拆解有三个性质：</p><ol><li><strong>每个约束都有反例</strong>。删掉任何一个，都能构造一个具体的故障场景——后面四节逐一展示。</li><li><strong>约束之间有依赖序</strong>。讨论「控制权互斥」的前提是「多端已经连上」，讨论「多端连接」的前提是「网络可达」。链条是：网络可达 → 多端共存 → 多端冲突 → 进程生命周期 → 交互模式分离。每一层的问题，只有在前一层被解决后才会暴露。</li><li><strong>每个约束恰好淘汰一种方案</strong>。没有两个约束淘汰同一种方案，没有冗余。</li></ol><p>这套「从最简开始，被失败逼着加组件」的方法有一个跨越八百年的同构案例：英国普通法。不是某位国王召集法学家写出完美法典，而是从亨利二世时期最简单的「派巡回法官解决纠纷」开始，每次新型案件暴露旧规则的不足，法官被迫创造一条新判例。每条规则都指向一次真实的失败——和我们的每个组件指向一个具体的约束是同一套逻辑。更贴身的版本：搬进新家，第一天只有一个行李箱。没有晾衣架就买晾衣架，地板湿滑就买防滑垫。三个月后家里每件东西都对应一个真实的不便，没有一件多余。如果你的架构中某个组件说不出它对应的失败场景，它大概率是过度设计。</p><p>后面每种方案都用这五个约束打分。</p><hr><h2 id=2-第一层app-直连-web-ui>2. 第一层：App 直连 Web UI<a hidden class=anchor aria-hidden=true href=#2-第一层app-直连-web-ui>#</a></h2><h3 id=21-kimi-cli-的现有能力>2.1 Kimi CLI 的现有能力<a hidden class=anchor aria-hidden=true href=#21-kimi-cli-的现有能力>#</a></h3><p>Kimi CLI 已经具备外部 UI 接入的基础设施。执行 <code>kimi web</code>，本地起一个 FastAPI 服务，浏览器通过 WebSocket 连接 Wire 协议与 Agent 内核交互。</p><p>底层消息分发采用 SPMC（Single Producer, Multiple Consumer）广播队列：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># kimi-cli/src/kimi_cli/utils/broadcast.py</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BroadcastQueue</span><span class=p>[</span><span class=n>T</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_queues</span><span class=p>:</span> <span class=nb>set</span><span class=p>[</span><span class=n>Queue</span><span class=p>[</span><span class=n>T</span><span class=p>]]</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>subscribe</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Queue</span><span class=p>[</span><span class=n>T</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>queue</span><span class=p>:</span> <span class=n>Queue</span><span class=p>[</span><span class=n>T</span><span class=p>]</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_queues</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>queue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>publish_nowait</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>item</span><span class=p>:</span> <span class=n>T</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>queue</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>_queues</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>queue</span><span class=o>.</span><span class=n>put_nowait</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>每个 WebSocket 客户端调用 <code>subscribe()</code> 获得自己的队列，Agent 内核每产生一条消息就通过 <code>publish_nowait</code> 广播给所有订阅者。多个客户端可以同时观看同一个会话的输出。</p><p>新客户端中途加入时，<code>SessionProcess</code> 用缓冲机制衔接历史回放和实时消息：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># kimi-cli/src/kimi_cli/web/runner/process.py:526-538</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>_broadcast</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>message</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>_ws_lock</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>to_send</span><span class=p>:</span> <span class=nb>list</span><span class=p>[</span><span class=n>WebSocket</span><span class=p>]</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>ws</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>_websockets</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>buffer</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_replay_buffers</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>ws</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>buffer</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>buffer</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>message</span><span class=p>)</span>   <span class=c1># 正在回放历史：缓冲实时消息</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>to_send</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>ws</span><span class=p>)</span>       <span class=c1># 已进入实时：直接发送</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>ws</span> <span class=ow>in</span> <span class=n>to_send</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=n>ws</span><span class=o>.</span><span class=n>send_text</span><span class=p>(</span><span class=n>message</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>正在回放 <code>wire.jsonl</code> 历史的客户端，实时消息暂存到 <code>_replay_buffers</code>。回放结束后 flush 缓冲区，无缝切换到实时流，解决了「中途加入不丢消息」的问题。</p><h3 id=22-卡在哪里>2.2 卡在哪里<a hidden class=anchor aria-hidden=true href=#22-卡在哪里>#</a></h3><p>用五个约束检验这个方案：</p><p><strong>C1 跨网失败</strong>。Web 服务默认绑定 <code>127.0.0.1</code>，加 <code>--network</code> 后绑定 <code>0.0.0.0</code>，但开发机仍然在 NAT 后面。手机在 4G 网络上找不到这台机器。用户需要自己搞 Tailscale 或 ngrok，不是产品化方案。</p><p><strong>C3 控制权失败</strong>。Wire 协议的请求响应是 1:1 的。Agent 发出 <code>ApprovalRequest</code>（请求用户批准某个工具调用）时，请求放进一个全局字典：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># kimi-cli/src/kimi_cli/wire/server.py:75-76</span>
</span></span><span class=line><span class=cl><span class=bp>self</span><span class=o>.</span><span class=n>_pending_requests</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Request</span><span class=p>]</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;Maps JSON RPC message IDs to pending Requests.&#34;&#34;&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>这个字典没有客户端隔离。两个 WebSocket 同时连接时，都能看到同一个 <code>ApprovalRequest</code>，都能响应它，谁先回复谁生效。两个客户端还可以在 session 空闲时同时发 prompt，<code>is_busy</code> 检查在 session 空闲时不起作用。</p><p><strong>C4 会话独立失败</strong>。Worker 子进程的生命周期绑定在 FastAPI Web 服务器上：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># kimi-cli/src/kimi_cli/web/app.py:168-186</span>
</span></span><span class=line><span class=cl><span class=nd>@asynccontextmanager</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>lifespan</span><span class=p>(</span><span class=n>app</span><span class=p>:</span> <span class=n>FastAPI</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>runner</span> <span class=o>=</span> <span class=n>KimiCLIRunner</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>app</span><span class=o>.</span><span class=n>state</span><span class=o>.</span><span class=n>runner</span> <span class=o>=</span> <span class=n>runner</span>
</span></span><span class=line><span class=cl>    <span class=n>runner</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>yield</span>
</span></span><span class=line><span class=cl>    <span class=k>finally</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=n>runner</span><span class=o>.</span><span class=n>stop</span><span class=p>()</span>  <span class=c1># Web 服务关闭 → 所有 Worker 子进程被杀</span>
</span></span></code></pre></td></tr></table></div></div><p>关掉终端窗口，Web 服务退出，<code>runner.stop()</code> 杀死所有 Worker 子进程，会话丢失。</p><p>打分：</p><table><thead><tr><th>约束</th><th style=text-align:center>直连方案</th></tr></thead><tbody><tr><td>C1 跨网</td><td style=text-align:center>❌</td></tr><tr><td>C2 多端一致</td><td style=text-align:center>⚠️ 广播可用，无协调</td></tr><tr><td>C3 控制权</td><td style=text-align:center>❌</td></tr><tr><td>C4 会话独立</td><td style=text-align:center>❌</td></tr><tr><td>C5 安全</td><td style=text-align:center>⚠️ Token，无 E2EE</td></tr></tbody></table><p>直连方案适合「同一张桌子上多开一个屏幕看输出」。要跨网、要多端、要产品化，得继续往上叠。</p><hr><h2 id=3-第二层web-ui--gateway>3. 第二层：Web UI + Gateway<a hidden class=anchor aria-hidden=true href=#3-第二层web-ui--gateway>#</a></h2><p>最直觉的补救：在 Web UI 前面加一层反向代理（Caddy、nginx、Cloudflare Tunnel），解决网络可达和 TLS 终止。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>iPhone ──HTTPS/WSS──▶ Gateway（公网） ──HTTP/WS──▶ 开发机 kimi web
</span></span></code></pre></td></tr></table></div></div><p>C1 跨网解决了，C5 传输层加密有了。但 Gateway 只是一根管道，不理解 Wire 协议的语义：</p><ul><li><strong>C2 多端一致</strong>：Gateway 透明转发，两个客户端各自和 Web UI 通信，没有人协调消息顺序</li><li><strong>C3 控制权</strong>：Gateway 不知道谁是控制端，两个客户端仍然可以同时发 prompt</li><li><strong>C4 会话独立</strong>：Worker 仍然绑在 Web 服务进程上，Gateway 管不了进程生命周期</li></ul><p>如果 Gateway 部署在第三方（比如 Cloudflare），它作为中间人能看到所有明文，代码、对话、工具调用参数对第三方完全透明。</p><table><thead><tr><th>约束</th><th style=text-align:center>直连</th><th style=text-align:center>+Gateway</th></tr></thead><tbody><tr><td>C1 跨网</td><td style=text-align:center>❌</td><td style=text-align:center>✅</td></tr><tr><td>C2 多端一致</td><td style=text-align:center>⚠️</td><td style=text-align:center>❌</td></tr><tr><td>C3 控制权</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td></tr><tr><td>C4 会话独立</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td></tr><tr><td>C5 安全</td><td style=text-align:center>⚠️</td><td style=text-align:center>⚠️ TLS only</td></tr></tbody></table><p>Gateway 解决了「网络管道」，但「谁说了算」需要一个理解协议的中间层。</p><hr><h2 id=4-第三层有状态的-server>4. 第三层：有状态的 Server<a hidden class=anchor aria-hidden=true href=#4-第三层有状态的-server>#</a></h2><p>把 Gateway 升级为「理解业务语义的 Server」。这是 Happy 架构中最重量级的组件。</p><h3 id=41-三种-socket-scope>4.1 三种 Socket Scope<a hidden class=anchor aria-hidden=true href=#41-三种-socket-scope>#</a></h3><p>Happy Server 不是简单地广播消息给所有连接。每个 Socket.IO 连接在握手时声明自己的类型，Server 按类型分发：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-server/sources/app/api/socket.ts:37-40
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>clientType</span> <span class=o>=</span> <span class=nx>socket</span><span class=p>.</span><span class=nx>handshake</span><span class=p>.</span><span class=nx>auth</span><span class=p>.</span><span class=nx>clientType</span>
</span></span><span class=line><span class=cl>    <span class=kr>as</span> <span class=s1>&#39;session-scoped&#39;</span> <span class=o>|</span> <span class=s1>&#39;user-scoped&#39;</span> <span class=o>|</span> <span class=s1>&#39;machine-scoped&#39;</span> <span class=o>|</span> <span class=kc>undefined</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>sessionId</span> <span class=o>=</span> <span class=nx>socket</span><span class=p>.</span><span class=nx>handshake</span><span class=p>.</span><span class=nx>auth</span><span class=p>.</span><span class=nx>sessionId</span> <span class=kr>as</span> <span class=kt>string</span> <span class=o>|</span> <span class=kc>undefined</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>machineId</span> <span class=o>=</span> <span class=nx>socket</span><span class=p>.</span><span class=nx>handshake</span><span class=p>.</span><span class=nx>auth</span><span class=p>.</span><span class=nx>machineId</span> <span class=kr>as</span> <span class=kt>string</span> <span class=o>|</span> <span class=kc>undefined</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>验证通过后，Server 根据 <code>clientType</code> 构建连接对象并注册到 <code>eventRouter</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6>6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7>7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8>8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-server/sources/app/api/socket.ts:78-100
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nx>metadata</span><span class=p>.</span><span class=nx>clientType</span> <span class=o>===</span> <span class=s1>&#39;session-scoped&#39;</span> <span class=o>&amp;&amp;</span> <span class=nx>sessionId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>connection</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>connectionType</span><span class=o>:</span> <span class=s1>&#39;session-scoped&#39;</span><span class=p>,</span> <span class=nx>socket</span><span class=p>,</span> <span class=nx>userId</span><span class=p>,</span> <span class=nx>sessionId</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=nx>metadata</span><span class=p>.</span><span class=nx>clientType</span> <span class=o>===</span> <span class=s1>&#39;machine-scoped&#39;</span> <span class=o>&amp;&amp;</span> <span class=nx>machineId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>connection</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>connectionType</span><span class=o>:</span> <span class=s1>&#39;machine-scoped&#39;</span><span class=p>,</span> <span class=nx>socket</span><span class=p>,</span> <span class=nx>userId</span><span class=p>,</span> <span class=nx>machineId</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>connection</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>connectionType</span><span class=o>:</span> <span class=s1>&#39;user-scoped&#39;</span><span class=p>,</span> <span class=nx>socket</span><span class=p>,</span> <span class=nx>userId</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>eventRouter</span><span class=p>.</span><span class=nx>addConnection</span><span class=p>(</span><span class=nx>userId</span><span class=p>,</span> <span class=nx>connection</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>三种 scope 各有职责：</p><table><thead><tr><th>Scope</th><th>使用者</th><th>接收</th><th>发送</th></tr></thead><tbody><tr><td>user-scoped</td><td>App / Web</td><td>全局更新（会话列表、机器状态）</td><td>ping、usage 上报</td></tr><tr><td>session-scoped</td><td>CLI 会话进程</td><td>特定会话的消息更新</td><td>消息、状态变更</td></tr><tr><td>machine-scoped</td><td>Daemon</td><td>机器级指令、RPC 请求</td><td>心跳、在线状态</td></tr></tbody></table><p>手机打开某个 session 时只订阅该 session 的流，不会收到其他 session 的消息。这比 Kimi Web UI 的「所有消息广播给所有客户端」精细得多。</p><h3 id=42-rpc为什么消息流不够>4.2 RPC：为什么消息流不够<a hidden class=anchor aria-hidden=true href=#42-rpc为什么消息流不够>#</a></h3><p>仅靠消息广播做不了交互式操作。消息流是 fire-and-forget 的，Server 推 update 给订阅者，不等回复。但有些操作需要同步等待响应：中止当前 turn、批准权限请求、在远程执行 bash 命令并拿到输出。</p><p>Happy 在 Socket.IO 上实现了一套 RPC 转发，核心链路分三步：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sequenceDiagram
</span></span><span class=line><span class=cl>    participant App as App (手机)
</span></span><span class=line><span class=cl>    participant Server as Server (公网)
</span></span><span class=line><span class=cl>    participant CLI as CLI (开发机)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Note over CLI,Server: 1. 注册
</span></span><span class=line><span class=cl>    CLI-&gt;&gt;Server: rpc-register({method: &#34;session-abc:bash&#34;})
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Note over App,CLI: 2. 转发
</span></span><span class=line><span class=cl>    App-&gt;&gt;Server: rpc-call({method: &#34;session-abc:bash&#34;, params: encrypted})
</span></span><span class=line><span class=cl>    Server-&gt;&gt;CLI: rpc-request({method, params})
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Note over App,CLI: 3. 执行 + 返回
</span></span><span class=line><span class=cl>    CLI--&gt;&gt;CLI: decrypt → handler(params) → encrypt
</span></span><span class=line><span class=cl>    CLI-&gt;&gt;Server: response (encrypted)
</span></span><span class=line><span class=cl>    Server-&gt;&gt;App: callback({ok: true, result: encrypted})
</span></span></code></pre></td></tr></table></div></div><p>Server 全程只做 socket 到 socket 的盲转发，看不到 params 和 result 的明文。</p><p><strong>注册</strong>。CLI 会话启动时，通过 <code>RpcHandlerManager</code> 向 Server 注册能处理的方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-cli/src/api/rpc/RpcHandlerManager.ts:36-47
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>registerHandler</span><span class=p>&lt;</span><span class=nt>TRequest</span><span class=p>,</span> <span class=na>TResponse</span><span class=p>&gt;(</span>
</span></span><span class=line><span class=cl>    <span class=nx>method</span>: <span class=kt>string</span><span class=p>,</span> <span class=nx>handler</span>: <span class=kt>RpcHandler</span><span class=p>&lt;</span><span class=nt>TRequest</span><span class=p>,</span> <span class=na>TResponse</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>)</span><span class=o>:</span> <span class=k>void</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>prefixedMethod</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>getPrefixedMethod</span><span class=p>(</span><span class=nx>method</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>handlers</span><span class=p>.</span><span class=kr>set</span><span class=p>(</span><span class=nx>prefixedMethod</span><span class=p>,</span> <span class=nx>handler</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>socket</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>socket</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;rpc-register&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>method</span>: <span class=kt>prefixedMethod</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>方法名带 <code>sessionId</code> 前缀（如 <code>session-abc:bash</code>），Server 用这个前缀做路由。</p><p><strong>转发</strong>。App 发送 <code>rpc-call</code>，Server 查找目标 socket 并转发：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-server/sources/app/api/socket/rpcHandler.ts:67-114（简化）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>socket</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;rpc-call&#39;</span><span class=p>,</span> <span class=kr>async</span> <span class=p>(</span><span class=nx>data</span><span class=p>,</span> <span class=nx>callback</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=p>{</span> <span class=nx>method</span><span class=p>,</span> <span class=nx>params</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>targetSocket</span> <span class=o>=</span> <span class=nx>rpcListeners</span><span class=p>.</span><span class=kr>get</span><span class=p>(</span><span class=nx>method</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>targetSocket</span> <span class=o>||</span> <span class=o>!</span><span class=nx>targetSocket</span><span class=p>.</span><span class=nx>connected</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>callback</span><span class=p>({</span> <span class=nx>ok</span>: <span class=kt>false</span><span class=p>,</span> <span class=nx>error</span><span class=o>:</span> <span class=s1>&#39;RPC method not available&#39;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>targetSocket</span> <span class=o>===</span> <span class=nx>socket</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>callback</span><span class=p>({</span> <span class=nx>ok</span>: <span class=kt>false</span><span class=p>,</span> <span class=nx>error</span><span class=o>:</span> <span class=s1>&#39;Cannot call RPC on the same socket&#39;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>response</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>targetSocket</span><span class=p>.</span><span class=nx>timeout</span><span class=p>(</span><span class=mi>30000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=nx>emitWithAck</span><span class=p>(</span><span class=s1>&#39;rpc-request&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>method</span><span class=p>,</span> <span class=nx>params</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=nx>callback</span><span class=p>({</span> <span class=nx>ok</span>: <span class=kt>true</span><span class=p>,</span> <span class=nx>result</span>: <span class=kt>response</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>执行</strong>。CLI 侧解密参数、调用 handler、加密响应返回：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5>5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6>6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7>7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8>8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-cli/src/api/rpc/RpcHandlerManager.ts:55-79（简化）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>async</span> <span class=nx>handleRequest</span><span class=p>(</span><span class=nx>request</span>: <span class=kt>RpcRequest</span><span class=p>)</span><span class=o>:</span> <span class=nx>Promise</span><span class=p>&lt;</span><span class=nt>any</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>handler</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>handlers</span><span class=p>.</span><span class=kr>get</span><span class=p>(</span><span class=nx>request</span><span class=p>.</span><span class=nx>method</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>decryptedParams</span> <span class=o>=</span> <span class=nx>decrypt</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>encryptionKey</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>encryptionVariant</span><span class=p>,</span> <span class=nx>decodeBase64</span><span class=p>(</span><span class=nx>request</span><span class=p>.</span><span class=nx>params</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>handler</span><span class=p>(</span><span class=nx>decryptedParams</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>encodeBase64</span><span class=p>(</span><span class=nx>encrypt</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>encryptionKey</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>encryptionVariant</span><span class=p>,</span> <span class=nx>result</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>params</code> 和返回值都是加密的 base64 字符串。Server 只做 socket 到 socket 的盲转发，看不到明文。即使 Server 被攻破，攻击者拿到的也只是密文。</p><h3 id=43-乐观并发控制>4.3 乐观并发控制<a hidden class=anchor aria-hidden=true href=#43-乐观并发控制>#</a></h3><p>多个客户端同时修改会话状态时，Happy 用乐观并发防止互相覆盖：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-cli/src/api/apiSession.ts:553-575（简化）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>answer</span> <span class=o>=</span> <span class=k>await</span> <span class=k>this</span><span class=p>.</span><span class=nx>socket</span><span class=p>.</span><span class=nx>emitWithAck</span><span class=p>(</span><span class=s1>&#39;update-state&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sid</span>: <span class=kt>this.sessionId</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>expectedVersion</span>: <span class=kt>this.agentStateVersion</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>agentState</span>: <span class=kt>encodeBase64</span><span class=p>(</span><span class=nx>encrypt</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>encryptionKey</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>encryptionVariant</span><span class=p>,</span> <span class=nx>updated</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nx>answer</span><span class=p>.</span><span class=nx>result</span> <span class=o>===</span> <span class=s1>&#39;version-mismatch&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>agentStateVersion</span> <span class=o>=</span> <span class=nx>answer</span><span class=p>.</span><span class=nx>version</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;version mismatch&#39;</span><span class=p>);</span> <span class=c1>// 触发 backoff 重试
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>客户端发送更新时带上 <code>expectedVersion</code>，Server 检查版本是否一致，不一致就拒绝。客户端拿到最新版本后重试。</p><h3 id=44-server-还缺什么>4.4 Server 还缺什么<a hidden class=anchor aria-hidden=true href=#44-server-还缺什么>#</a></h3><p>Server 解决了 C1（跨网）、C2（单一数据源 + 版本化）、C3（控制权租约）、C5（E2EE + 盲转发）。</p><p>但 C4 仍然失败。问题出在开发机那端：谁来管 Agent 进程？用户关掉终端窗口，CLI 进程退出，会话断了。Server 协调了多端通信，但管不了远端机器上的进程生命周期。需要一个在开发机上<strong>常驻</strong>的进程。</p><hr><h2 id=5-第四层daemon--cli-分离>5. 第四层：Daemon + CLI 分离<a hidden class=anchor aria-hidden=true href=#5-第四层daemon--cli-分离>#</a></h2><h3 id=51-daemon-的三个职责>5.1 Daemon 的三个职责<a hidden class=anchor aria-hidden=true href=#51-daemon-的三个职责>#</a></h3><p>Daemon 是 Happy 在开发机上的常驻后台进程，不做 AI 推理，只做三件事：</p><ol><li><strong>管理 Session 子进程</strong>。维护一个 <code>pidToTrackedSession</code> Map，跟踪每个会话的 PID、<code>sessionId</code>、启动方式。</li><li><strong>接收远程 spawn</strong>。手机点「新建会话」，Server 转发，Daemon 启动 CLI 子进程。</li><li><strong>维护机器身份</strong>。通过 machine-scoped Socket 保持心跳，上报在线状态。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3>3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4>4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5>5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6>6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-cli/src/daemon/run.ts:145-168
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>daemonLockHandle</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>acquireDaemonLock</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mi>200</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>daemonLockHandle</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>process</span><span class=p>.</span><span class=nx>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// 已有 Daemon 在运行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=p>{</span> <span class=nx>credentials</span><span class=p>,</span> <span class=nx>machineId</span> <span class=p>}</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>authAndSetupMachineIfNeeded</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>pidToTrackedSession</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>&lt;</span><span class=nt>number</span><span class=p>,</span> <span class=na>TrackedSession</span><span class=p>&gt;();</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=52-排他锁>5.2 排他锁<a hidden class=anchor aria-hidden=true href=#52-排他锁>#</a></h3><p>一台机器只能有一个 Daemon。Happy 用文件系统原子操作实现排他锁：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span><span class=lnt id=hl-14-11><a class=lnlinks href=#hl-14-11>11</a>
</span><span class=lnt id=hl-14-12><a class=lnlinks href=#hl-14-12>12</a>
</span><span class=lnt id=hl-14-13><a class=lnlinks href=#hl-14-13>13</a>
</span><span class=lnt id=hl-14-14><a class=lnlinks href=#hl-14-14>14</a>
</span><span class=lnt id=hl-14-15><a class=lnlinks href=#hl-14-15>15</a>
</span><span class=lnt id=hl-14-16><a class=lnlinks href=#hl-14-16>16</a>
</span><span class=lnt id=hl-14-17><a class=lnlinks href=#hl-14-17>17</a>
</span><span class=lnt id=hl-14-18><a class=lnlinks href=#hl-14-18>18</a>
</span><span class=lnt id=hl-14-19><a class=lnlinks href=#hl-14-19>19</a>
</span><span class=lnt id=hl-14-20><a class=lnlinks href=#hl-14-20>20</a>
</span><span class=lnt id=hl-14-21><a class=lnlinks href=#hl-14-21>21</a>
</span><span class=lnt id=hl-14-22><a class=lnlinks href=#hl-14-22>22</a>
</span><span class=lnt id=hl-14-23><a class=lnlinks href=#hl-14-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-cli/src/persistence.ts:556-597（简化）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>async</span> <span class=kd>function</span> <span class=nx>acquireDaemonLock</span><span class=p>(</span><span class=nx>maxAttempts</span><span class=p>,</span> <span class=nx>delayIncrementMs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>attempt</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>attempt</span> <span class=o>&lt;=</span> <span class=nx>maxAttempts</span><span class=p>;</span> <span class=nx>attempt</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kr>const</span> <span class=nx>fileHandle</span> <span class=o>=</span> <span class=k>await</span> <span class=nx>open</span><span class=p>(</span><span class=nx>configuration</span><span class=p>.</span><span class=nx>daemonLockFile</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=nx>constants</span><span class=p>.</span><span class=nx>O_CREAT</span> <span class=o>|</span> <span class=nx>constants</span><span class=p>.</span><span class=nx>O_EXCL</span> <span class=o>|</span> <span class=nx>constants</span><span class=p>.</span><span class=nx>O_WRONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>await</span> <span class=nx>fileHandle</span><span class=p>.</span><span class=nx>writeFile</span><span class=p>(</span><span class=nb>String</span><span class=p>(</span><span class=nx>process</span><span class=p>.</span><span class=nx>pid</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>fileHandle</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nx>error</span><span class=p>.</span><span class=nx>code</span> <span class=o>===</span> <span class=s1>&#39;EEXIST&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kr>const</span> <span class=nx>lockPid</span> <span class=o>=</span> <span class=nx>readFileSync</span><span class=p>(</span><span class=nx>configuration</span><span class=p>.</span><span class=nx>daemonLockFile</span><span class=p>,</span> <span class=s1>&#39;utf-8&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>process</span><span class=p>.</span><span class=nx>kill</span><span class=p>(</span><span class=nb>Number</span><span class=p>(</span><span class=nx>lockPid</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// 信号 0：只检查进程是否存在
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>}</span> <span class=k>catch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nx>unlinkSync</span><span class=p>(</span><span class=nx>configuration</span><span class=p>.</span><span class=nx>daemonLockFile</span><span class=p>);</span> <span class=c1>// 进程已死，清理
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>await</span> <span class=k>new</span> <span class=nx>Promise</span><span class=p>(</span><span class=nx>r</span> <span class=o>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(</span><span class=nx>r</span><span class=p>,</span> <span class=nx>attempt</span> <span class=o>*</span> <span class=nx>delayIncrementMs</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>O_CREAT | O_EXCL</code> 在文件系统层面是原子的，不存在 TOCTOU 竞态。锁文件里写 PID，用 <code>kill(pid, 0)</code> 检测死进程，信号 0 不杀进程，只验证进程是否存在。</p><h3 id=53-control-server本地-ipc>5.3 Control Server：本地 IPC<a hidden class=anchor aria-hidden=true href=#53-control-server本地-ipc>#</a></h3><p>Daemon 在 <code>127.0.0.1</code> 上起一个 HTTP 服务，端口号写入 <code>daemon.state.json</code>。CLI 读取这个文件找到 Daemon：</p><table><thead><tr><th>端点</th><th>用途</th></tr></thead><tbody><tr><td><code>POST /session-started</code></td><td>CLI 会话启动后上报 <code>sessionId</code></td></tr><tr><td><code>POST /list</code></td><td>列出所有活跃会话</td></tr><tr><td><code>POST /spawn-session</code></td><td>创建新会话（手机远程触发）</td></tr><tr><td><code>POST /stop</code></td><td>优雅关闭 Daemon</td></tr></tbody></table><p>CLI 和 Daemon 通过 HTTP 解耦：CLI 不需要知道 Daemon 的内部状态，不共享内存，不做进程间的直接调用。</p><h3 id=54-为什么-cli-和-daemon-不能合并>5.4 为什么 CLI 和 Daemon 不能合并<a hidden class=anchor aria-hidden=true href=#54-为什么-cli-和-daemon-不能合并>#</a></h3><p>这是最容易引发困惑的拆分。答案在于进程模型不兼容：</p><table><thead><tr><th>特征</th><th>CLI</th><th>Daemon</th></tr></thead><tbody><tr><td>生命周期</td><td>敲一次命令，跑完退出</td><td>开机启动，永久常驻</td></tr><tr><td>stdio</td><td>需要 TTY（键盘输入 + 终端渲染）</td><td>无 TTY（detached, stdio: ignore）</td></tr><tr><td>并发</td><td>一次一个会话</td><td>同时管理多个会话</td></tr><tr><td>启动方式</td><td>用户手动执行</td><td>自动启动（launchd / systemd）</td></tr><tr><td>Socket scope</td><td>session-scoped</td><td>machine-scoped</td></tr></tbody></table><p>让 CLI 常驻意味着放弃 TTY，但本地交互模式需要 TTY 来读键盘、渲染 UI。让 CLI 后台 fork 自己，stdin/stdout 断裂，本地交互无法继续。</p><p>Happy 让 CLI 首次运行时自动 spawn Daemon：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4>4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5>5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6>6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7>7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8>8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=c1>// happy-cli/src/index.ts:327-334
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=k>await</span> <span class=nx>isDaemonRunningCurrentlyInstalledHappyVersion</span><span class=p>()))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>daemonProcess</span> <span class=o>=</span> <span class=nx>spawnHappyCLI</span><span class=p>([</span><span class=s1>&#39;daemon&#39;</span><span class=p>,</span> <span class=s1>&#39;start-sync&#39;</span><span class=p>],</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>detached</span>: <span class=kt>true</span><span class=p>,</span>    <span class=c1>// 独立于 CLI
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>stdio</span><span class=o>:</span> <span class=s1>&#39;ignore&#39;</span><span class=p>,</span>   <span class=c1>// 不继承 TTY
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>env</span>: <span class=kt>process.env</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=nx>daemonProcess</span><span class=p>.</span><span class=nx>unref</span><span class=p>();</span> <span class=c1>// CLI 退出后 Daemon 继续活着
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>detached: true</code> + <code>stdio: 'ignore'</code> + <code>unref()</code>：三行配置把 Daemon 变成独立后台进程。CLI 保持了「敲一次命令跑完就退」的 Unix 哲学。</p><h3 id=55-全部满足>5.5 全部满足<a hidden class=anchor aria-hidden=true href=#55-全部满足>#</a></h3><table><thead><tr><th>约束</th><th style=text-align:center>直连</th><th style=text-align:center>+Gateway</th><th style=text-align:center>+Server</th><th style=text-align:center>+Daemon</th></tr></thead><tbody><tr><td>C1 跨网</td><td style=text-align:center>❌</td><td style=text-align:center>✅</td><td style=text-align:center>✅</td><td style=text-align:center>✅</td></tr><tr><td>C2 多端一致</td><td style=text-align:center>⚠️</td><td style=text-align:center>❌</td><td style=text-align:center>✅</td><td style=text-align:center>✅</td></tr><tr><td>C3 控制权</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td><td style=text-align:center>✅</td><td style=text-align:center>✅</td></tr><tr><td>C4 会话独立</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td><td style=text-align:center>❌</td><td style=text-align:center>✅</td></tr><tr><td>C5 安全</td><td style=text-align:center>⚠️</td><td style=text-align:center>⚠️</td><td style=text-align:center>✅</td><td style=text-align:center>✅</td></tr></tbody></table><p>每多加一个组件，恰好解决上一层遗留的那一个不可绕过的约束。</p><p>四组件的完整拓扑：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span><span class=lnt id=hl-16-12><a class=lnlinks href=#hl-16-12>12</a>
</span><span class=lnt id=hl-16-13><a class=lnlinks href=#hl-16-13>13</a>
</span><span class=lnt id=hl-16-14><a class=lnlinks href=#hl-16-14>14</a>
</span><span class=lnt id=hl-16-15><a class=lnlinks href=#hl-16-15>15</a>
</span><span class=lnt id=hl-16-16><a class=lnlinks href=#hl-16-16>16</a>
</span><span class=lnt id=hl-16-17><a class=lnlinks href=#hl-16-17>17</a>
</span><span class=lnt id=hl-16-18><a class=lnlinks href=#hl-16-18>18</a>
</span><span class=lnt id=hl-16-19><a class=lnlinks href=#hl-16-19>19</a>
</span><span class=lnt id=hl-16-20><a class=lnlinks href=#hl-16-20>20</a>
</span><span class=lnt id=hl-16-21><a class=lnlinks href=#hl-16-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>graph TB
</span></span><span class=line><span class=cl>    subgraph 手机
</span></span><span class=line><span class=cl>        App[App]
</span></span><span class=line><span class=cl>    end
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    subgraph 公网
</span></span><span class=line><span class=cl>        Server[Server]
</span></span><span class=line><span class=cl>    end
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    subgraph 开发机
</span></span><span class=line><span class=cl>        Daemon[Daemon]
</span></span><span class=line><span class=cl>        CLI1[CLI 会话 1]
</span></span><span class=line><span class=cl>        CLI2[CLI 会话 2]
</span></span><span class=line><span class=cl>    end
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    App &lt;--&gt;|&#34;user-scoped Socket&lt;br/&gt;全局状态 + RPC 调用&#34;| Server
</span></span><span class=line><span class=cl>    CLI1 &lt;--&gt;|&#34;session-scoped Socket&lt;br/&gt;会话消息 + 状态变更&#34;| Server
</span></span><span class=line><span class=cl>    CLI2 &lt;--&gt;|&#34;session-scoped Socket&#34;| Server
</span></span><span class=line><span class=cl>    Daemon &lt;--&gt;|&#34;machine-scoped Socket&lt;br/&gt;心跳 + 远程 spawn&#34;| Server
</span></span><span class=line><span class=cl>    Daemon ---|&#34;HTTP 127.0.0.1&lt;br/&gt;daemon.state.json&#34;| CLI1
</span></span><span class=line><span class=cl>    Daemon ---|&#34;HTTP 127.0.0.1&#34;| CLI2
</span></span></code></pre></td></tr></table></div></div><p>三种 Socket scope 各走各的通道：App 通过 user-scoped 看全局、发 RPC，CLI 通过 session-scoped 收发会话消息，Daemon 通过 machine-scoped 维持心跳和接收远程 spawn 指令。CLI 和 Daemon 之间通过本地 HTTP 解耦。</p><hr><h2 id=6-架构师视角从零设计会怎样>6. 架构师视角：从零设计会怎样<a hidden class=anchor aria-hidden=true href=#6-架构师视角从零设计会怎样>#</a></h2><h3 id=61-三组件方案>6.1 三组件方案<a hidden class=anchor aria-hidden=true href=#61-三组件方案>#</a></h3><p>如果只针对 Kimi CLI（单一 Provider），四组件可以缩减为三个：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2>2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3>3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4>4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Client（iOS / Web）
</span></span><span class=line><span class=cl>    ↕ WSS + E2EE
</span></span><span class=line><span class=cl>Relay Server（路由 + 认证 + 存储）
</span></span><span class=line><span class=cl>    ↕ WSS + E2EE
</span></span><span class=line><span class=cl>Agent（开发机常驻 = Daemon + Provider Wrapper）
</span></span></code></pre></td></tr></table></div></div><p>把 CLI 和 Daemon 合并成一个二进制：</p><ul><li><code>kimi-remote agent start</code> → 常驻进程（Daemon 角色）</li><li><code>kimi-remote agent attach</code> → 终端 attach 到某个会话（CLI 角色）</li></ul><p>Happy 拆出独立 CLI 是因为要统一封装 Claude Code、Codex、Gemini 三种 Provider，每种输出格式不同，需要映射层转成统一的 9 种事件。Kimi CLI 只有一个 Provider，这层封装可以内嵌。</p><h3 id=62-不可省略的部分>6.2 不可省略的部分<a hidden class=anchor aria-hidden=true href=#62-不可省略的部分>#</a></h3><p>无论怎么简化：</p><ul><li><strong>Server 不可省</strong>。它解决的是物理约束：NAT 穿透和多端一致性。只要手机和开发机不在同一网络，就需要一个双方都能访问的中继。</li><li><strong>Daemon 不可省</strong>。它解决的是进程约束：会话生命周期独立于前端。只要「关掉终端后 Agent 继续跑」是需求，就需要常驻进程。</li></ul><p>组件数量是约束数量的函数。放宽约束可以减少组件：</p><table><thead><tr><th>放宽的约束</th><th>可省略</th><th>代价</th></tr></thead><tbody><tr><td>不需要跨网</td><td>Server</td><td>失去公网可达</td></tr><tr><td>不需要本地终端交互</td><td>CLI（合并到 Agent）</td><td>回到电脑时无法在终端继续</td></tr><tr><td>只有一个 Provider</td><td>Provider 封装层</td><td>不影响功能</td></tr><tr><td>Server 自己部署</td><td>E2EE</td><td>安全性自己负责</td></tr></tbody></table><h3 id=63-约束推导方法五维度扫描>6.3 约束推导方法：五维度扫描<a hidden class=anchor aria-hidden=true href=#63-约束推导方法五维度扫描>#</a></h3><p>上面的约束列表是怎么推导出来的？不是靠经验枚举，而是靠一个固定的扫描清单。</p><p>面对任何远程操控场景，画出最简架构（两个节点之间一条线），然后按五个维度依次提问：</p><table><thead><tr><th>维度</th><th>问的问题</th><th>答案为「是」时产生的约束</th></tr></thead><tbody><tr><td>网络</td><td>A 能直接找到 B 吗？</td><td>跨网可达</td></tr><tr><td>一致性</td><td>多个观察者看到的状态一样吗？</td><td>多端状态一致</td></tr><tr><td>并发</td><td>多个操作者同时动手会冲突吗？</td><td>控制权互斥</td></tr><tr><td>生命周期</td><td>UI 挂了，后台任务也死吗？</td><td>会话独立于前端</td></tr><tr><td>交互模式</td><td>所有用户用同一种界面吗？</td><td>CLI / Daemon 分离</td></tr></tbody></table><p>这五个维度的顺序对应从物理层到应用层的分层——和 OSI 模型的思路一样，先解决低层问题，再考虑高层。每个维度用同一个问题检验：<strong>不处理的话，能构造出什么灾难场景？</strong> 能构造出来 → 硬约束，必须解决。构造不出来 → 软偏好，可以延后。</p><p>以「控制权互斥」为例：多端连上后，能不能不做互斥，让用户先后操控？可以，lease 机制本质上就是在实现「先后操控」。但问题是<strong>谁来保证先后</strong>——如果没有 Server 维护 lease，两个客户端都认为自己是当前控制者，同时发 prompt，Agent 收到矛盾指令。约束不是「要不要互斥」，而是「谁来仲裁」。</p><p>这个方法的原型是航空业的起飞前检查清单。1935 年，波音 Model 299（B-17 轰炸机原型）试飞坠毁，原因是首席试飞员忘记释放升降舵锁——飞机太复杂，超出了一个人的记忆力极限。波音的应对不是简化飞机，而是发明了一张清单：从燃油到襟翼到升降舵到仪表，逐层检查。五维度扫描法和它解决的是同一个问题：不是给新手用的拐杖，是给专家用的认知外骨骼。B-17 的试飞员是波音首席试飞员，不是菜鸟。</p><p>日常版本：旅行前拍脑袋收拾行李，你会带三件外套却忘充电器。衣服是「看得见的维度」，充电器是「用到才想起的维度」。架构设计中「WebSocket 能不能连上」是衣服，「关掉终端后会话还在不在」是充电器。</p><h3 id=延伸练习>延伸练习<a hidden class=anchor aria-hidden=true href=#延伸练习>#</a></h3><p>把这个方法用在一个新场景上：<strong>设计一个「手机远程操控家里电脑 Docker 容器」的系统</strong>——手机上启动/停止容器、查看日志、执行命令。</p><ol><li>画出最简架构</li><li>按五个维度扫描，每个维度构造一个灾难场景</li><li>对每个灾难场景决定加什么组件</li><li>和 Happy 的四组件对比：哪些一样？哪些不需要？为什么？</li></ol><p>关键不是答案对不对，而是每个维度能不能写出具体场景。写不出来的维度，恰好说明那个约束在这个场景下不存在——这本身就是一个有价值的结论。</p><hr><h2 id=7-wire-协议能复用吗分层拆解>7. Wire 协议能复用吗：分层拆解<a hidden class=anchor aria-hidden=true href=#7-wire-协议能复用吗分层拆解>#</a></h2><p>一个自然的问题：Kimi CLI 的 Web UI 已经有了 Wire 协议（JSON-RPC 2.0）和 BroadcastQueue，远程方案能直接复用吗？还是推翻重来设计一套新协议？</p><p>答案不是「能」或「不能」，而是<strong>按层看</strong>。</p><h3 id=71-三层拆解>7.1 三层拆解<a hidden class=anchor aria-hidden=true href=#71-三层拆解>#</a></h3><p>把 Wire 协议拆成三层，逐层评估：</p><table><thead><tr><th>层</th><th>包含什么</th><th>能复用吗</th><th>理由</th></tr></thead><tbody><tr><td>应用语义层</td><td>17 种事件类型 + 2 种请求类型 + WireMessageEnvelope 格式</td><td>✅ 100% 复用</td><td>消息的含义不因传输方式改变</td></tr><tr><td>会话管理层</td><td>客户端身份、消息排序、请求匹配、控制权、心跳</td><td>❌ 需要新增</td><td>本地方案没有这一层</td></tr><tr><td>传输层</td><td>stdio 管道、localhost WebSocket</td><td>⚠️ 替换</td><td>从本地换成公网 WSS + 中继</td></tr></tbody></table><p>关键发现：Wire 协议目前<strong>只有两层</strong>（应用语义 + 传输），中间的会话管理层是空的。这不是设计缺陷——本地场景不需要。但远程场景必须补上。</p><h3 id=72-应用语义层直接搬>7.2 应用语义层：直接搬<a hidden class=anchor aria-hidden=true href=#72-应用语义层直接搬>#</a></h3><p>Wire 定义的事件类型是纯业务语义，不绑定传输假设：<code>TurnBegin</code>/<code>TurnEnd</code> 标记对话边界，<code>ContentPart</code> 承载流式输出，<code>ToolCall</code>/<code>ToolResult</code> 处理工具调用，<code>ApprovalRequest</code> 请求用户批准。这些消息的格式和含义，无论走 stdio、localhost WebSocket 还是公网 WSS 中继，都不需要改。</p><p>BroadcastQueue 的 SPMC 模式也可以复用——Server 中继收到 Agent 的消息后，用同样的「一个生产者、多个消费者」模式广播给同一个 session 的所有订阅者。</p><h3 id=73-会话管理层必须新增>7.3 会话管理层：必须新增<a hidden class=anchor aria-hidden=true href=#73-会话管理层必须新增>#</a></h3><p>这是最大的工作量。本地方案有三个隐含假设，远程场景下全部失效：</p><p><strong>假设 1：只有一个客户端</strong>。<code>_pending_requests</code> 是全局字典，没有客户端隔离：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1>1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># wire/server.py — 当前</span>
</span></span><span class=line><span class=cl><span class=bp>self</span><span class=o>.</span><span class=n>_pending_requests</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Request</span><span class=p>]</span> <span class=o>=</span> <span class=p>{}</span>
</span></span></code></pre></td></tr></table></div></div><p>远程场景需要按 session 隔离，并且同一个 <code>ApprovalRequest</code> 只能由当前 controller 响应，不能所有客户端都能回复。</p><p><strong>假设 2：消息天然有序</strong>。stdio 是单流，消息到达顺序就是发送顺序。公网 WebSocket 经过中继后，可能乱序到达。需要在每条消息上加 seq：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1>1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 远程方案需要</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=s2>&#34;seq&#34;</span><span class=p>:</span> <span class=mi>42</span><span class=p>,</span> <span class=s2>&#34;session_id&#34;</span><span class=p>:</span> <span class=s2>&#34;abc&#34;</span><span class=p>,</span> <span class=s2>&#34;message&#34;</span><span class=p>:</span> <span class=p>{</span><span class=o>...</span><span class=p>}}</span>
</span></span></code></pre></td></tr></table></div></div><p>Happy 的 <code>CoreUpdateContainer</code> 正是这样做的——每条 update 带 <code>id</code>（用于去重）和 <code>seq</code>（用于排序）。</p><p><strong>假设 3：连接不会断</strong>。stdio 管道在进程活着时永远不断。公网连接随时可能断，需要心跳检测和断线重连后的状态同步。Wire 文件格式（JSONL）本身可以作为重连后的回放源——这部分 Kimi CLI 的 <code>_replay_buffers</code> 机制可以直接复用。</p><h3 id=74-传输层整体替换>7.4 传输层：整体替换<a hidden class=anchor aria-hidden=true href=#74-传输层整体替换>#</a></h3><p>从 stdio 管道换成 WSS + 中继 Server，这是基础设施变更。另外 <code>asyncio.Future</code>（用于本地等待请求响应）不能跨网络传递，需要替换为带超时的回调机制——Happy 的 <code>emitWithAck</code> + 30 秒超时就是一种实现。</p><h3 id=75-结论六成复用四成新增>7.5 结论：六成复用，四成新增<a hidden class=anchor aria-hidden=true href=#75-结论六成复用四成新增>#</a></h3><table><thead><tr><th>工作项</th><th>工作量</th><th>复用率</th></tr></thead><tbody><tr><td>消息类型定义（17 + 2）</td><td>零</td><td>100%</td></tr><tr><td>序列化格式（JSON-RPC 2.0）</td><td>零</td><td>100%</td></tr><tr><td>BroadcastQueue / 回放机制</td><td>小</td><td>80%</td></tr><tr><td>会话管理（身份 / 排序 / 心跳）</td><td>大</td><td>0%（新增）</td></tr><tr><td>控制权租约</td><td>中</td><td>0%（新增）</td></tr><tr><td>传输层替换（stdio → WSS）</td><td>中</td><td>0%（替换）</td></tr></tbody></table><p>不需要推翻重来，也不能原样照搬。应用语义层完整复用，会话管理层从零新增，传输层整体替换。</p><h3 id=76-分层复用的-mindset>7.6 分层复用的 mindset<a hidden class=anchor aria-hidden=true href=#76-分层复用的-mindset>#</a></h3><p>上面的分析用的思维方式是：<strong>按层拆解，逐层判断</strong>。面对「现有系统迁移到新环境」，不陷入「推翻重来」和「原样复用」的二元争论，而是拆成层，每一层独立评估。</p><p>这个方法有一个跨越 150 年的同构案例：明治维新。不是全盘西化，也不是完全拒绝。伊藤博文按层拆解：军事技术层→全面引进西方模式（传输层替换）；行政制度层→选择性改造，学普鲁士而非英法，因为普鲁士的君主立宪更兼容天皇制（会话管理层重新设计）；文化认同层→保留天皇制和神道教（应用语义层复用）。同期清朝洋务运动的失败恰恰是层次判断错误：只换了传输层（买军舰），没动会话管理层（制度），甲午战争被「分层正确」的日本击败。</p><p>日常版本：你换了城市工作。衣服直接搬过去——它们不绑定城市。健身房重新办卡——会员绑定了旧的地理位置，原样照搬毫无意义。朋友关系继续维护，但方式从线下聚餐扩展为线上联系——复用关系本身，替换承载关系的渠道。你不会因为换了城市就换掉所有朋友，也不会继续用旧城市的健身房卡。把这个直觉显式化，就是分层复用分析法。</p><hr><h2 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h2><p>回到开篇：手机远程操控 AI Coding CLI，为什么不是「一个 WebSocket」就能搞定？</p><p>五个约束逐层叠加，每个约束淘汰一种更简单的方案：</p><ol><li><strong>NAT 穿透</strong>淘汰了直连。手机找不到 NAT 后面的开发机，必须有公网中继（Server）</li><li><strong>多端一致性</strong>淘汰了无状态 Gateway。Gateway 只转发不协调，两端看到的状态可能不一致</li><li><strong>控制权互斥</strong>要求 Server 理解协议语义。Gateway 不知道谁是控制端</li><li><strong>会话独立于前端</strong>要求常驻进程。关掉终端不能杀死 Agent（Daemon）</li><li><strong>本地 + 远程并存</strong>让 CLI 和 Daemon 无法合并。TTY 需求和 detached 后台进程的模型冲突</li></ol><p>Happy 的四组件恰好对应这五个约束。如果场景更简单（单 Provider、不需要本地终端交互），可以缩减到三组件。但 Server 和 Daemon 无论如何不可省，它们解决的是物理约束，不是设计偏好。</p><p><strong>判断自己需要几个组件</strong>：</p><ul><li>手机和开发机在同一网络？是：不需要 Server</li><li>关掉终端后 Agent 要继续跑？否：不需要 Daemon</li><li>电脑端也要交互式操控？否：CLI 可并入 Daemon</li><li>支持多种 AI Provider？否：封装层可内嵌</li><li>Server 自己部署？是：可不做 E2EE</li></ul><p>每个「否」省掉一个组件。每个「是」加回来一个不可替代的齿轮。</p><p>协议层面，Kimi CLI 的 Wire 协议不需要推翻——应用语义层（消息类型和格式）100% 复用，会话管理层（身份、排序、租约）从零新增，传输层整体替换。</p><p>文章中用了三个可迁移的思维方法：</p><table><thead><tr><th>方法</th><th>核心动作</th><th>远镜类比</th><th>近镜类比</th></tr></thead><tbody><tr><td>逐步证伪法</td><td>从最简方案出发，用失败场景逼出组件</td><td>英国普通法：每条判例对应一次真实失败</td><td>搬新家：每件物品对应一个具体不便</td></tr><tr><td>五维度扫描法</td><td>按固定清单逐层检查「不处理会怎样」</td><td>B-17 坠毁催生飞行检查清单</td><td>旅行打包：显眼物品挤占注意力</td></tr><tr><td>分层复用分析法</td><td>按层拆解，逐层判断复用/扩展/新增</td><td>明治维新按层判断西化程度</td><td>换城市：衣服搬走、健身房重办、朋友维护</td></tr></tbody></table><p>三个方法对应架构设计的三个阶段：发现约束、梳理约束、迁移方案。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://miss-you.github.io/tags/ai/>AI</a></li><li><a href=https://miss-you.github.io/tags/websocket/>WebSocket</a></li><li><a href=https://miss-you.github.io/tags/%E6%9E%B6%E6%9E%84/>架构</a></li><li><a href=https://miss-you.github.io/tags/cli/>CLI</a></li><li><a href=https://miss-you.github.io/tags/kimi/>Kimi</a></li><li><a href=https://miss-you.github.io/tags/happy/>Happy</a></li><li><a href=https://miss-you.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/>架构设计</a></li></ul><nav class=paginav><a class=next href=https://miss-you.github.io/posts/20260216-swift-kimi-cli-console/><span class=title>下一页 »</span><br><span>用 300 行 Swift 让 iPhone 变成 Kimi CLI 控制台</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 on x" href="https://x.com/intent/tweet/?text=%e4%bb%8e%e4%b8%80%e4%b8%aa%20WebSocket%20%e5%88%b0%e5%9b%9b%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9a%e5%a4%9a%e7%ab%af%e6%93%8d%e6%8e%a7%20AI%20Coding%20CLI%20%e7%9a%84%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8c%96&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f&amp;hashtags=AI%2cWebSocket%2c%e6%9e%b6%e6%9e%84%2cCLI%2cKimi%2cHappy%2c%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f&amp;title=%e4%bb%8e%e4%b8%80%e4%b8%aa%20WebSocket%20%e5%88%b0%e5%9b%9b%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9a%e5%a4%9a%e7%ab%af%e6%93%8d%e6%8e%a7%20AI%20Coding%20CLI%20%e7%9a%84%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8c%96&amp;summary=%e4%bb%8e%e4%b8%80%e4%b8%aa%20WebSocket%20%e5%88%b0%e5%9b%9b%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9a%e5%a4%9a%e7%ab%af%e6%93%8d%e6%8e%a7%20AI%20Coding%20CLI%20%e7%9a%84%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8c%96&amp;source=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f&title=%e4%bb%8e%e4%b8%80%e4%b8%aa%20WebSocket%20%e5%88%b0%e5%9b%9b%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9a%e5%a4%9a%e7%ab%af%e6%93%8d%e6%8e%a7%20AI%20Coding%20CLI%20%e7%9a%84%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8c%96"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 on whatsapp" href="https://api.whatsapp.com/send?text=%e4%bb%8e%e4%b8%80%e4%b8%aa%20WebSocket%20%e5%88%b0%e5%9b%9b%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9a%e5%a4%9a%e7%ab%af%e6%93%8d%e6%8e%a7%20AI%20Coding%20CLI%20%e7%9a%84%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8c%96%20-%20https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 on telegram" href="https://telegram.me/share/url?text=%e4%bb%8e%e4%b8%80%e4%b8%aa%20WebSocket%20%e5%88%b0%e5%9b%9b%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9a%e5%a4%9a%e7%ab%af%e6%93%8d%e6%8e%a7%20AI%20Coding%20CLI%20%e7%9a%84%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8c%96&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从一个 WebSocket 到四个组件：多端操控 AI Coding CLI 的架构演化 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e4%bb%8e%e4%b8%80%e4%b8%aa%20WebSocket%20%e5%88%b0%e5%9b%9b%e4%b8%aa%e7%bb%84%e4%bb%b6%ef%bc%9a%e5%a4%9a%e7%ab%af%e6%93%8d%e6%8e%a7%20AI%20Coding%20CLI%20%e7%9a%84%e6%9e%b6%e6%9e%84%e6%bc%94%e5%8c%96&u=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260217-websocket-to-four-components%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://miss-you.github.io/>Yousa Driven Development | YDD</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>