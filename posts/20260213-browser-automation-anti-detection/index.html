<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战 | Yousa Driven Development | YDD</title><meta name=keywords content="浏览器自动化,CDP,反检测,Patchright,小红书,Python"><meta name=description content="国内内容平台没有开放API，浏览器自动化是唯一出路。但平台风控会检测自动化痕迹。本文记录了一次完整的反检测实战：从 Playwright 被封到 Patchright + CDP 模式的调试全过程，踩过 7 个具体的坑，提炼出可复用的原则。"><meta name=author content="Miss-you"><link rel=canonical href=https://miss-you.github.io/posts/20260213-browser-automation-anti-detection/><link crossorigin=anonymous href=/assets/css/stylesheet.90ccfe940c2ebacfe29cf6c094281c8c148bd718511cde00be68d330109118be.css integrity="sha256-kMz+lAwuus/inPbAlCgcjBSL1xhRHN4AvmjTMBCRGL4=" rel="preload stylesheet" as=style><link rel=icon href=https://miss-you.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://miss-you.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://miss-you.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://miss-you.github.io/apple-touch-icon.png><link rel=mask-icon href=https://miss-you.github.io/safari-pinned-tab.svg><meta name=theme-color content="#f4f3ee"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://miss-you.github.io/posts/20260213-browser-automation-anti-detection/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Noto+Serif+SC:wght@400;600;700;900&family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel=stylesheet><meta property="og:url" content="https://miss-you.github.io/posts/20260213-browser-automation-anti-detection/"><meta property="og:site_name" content="Yousa Driven Development | YDD"><meta property="og:title" content="当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战"><meta property="og:description" content="国内内容平台没有开放API，浏览器自动化是唯一出路。但平台风控会检测自动化痕迹。本文记录了一次完整的反检测实战：从 Playwright 被封到 Patchright + CDP 模式的调试全过程，踩过 7 个具体的坑，提炼出可复用的原则。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-13T10:00:00+08:00"><meta property="article:modified_time" content="2026-02-14T13:58:57+08:00"><meta property="article:tag" content="浏览器自动化"><meta property="article:tag" content="CDP"><meta property="article:tag" content="反检测"><meta property="article:tag" content="Patchright"><meta property="article:tag" content="小红书"><meta property="article:tag" content="Python"><meta name=twitter:card content="summary"><meta name=twitter:title content="当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战"><meta name=twitter:description content="国内内容平台没有开放API，浏览器自动化是唯一出路。但平台风控会检测自动化痕迹。本文记录了一次完整的反检测实战：从 Playwright 被封到 Patchright + CDP 模式的调试全过程，踩过 7 个具体的坑，提炼出可复用的原则。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://miss-you.github.io/posts/"},{"@type":"ListItem","position":2,"name":"当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战","item":"https://miss-you.github.io/posts/20260213-browser-automation-anti-detection/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战","name":"当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战","description":"国内内容平台没有开放API，浏览器自动化是唯一出路。但平台风控会检测自动化痕迹。本文记录了一次完整的反检测实战：从 Playwright 被封到 Patchright + CDP 模式的调试全过程，踩过 7 个具体的坑，提炼出可复用的原则。","keywords":["浏览器自动化","CDP","反检测","Patchright","小红书","Python"],"articleBody":"当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战 事情的起因很简单。我需要一个工具，自动把内容发布到小红书。\n打开创作者中心，上传几张图，填标题，写正文，加话题标签，点发布。一篇两篇没问题，但每天要发几十篇的话，纯体力劳动。\n自然想到浏览器自动化。写个脚本，模拟人在浏览器里的操作。\n但我低估了难度。Playwright 的 API 很好用，模拟点击、填写、上传都有现成的方法，编码不难。难的是小红书的风控系统会识别出你在用自动化工具，然后封你。\n下面是从被风控到稳定运行的调试记录，踩了 7 个坑。\n为什么得用浏览器自动化 国内的内容平台，小红书、抖音、公众号，都不提供公开的发布 API。\n海外不一样。Twitter、YouTube、Medium 都有 API，HTTP 请求直接发内容。国内平台对内容管控更严格，API 只给少数合作伙伴，普通开发者拿不到。\n所以你想自动化发内容，只剩一条路。用代码打开浏览器，模拟人的操作。\n主流工具有 Selenium、Playwright、Puppeteer，干的事情一样。启动一个浏览器实例，通过协议控制它。\n但平台也不傻。\n传统方案怎么被检测的 用 Playwright 的 launch() 启动浏览器，这个浏览器从出生那一刻就带着「自动化」的印记。风控脚本查几个点就够了。\n最直接的是 navigator.webdriver。正常浏览器里这个值是 undefined，但 Selenium 和 Playwright 启动的浏览器是 true。一行 JS 就能判断。\n1 2 3 if (navigator.webdriver) { // 自动化工具，触发风控 } 然后是浏览器指纹。UA 字符串可能带 HeadlessChrome，WebGL 渲染结果不同，Canvas 指纹不同，屏幕分辨率是固定的默认值。单个差异不起眼，组合起来就是明确的信号。\n还有操作节奏。机器操作太整齐了，每次点击间隔恰好 500ms，输入速度完全一致。真人会犹豫，会停顿，快慢不一。\n最后是「生活痕迹」。自动化启动的浏览器是全新实例。没有浏览历史，没有书签，没有扩展，没有其他网站的 cookies。像一个刚出厂的手机。\n风控不需要多精密。它只问一个问题：这个浏览器环境真实吗？\n不真实就触发验证码、限制发布、标记异常。\n小红书自动发笔记 先说我要做的事。\n写一个 Python 脚本。打开小红书创作者中心，登录，上传图片，填标题正文，加话题标签，点发布。\n用 Playwright 写这个流程不难。page.click()、page.fill()、page.set_input_files() 都能直接用。\n第一次跑，成功了。\n第二次，还是成功。\n第三次，弹了个滑块验证码。手动过了，继续。\n第四次，直接提示「操作频繁，请稍后再试」。\n第五次，账号被标记异常，要手机验证。\n典型的风控升级。平台不会一上来就封你，逐步加码，先软后硬。\n到这一步，launch() 模式走不通了。得换思路。\nCDP 模式：连接真实浏览器 这是整篇文章的核心。不是前端开发者的话可能对 CDP 不熟，我尽量讲清楚。\n什么是 CDP CDP 全称 Chrome DevTools Protocol。\n你在 Chrome 里按 F12 打开的开发者工具，Elements 面板、Console 面板、Network 面板，它们和浏览器本体之间走的就是这个协议。\n具体来说，CDP 是一套 JSON 格式的消息，通过 WebSocket 传输。浏览器暴露一个 WebSocket 端口，外部程序通过这个端口发指令、收事件。\n「帮我导航到这个 URL」→ Page.navigate 「帮我执行这段 JS」→ Runtime.evaluate 「页面加载完了没」→ Page.loadEventFired Playwright 和 Puppeteer 就是 CDP 的高级封装。把底层 JSON 消息包成好用的 API。\nlaunch() vs connect_over_cdp() Playwright 有两种模式。这两种模式的区别是解决反检测的关键。\nlaunch()：Playwright 自己启动一个全新的 Chromium 实例，整个生命周期都由它控制。问题是这个浏览器从出生就带自动化标记。--enable-automation 启动参数，navigator.webdriver 设成 true，实例全新，没有用户数据。\nconnect_over_cdp()：不启动新浏览器，连接到一个已经在运行的 Chrome。可以是你日常用的浏览器，有书签、扩展、浏览历史、登录过的各种网站。Playwright 通过 CDP 协议「接管」控制权。\n一个是造机器人去冒充人类。另一个是给真人装一只遥控的手。\n为什么 CDP 模式更难被检测 因为连接的就是用户的真实浏览器。\n指纹完全真实。UA、WebGL、Canvas、屏幕分辨率都是真实设备的数据 没有 --enable-automation 启动参数 有真实的浏览历史、扩展、书签 网络栈完全真实。DNS 解析、TLS 握手、证书链验证都是 Chrome 原生行为 风控看这个浏览器，每个维度都是「真的」。因为它确实是真的。\nPatchright：在 CDP 层做额外修补 用了 CDP 模式还有几个细微的检测点。Playwright 连接 CDP 时会发一些特定的协议命令，留下可被检测的痕迹。\nPatchright 是 Playwright 的 fork，专门解决这个。修补了三个检测点。\nRuntime.enable leak：Playwright 连接后会发 Runtime.enable 命令监听 JS 运行时事件。某些反检测脚本能检测这个命令是否被调用过。Patchright 移除了这个行为。\nConsole.enable leak：Playwright 会启用 Console 域来捕获 console.log 输出。也是检测信号。Patchright 同样移除了。\nnavigator.webdriver：Patchright 通过 --disable-blink-features=AutomationControlled 启动参数禁用自动化标记。在 CDP 模式下，连接的是用户自己启动的 Chrome，本身就没有 --enable-automation，这个属性天然是正常值。\n前两个修补在 CDP 协议通信层完成，不注入任何 JavaScript。JS 注入本身也能被检测到（通过检查属性描述符、原型链等），协议层的修补对页面内的 JS 完全透明。\n理论讲完了。下面是实战。\n7 个坑 理论上方案很清晰。启动 Chrome 加调试端口，用 Patchright 连上去，写自动化脚本。实际操作中每一步都可能出问题。\n以下 7 个坑按遇到的时间顺序排列。大部分是 AI 在「探索 → 生成代码 → 验证」的循环里自己发现的，我作为验收员确认方案可行性，同时学习风控相关的背景知识。\n坑 1：Chrome 拒绝在默认 Profile 上开 CDP 端口 现象\n启动 Chrome 开远程调试端口。\n1 2 /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome \\ --remote-debugging-port=9222 终端直接报错。\n1 DevTools remote debugging requires a non-default data directory. Chrome 启动了，但调试端口没生效。\n原因\nChrome 136 开始不允许在默认用户数据目录「~/Library/Application Support/Google/Chrome」上启用远程调试端口。安全考虑。如果恶意软件偷偷给你的 Chrome 开了调试端口，它就能通过 CDP 读你所有的 cookies、密码、浏览历史。\n解决\n创建一个专用 Profile 目录。\n1 2 3 4 5 6 7 mkdir -p ~/.config/rednote-toolkit/chrome-cdp-profile /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome \\ --remote-debugging-port=9222 \\ --user-data-dir=\"$HOME/.config/rednote-toolkit/chrome-cdp-profile\" \\ --no-first-run \\ --no-default-browser-check --user-data-dir 指向非默认目录，Chrome 就允许开调试端口了。代价是新 Profile 没有原来的 cookies，不过后面可以通过代码注入。\n坑 2：Chrome 实例合并导致调试端口不生效 现象\n按坑 1 的方案启动 Chrome，没报错。ps aux | grep Chrome 也能看到进程带着 --remote-debugging-port=9222 参数。但是\n1 2 lsof -i :9222 # 没有输出，端口没被监听 Patchright 连接失败。\n原因\nChrome 在 macOS 上是单实例应用。系统上已经有一个 Chrome 在运行的话（哪怕只是后台残留进程），新的启动命令不会真的创建新进程。它把窗口请求「合并」到已有进程里，--remote-debugging-port=9222 参数直接被扔掉了。\n这个坑最容易忽略。macOS 上关闭所有窗口不等于退出应用。你觉得 Chrome 关了，其实它还在 Dock 栏挂着。\n解决\n启动前确保 Chrome 完全退出。\n1 2 3 4 5 6 7 8 9 10 # Cmd+Q 退出 Chrome，或者命令行杀进程 pkill -f \"Google Chrome\" sleep 2 # 然后再启动 /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome \\ --remote-debugging-port=9222 \\ --user-data-dir=\"$HOME/.config/rednote-toolkit/chrome-cdp-profile\" \\ --no-first-run \\ --no-default-browser-check 脚本里我加了检测逻辑。启动后用 lsof 确认端口在监听，不在的话提示用户先退出 Chrome。\n坑 3：Patchright 的 HTTP 发现机制返回 400 现象\nChrome 启动了，端口也确认在监听。用 Patchright 连接。\n1 browser = await pw.chromium.connect_over_cdp(\"http://localhost:9222\") 报错 Unexpected status 400。\n但 curl 请求完全正常。\n1 2 curl http://localhost:9222/json/version # 返回正常 JSON，包含 webSocketDebuggerUrl 原因\nPatchright 内部做 HTTP 发现时，请求路径是 /json/version/，注意尾部多了一个斜杠。Chrome 144 对带尾部斜杠的 URL 返回 400。不带斜杠的 /json/version 正常返回 200。\nPatchright 1.58 + Chrome 144 的兼容性问题。\n解决\n绕过 Patchright 的 HTTP 发现。手动请求 Chrome 的发现端点，提取 WebSocket URL，直连。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import http.client import json from urllib.parse import urlparse def resolve_cdp_ws_url(endpoint: str) -\u003e str: \"\"\"将 HTTP 端点解析为 WebSocket URL\"\"\" if endpoint.startswith(\"ws://\") or endpoint.startswith(\"wss://\"): return endpoint try: parsed = urlparse(endpoint) host = parsed.hostname or \"127.0.0.1\" port = parsed.port or 9222 conn = http.client.HTTPConnection(host, port, timeout=5) conn.request(\"GET\", \"/json/version\") # 没有尾部斜杠 resp = conn.getresponse() if resp.status == 200: data = json.loads(resp.read()) ws_url = data.get(\"webSocketDebuggerUrl\") if ws_url: conn.close() return ws_url conn.close() except Exception: pass return endpoint # 使用 ws_url = resolve_cdp_ws_url(\"http://localhost:9222\") browser = await pw.chromium.connect_over_cdp(ws_url) 用 http.client 请求 /json/version，从 JSON 里取出 webSocketDebuggerUrl（形如 ws://127.0.0.1:9222/devtools/browser/xxx），传给 connect_over_cdp()。\n坑 4：urllib.request 请求 localhost 返回 502 现象\n写坑 3 的解决方案时，我最初用 urllib.request.urlopen() 请求 /json/version。\n1 2 3 import urllib.request resp = urllib.request.urlopen(\"http://localhost:9222/json/version\") # urllib.error.HTTPError: HTTP Error 502: Bad Gateway 502？Bad Gateway？localhost 又没有网关。\n同一时间 curl 正常，http.client 也正常。单独 urllib 不行。\n原因\n我 Mac 上装了 ClashX，开了系统代理。\nurllib.request 会读系统代理设置。发现系统配了 HTTP 代理，就把所有请求（包括 localhost）转发给代理服务器。代理收到指向 localhost:9222 的请求，连的是代理服务器自己的 localhost。那上面当然没有 Chrome 在 9222 端口监听，所以 502。\nhttp.client.HTTPConnection 是底层 HTTP 客户端，不读系统代理，直接建 TCP 连接。curl 默认也不走系统代理。\n解决\n用 http.client 代替 urllib.request。\n1 2 3 4 5 6 7 8 9 10 # 不要用这个 # urllib.request.urlopen(\"http://localhost:9222/json/version\") # 用这个 import http.client conn = http.client.HTTPConnection(\"127.0.0.1\", 9222, timeout=5) conn.request(\"GET\", \"/json/version\") resp = conn.getresponse() data = resp.read() conn.close() 后来我养成了习惯。在 macOS 上调试 localhost 通信，同一个 URL 用 curl 能通但 Python 不通，先查代理。\n坑 5：CDP 模式下 new_context() 导致 ERR_CONNECTION_CLOSED 现象\n连上 Chrome 后，按 Playwright 的常规用法创建新的 BrowserContext。\n1 2 3 4 browser = await pw.chromium.connect_over_cdp(ws_url) context = await browser.new_context() page = await context.new_page() await page.goto(\"https://creator.xiaohongshu.com\") 所有 HTTPS 请求失败，控制台全是 ERR_CONNECTION_CLOSED。页面空白。\n但不创建新 context，直接用 Chrome 已有的。\n1 2 3 4 browser = await pw.chromium.connect_over_cdp(ws_url) context = browser.contexts[0] # Chrome 已有的默认 context page = await context.new_page() await page.goto(\"https://creator.xiaohongshu.com\") 一切正常。\n原因\n这里有个认知误区。\nlaunch() 模式下 Playwright 完全控制浏览器生命周期，new_context() 创建的 BrowserContext 有完整的网络栈配置。CDP 模式下不是这样。new_context() 创建的是一个隔离的 context，有独立的网络栈。\n问题出在「独立的网络栈」。新 context 缺少 Chrome 原始 context 的 DNS 配置、TLS 会话缓存、证书验证策略。HTTPS 连接建不起来。\n说白了，CDP 连接不等于完全透明地操控用户浏览器。new_context() 会引入隔离层，而这个隔离层缺关键的网络配置。\n解决\n不建新 context。用 Chrome 已有的默认 context，通过 add_cookies() 注入 cookies。\n1 2 3 4 5 6 7 8 9 10 11 12 13 import json browser = await pw.chromium.connect_over_cdp(ws_url) ctx = browser.contexts[0] # 使用已有 context # 注入 cookies storage_state_path = \"storage_state.json\" with open(storage_state_path) as f: state = json.load(f) await ctx.add_cookies(state[\"cookies\"]) page = await ctx.new_page() await page.goto(\"https://creator.xiaohongshu.com\") 好处是 DNS、TLS、代理设置全部继承自 Chrome 原始配置。缺点是不能用 BrowserContext 隔离多个会话。需要多账号的话，得启动多个 Chrome 实例。\n坑 6：CDP 模式下 add_init_script() 导致 ERR_CONNECTION_CLOSED 现象\n为了双重保险，我加了一行 JS 注入覆盖 navigator.webdriver。\n1 2 3 4 5 6 ctx = browser.contexts[0] await ctx.add_init_script(\"\"\" Object.defineProperty(navigator, 'webdriver', { get: () =\u003e undefined }); \"\"\") page = await ctx.new_page() await page.goto(\"https://creator.xiaohongshu.com\") 又是 ERR_CONNECTION_CLOSED。和坑 5 一模一样。\n去掉 add_init_script() 那一行，恢复正常。\n原因\n这是整个调试过程中最难定位的 bug。\nadd_init_script() 不报任何错误。静静地执行，返回成功。但它改了 context 的页面初始化流程。CDP 模式下，对已有 context 调用这个方法会和 Chrome 原始初始化流程冲突，后续新页面的网络栈被悄悄破坏了。\n具体来说，add_init_script() 通过 CDP 的 Page.addScriptToEvaluateOnNewDocument 命令实现。launch() 模式下 Playwright 完全控制这个流程，没问题。CDP 模式连接到已有 context，这个命令可能和 Chrome 自身的初始化脚本冲突。\n解决\nCDP 模式下跳过 add_init_script()。\n1 2 3 4 5 6 7 8 if not cdp_endpoint: # 非 CDP 模式，手动覆盖 webdriver await ctx.add_init_script(\"\"\" Object.defineProperty(navigator, 'webdriver', { get: () =\u003e undefined }); \"\"\") # CDP 模式下不需要。连接的 Chrome 本身没有 --enable-automation，navigator.webdriver 天然正常 CDP 模式连接的是用户自己启动的 Chrome，没有 --enable-automation 参数，navigator.webdriver 天然正常，不需要 JS 注入去覆盖。\n定位这个 bug 的过程中，AI 尝试了多种方法，最后靠逐行注释代码做二分找到根因。先注释一半，看正不正常。正常就说明问题在被注释的那一半里。再二分，直到缩小到一行。看日志、猜测、搜 StackOverflow 都没用。\n坑 7：CDP 模式不应覆盖 User-Agent 现象\n为了进一步隐藏自动化痕迹，我传了自定义 User-Agent。\n1 2 3 4 page = await ctx.new_page() await page.set_extra_http_headers({ \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) ...\" }) 又出网络异常。有些请求正常，有些返回奇怪的错误。\n原因\nCDP 连接的是用户真实的 Chrome。这个 Chrome 有自己的 UA，而且 UA 和浏览器的其他指纹（navigator.userAgentData、Client Hints 等）一致。\n手动覆盖 UA，HTTP 请求头里的 UA 变了，但 JS 层面通过 navigator.userAgent 拿到的可能没变（或者变了但和 Client Hints 不一致）。风控一对比，HTTP 头和 JS 返回值不一致，反而更容易判定自动化。\n覆盖 UA 还可能影响 TLS 协商。某些 CDN 会根据 UA 返回不同内容。\n解决\nCDP 模式下不碰 User-Agent。\n1 2 3 4 if not cdp_endpoint: # 非 CDP 模式，用预设 UA context_options[\"user_agent\"] = CUSTOM_USER_AGENT # CDP 模式下用 Chrome 自带的 UA 既然在用真实的 Chrome，就不要画蛇添足。Chrome 自己的 UA 就是最好的 UA。\n踩完之后回头看 这 7 个坑背后有一些共通的东西。记下来，省得下次再踩。\n风控和反风控，争的是「真实性」 平台检测的核心问题就一个：这是不是真人在用真浏览器？\n所以最好的反检测不是「伪装成真的」，而是「本来就是真的」。CDP 模式连接真实 Chrome 就是这个思路。不伪装 UA，不伪装指纹，不伪装浏览历史，因为它们本来就是真的。\n操作层面也一样。脚本里每次点击、每次输入都加随机延迟。不是固定 sleep(1)，而是 sleep(random.uniform(0.5, 2.0))。节奏要像真人，有快有慢，偶尔「犹豫」一下。\n坑 7 也说明了这一点。覆盖 UA 导致指纹不一致，比不覆盖更容易被抓。过度伪装适得其反。\n浏览器比你想的复杂 我之前对浏览器的认知停留在「发 HTTP 请求、渲染 HTML」。踩了坑 5 和坑 6 才意识到不是这么回事。\n浏览器实例背后有一整套网络栈。DNS 解析器、TLS 会话管理器、证书验证链、代理配置、HTTP/2 连接池、HSTS 缓存。BrowserContext 不只是 cookies 的隔离容器，它隔离的是这整套网络栈。\nCDP 模式下 new_context() 等于创建了一套新的、不完整的网络栈。add_init_script() 改了页面初始化流程，可能和原始 context 的初始化冲突。这些副作用在 launch() 模式下不存在（Playwright 完全控制环境），CDP 模式下就暴露出来了。\n代理是隐形杀手 macOS 上 ClashX、Surge、V2Ray 这些工具设的系统代理，会影响 Python 的 urllib.request。你的代码访问 localhost 时，请求可能被莫名转发到代理服务器。\n同一个 URL 用 curl 能通但 Python 不通，先怀疑代理。\n两个选择：http.client.HTTPConnection 直连，不读系统代理。或者代码里设 os.environ[\"no_proxy\"] = \"localhost,127.0.0.1\"。我选了前者，更确定。\n「悄悄失败」的 bug 用二分法 坑 6 是典型。函数调用不报错，返回值正常，但后续网络连接被偷偷破坏了。\n这类 bug 不出现在日志里，不抛异常，不触发断点。你看到的只是结果不对，不知道哪里导致的。\n我试过看日志、猜原因、搜 StackOverflow，都没用。最后靠二分法。注释掉一半代码，跑一遍，看正不正常。正常就说明问题在被注释的那一半。再二分。每次只改一个变量。慢，但保证能找到。\n版本兼容性别想当然 坑 1 是 Chrome 136 的安全策略变更。坑 3 是 Patchright 1.58 + Chrome 144 的 HTTP 发现不兼容。这些工具的行为和文档描述的（或者你以为的）不一样。\nChrome 平均 4 周发一个大版本，每个版本都可能改行为。Patchright 作为 Playwright 的 fork，更新节奏不一定跟得上。\n官方方法不工作时别死磕。看版本号，搜 Changelog。兼容性问题要么降版本，要么绕过去。坑 3 我选了绕。Patchright 的 HTTP 发现不好使？自己写一个。手动用 http.client 请求 /json/version，拿到 WebSocket URL 直连。多了十几行代码，问题解决。\n最终代码 把所有解决方案组合起来，核心连接逻辑大致长这样。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import http.client import json from urllib.parse import urlparse from patchright.async_api import async_playwright def resolve_cdp_ws_url(endpoint: str) -\u003e str: \"\"\"手动解析 CDP WebSocket URL，绕过 Patchright 的 HTTP 发现 bug\"\"\" if endpoint.startswith(\"ws://\") or endpoint.startswith(\"wss://\"): return endpoint try: parsed = urlparse(endpoint) host = parsed.hostname or \"127.0.0.1\" port = parsed.port or 9222 conn = http.client.HTTPConnection(host, port, timeout=5) conn.request(\"GET\", \"/json/version\") resp = conn.getresponse() if resp.status == 200: data = json.loads(resp.read()) ws_url = data.get(\"webSocketDebuggerUrl\") if ws_url: conn.close() return ws_url conn.close() except Exception: pass return endpoint async def create_browser_context(cdp_endpoint: str = None): pw = await async_playwright().start() if cdp_endpoint: # CDP 模式：连接已有的 Chrome ws_url = resolve_cdp_ws_url(cdp_endpoint) browser = await pw.chromium.connect_over_cdp(ws_url) ctx = browser.contexts[0] # 用已有 context，不要 new_context() # 注入 cookies，不用 add_init_script storage_state_path = \"storage_state.json\" try: with open(storage_state_path) as f: state = json.load(f) await ctx.add_cookies(state[\"cookies\"]) except FileNotFoundError: pass # 首次运行没有保存的状态 # CDP 模式不覆盖 UA，不注入 init script else: # 非 CDP 模式：Patchright 自己启动浏览器 browser = await pw.chromium.launch(headless=False) ctx = await browser.new_context( user_agent=\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) ...\", ) # 非 CDP 模式可以安全使用 add_init_script await ctx.add_init_script(\"\"\" Object.defineProperty(navigator, 'webdriver', { get: () =\u003e undefined }); \"\"\") return browser, ctx, pw 写在最后 整个调试过程前后花了大概 2-3 个小时。\n工作模式是这样的：我把需求描述给 AI，AI 在「探索 → 生成代码 → 验证」的循环里自主推进。它去尝试各种方案，遇到报错就分析原因，生成修复代码，再验证。我主要负责三方面：一是作为验收员，确认 AI 提出的方案是否合理；二是学习风控和反风控的背景知识，理解平台检测的原理；三是作为测试员，在关键环节做人工验证，比如登录账号看是否触发风控。\n大部分问题 AI 自己能闭环解决。比如 Patchright 的 HTTP 发现机制返回 400，它自己查到是 URL 尾部斜杠的问题，写出绕过代码。比如 Chrome 实例合并导致调试端口不生效，它自己推理出是 macOS 单实例机制的原因。我需要介入的情况不多，主要是确认方向正确，以及验证最终效果。\n浏览器自动化反检测这件事，技术门槛其实不高。不需要逆向工程，不需要破解加密算法。理解 CDP 协议的基本原理，知道 launch() 和 connect_over_cdp() 的区别，知道 CDP 模式下哪些 API 不能用，差不多了。\n如果你也在做类似的事情，希望这 7 个坑能省你一些时间。\n最后说一句合规性。我用这套方案是把同一篇原创内容分发到多个平台，省掉重复的手动操作。不是拿来刷量灌水的。工具无所谓好坏，关键看你拿它做什么。\n","wordCount":"1428","inLanguage":"zh","datePublished":"2026-02-13T10:00:00+08:00","dateModified":"2026-02-14T13:58:57+08:00","author":{"@type":"Person","name":"Miss-you"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://miss-you.github.io/posts/20260213-browser-automation-anti-detection/"},"publisher":{"@type":"Organization","name":"Yousa Driven Development | YDD","logo":{"@type":"ImageObject","url":"https://miss-you.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://miss-you.github.io/ accesskey=h title="Yousa Driven Development | YDD (Alt + H)">Yousa Driven Development | YDD</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://miss-you.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://miss-you.github.io/archives title=归档><span>归档</span></a></li><li><a href=https://miss-you.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://miss-you.github.io/tools/ title=工具><span>工具</span></a></li><li><a href=https://miss-you.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://github.com/Miss-you title=GitHub><span>GitHub</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://miss-you.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://miss-you.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战</h1><div class=post-description>国内内容平台没有开放API，浏览器自动化是唯一出路。但平台风控会检测自动化痕迹。本文记录了一次完整的反检测实战：从 Playwright 被封到 Patchright + CDP 模式的调试全过程，踩过 7 个具体的坑，提炼出可复用的原则。</div><div class=post-meta><span title='2026-02-13 10:00:00 +0800 +0800'>二月 13, 2026</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;12828 字&nbsp;·&nbsp;Miss-you&nbsp;|&nbsp;<a href=https://github.com/Miss-you/miss-you.github.io/tree/main/content/posts/20260213-browser-automation-anti-detection/index.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#为什么得用浏览器自动化>为什么得用浏览器自动化</a></li><li><a href=#传统方案怎么被检测的>传统方案怎么被检测的</a></li><li><a href=#小红书自动发笔记>小红书自动发笔记</a></li><li><a href=#cdp-模式连接真实浏览器>CDP 模式：连接真实浏览器</a><ul><li><a href=#什么是-cdp>什么是 CDP</a></li><li><a href=#launch-vs-connect_over_cdp><code>launch()</code> vs <code>connect_over_cdp()</code></a></li><li><a href=#为什么-cdp-模式更难被检测>为什么 CDP 模式更难被检测</a></li><li><a href=#patchright在-cdp-层做额外修补>Patchright：在 CDP 层做额外修补</a></li></ul></li><li><a href=#7-个坑>7 个坑</a><ul><li><a href=#坑-1chrome-拒绝在默认-profile-上开-cdp-端口>坑 1：Chrome 拒绝在默认 Profile 上开 CDP 端口</a></li><li><a href=#坑-2chrome-实例合并导致调试端口不生效>坑 2：Chrome 实例合并导致调试端口不生效</a></li><li><a href=#坑-3patchright-的-http-发现机制返回-400>坑 3：Patchright 的 HTTP 发现机制返回 400</a></li><li><a href=#坑-4urllibrequest-请求-localhost-返回-502>坑 4：urllib.request 请求 localhost 返回 502</a></li><li><a href=#坑-5cdp-模式下-new_context-导致-err_connection_closed>坑 5：CDP 模式下 <code>new_context()</code> 导致 ERR_CONNECTION_CLOSED</a></li><li><a href=#坑-6cdp-模式下-add_init_script-导致-err_connection_closed>坑 6：CDP 模式下 <code>add_init_script()</code> 导致 ERR_CONNECTION_CLOSED</a></li><li><a href=#坑-7cdp-模式不应覆盖-user-agent>坑 7：CDP 模式不应覆盖 User-Agent</a></li></ul></li><li><a href=#踩完之后回头看>踩完之后回头看</a><ul><li><a href=#风控和反风控争的是真实性>风控和反风控，争的是「真实性」</a></li><li><a href=#浏览器比你想的复杂>浏览器比你想的复杂</a></li><li><a href=#代理是隐形杀手>代理是隐形杀手</a></li><li><a href=#悄悄失败的-bug-用二分法>「悄悄失败」的 bug 用二分法</a></li><li><a href=#版本兼容性别想当然>版本兼容性别想当然</a></li></ul></li><li><a href=#最终代码>最终代码</a></li><li><a href=#写在最后>写在最后</a></li></ul></nav></div></details></div><div class=post-content><h1 id=当浏览器自动化遇上平台风控一次小红书发布工具的反检测实战>当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战<a hidden class=anchor aria-hidden=true href=#当浏览器自动化遇上平台风控一次小红书发布工具的反检测实战>#</a></h1><p>事情的起因很简单。我需要一个工具，自动把内容发布到小红书。</p><p>打开创作者中心，上传几张图，填标题，写正文，加话题标签，点发布。一篇两篇没问题，但每天要发几十篇的话，纯体力劳动。</p><p>自然想到浏览器自动化。写个脚本，模拟人在浏览器里的操作。</p><p>但我低估了难度。Playwright 的 API 很好用，模拟点击、填写、上传都有现成的方法，编码不难。难的是小红书的风控系统会识别出你在用自动化工具，然后封你。</p><p>下面是从被风控到稳定运行的调试记录，踩了 7 个坑。</p><h2 id=为什么得用浏览器自动化>为什么得用浏览器自动化<a hidden class=anchor aria-hidden=true href=#为什么得用浏览器自动化>#</a></h2><p>国内的内容平台，小红书、抖音、公众号，都不提供公开的发布 API。</p><p>海外不一样。Twitter、YouTube、Medium 都有 API，HTTP 请求直接发内容。国内平台对内容管控更严格，API 只给少数合作伙伴，普通开发者拿不到。</p><p>所以你想自动化发内容，只剩一条路。用代码打开浏览器，模拟人的操作。</p><p>主流工具有 Selenium、Playwright、Puppeteer，干的事情一样。启动一个浏览器实例，通过协议控制它。</p><p>但平台也不傻。</p><h2 id=传统方案怎么被检测的>传统方案怎么被检测的<a hidden class=anchor aria-hidden=true href=#传统方案怎么被检测的>#</a></h2><p>用 Playwright 的 <code>launch()</code> 启动浏览器，这个浏览器从出生那一刻就带着「自动化」的印记。风控脚本查几个点就够了。</p><p>最直接的是 <code>navigator.webdriver</code>。正常浏览器里这个值是 <code>undefined</code>，但 Selenium 和 Playwright 启动的浏览器是 <code>true</code>。一行 JS 就能判断。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nx>navigator</span><span class=p>.</span><span class=nx>webdriver</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 自动化工具，触发风控
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>然后是浏览器指纹。UA 字符串可能带 <code>HeadlessChrome</code>，WebGL 渲染结果不同，Canvas 指纹不同，屏幕分辨率是固定的默认值。单个差异不起眼，组合起来就是明确的信号。</p><p>还有操作节奏。机器操作太整齐了，每次点击间隔恰好 500ms，输入速度完全一致。真人会犹豫，会停顿，快慢不一。</p><p>最后是「生活痕迹」。自动化启动的浏览器是全新实例。没有浏览历史，没有书签，没有扩展，没有其他网站的 cookies。像一个刚出厂的手机。</p><p>风控不需要多精密。它只问一个问题：这个浏览器环境真实吗？</p><p>不真实就触发验证码、限制发布、标记异常。</p><h2 id=小红书自动发笔记>小红书自动发笔记<a hidden class=anchor aria-hidden=true href=#小红书自动发笔记>#</a></h2><p>先说我要做的事。</p><p>写一个 Python 脚本。打开小红书创作者中心，登录，上传图片，填标题正文，加话题标签，点发布。</p><p>用 Playwright 写这个流程不难。<code>page.click()</code>、<code>page.fill()</code>、<code>page.set_input_files()</code> 都能直接用。</p><p>第一次跑，成功了。</p><p>第二次，还是成功。</p><p>第三次，弹了个滑块验证码。手动过了，继续。</p><p>第四次，直接提示「操作频繁，请稍后再试」。</p><p>第五次，账号被标记异常，要手机验证。</p><p>典型的风控升级。平台不会一上来就封你，逐步加码，先软后硬。</p><p>到这一步，<code>launch()</code> 模式走不通了。得换思路。</p><h2 id=cdp-模式连接真实浏览器>CDP 模式：连接真实浏览器<a hidden class=anchor aria-hidden=true href=#cdp-模式连接真实浏览器>#</a></h2><p>这是整篇文章的核心。不是前端开发者的话可能对 CDP 不熟，我尽量讲清楚。</p><h3 id=什么是-cdp>什么是 CDP<a hidden class=anchor aria-hidden=true href=#什么是-cdp>#</a></h3><p>CDP 全称 Chrome DevTools Protocol。</p><p>你在 Chrome 里按 F12 打开的开发者工具，Elements 面板、Console 面板、Network 面板，它们和浏览器本体之间走的就是这个协议。</p><p>具体来说，CDP 是一套 JSON 格式的消息，通过 WebSocket 传输。浏览器暴露一个 WebSocket 端口，外部程序通过这个端口发指令、收事件。</p><ul><li>「帮我导航到这个 URL」→ <code>Page.navigate</code></li><li>「帮我执行这段 JS」→ <code>Runtime.evaluate</code></li><li>「页面加载完了没」→ <code>Page.loadEventFired</code></li></ul><p>Playwright 和 Puppeteer 就是 CDP 的高级封装。把底层 JSON 消息包成好用的 API。</p><h3 id=launch-vs-connect_over_cdp><code>launch()</code> vs <code>connect_over_cdp()</code><a hidden class=anchor aria-hidden=true href=#launch-vs-connect_over_cdp>#</a></h3><p>Playwright 有两种模式。这两种模式的区别是解决反检测的关键。</p><p><strong><code>launch()</code></strong>：Playwright 自己启动一个全新的 Chromium 实例，整个生命周期都由它控制。问题是这个浏览器从出生就带自动化标记。<code>--enable-automation</code> 启动参数，<code>navigator.webdriver</code> 设成 <code>true</code>，实例全新，没有用户数据。</p><p><strong><code>connect_over_cdp()</code></strong>：不启动新浏览器，连接到一个已经在运行的 Chrome。可以是你日常用的浏览器，有书签、扩展、浏览历史、登录过的各种网站。Playwright 通过 CDP 协议「接管」控制权。</p><p>一个是造机器人去冒充人类。另一个是给真人装一只遥控的手。</p><h3 id=为什么-cdp-模式更难被检测>为什么 CDP 模式更难被检测<a hidden class=anchor aria-hidden=true href=#为什么-cdp-模式更难被检测>#</a></h3><p>因为连接的就是用户的真实浏览器。</p><ul><li>指纹完全真实。UA、WebGL、Canvas、屏幕分辨率都是真实设备的数据</li><li>没有 <code>--enable-automation</code> 启动参数</li><li>有真实的浏览历史、扩展、书签</li><li>网络栈完全真实。DNS 解析、TLS 握手、证书链验证都是 Chrome 原生行为</li></ul><p>风控看这个浏览器，每个维度都是「真的」。因为它确实是真的。</p><h3 id=patchright在-cdp-层做额外修补>Patchright：在 CDP 层做额外修补<a hidden class=anchor aria-hidden=true href=#patchright在-cdp-层做额外修补>#</a></h3><p>用了 CDP 模式还有几个细微的检测点。Playwright 连接 CDP 时会发一些特定的协议命令，留下可被检测的痕迹。</p><p><a href=https://github.com/Kaliiiiiiiiii-Vinyzu/patchright>Patchright</a> 是 Playwright 的 fork，专门解决这个。修补了三个检测点。</p><p><strong><code>Runtime.enable</code> leak</strong>：Playwright 连接后会发 <code>Runtime.enable</code> 命令监听 JS 运行时事件。某些反检测脚本能检测这个命令是否被调用过。Patchright 移除了这个行为。</p><p><strong><code>Console.enable</code> leak</strong>：Playwright 会启用 Console 域来捕获 <code>console.log</code> 输出。也是检测信号。Patchright 同样移除了。</p><p><strong><code>navigator.webdriver</code></strong>：Patchright 通过 <code>--disable-blink-features=AutomationControlled</code> 启动参数禁用自动化标记。在 CDP 模式下，连接的是用户自己启动的 Chrome，本身就没有 <code>--enable-automation</code>，这个属性天然是正常值。</p><p>前两个修补在 CDP 协议通信层完成，不注入任何 JavaScript。JS 注入本身也能被检测到（通过检查属性描述符、原型链等），协议层的修补对页面内的 JS 完全透明。</p><p>理论讲完了。下面是实战。</p><h2 id=7-个坑>7 个坑<a hidden class=anchor aria-hidden=true href=#7-个坑>#</a></h2><p>理论上方案很清晰。启动 Chrome 加调试端口，用 Patchright 连上去，写自动化脚本。实际操作中每一步都可能出问题。</p><p>以下 7 个坑按遇到的时间顺序排列。大部分是 AI 在「探索 → 生成代码 → 验证」的循环里自己发现的，我作为验收员确认方案可行性，同时学习风控相关的背景知识。</p><h3 id=坑-1chrome-拒绝在默认-profile-上开-cdp-端口>坑 1：Chrome 拒绝在默认 Profile 上开 CDP 端口<a hidden class=anchor aria-hidden=true href=#坑-1chrome-拒绝在默认-profile-上开-cdp-端口>#</a></h3><p><strong>现象</strong></p><p>启动 Chrome 开远程调试端口。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>/Applications/Google<span class=se>\ </span>Chrome.app/Contents/MacOS/Google<span class=se>\ </span>Chrome <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --remote-debugging-port<span class=o>=</span><span class=m>9222</span>
</span></span></code></pre></td></tr></table></div></div><p>终端直接报错。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>DevTools remote debugging requires a non-default data directory.
</span></span></code></pre></td></tr></table></div></div><p>Chrome 启动了，但调试端口没生效。</p><p><strong>原因</strong></p><p>Chrome 136 开始不允许在默认用户数据目录「<code>~/Library/Application Support/Google/Chrome</code>」上启用远程调试端口。安全考虑。如果恶意软件偷偷给你的 Chrome 开了调试端口，它就能通过 CDP 读你所有的 cookies、密码、浏览历史。</p><p><strong>解决</strong></p><p>创建一个专用 Profile 目录。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkdir -p ~/.config/rednote-toolkit/chrome-cdp-profile
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/Applications/Google<span class=se>\ </span>Chrome.app/Contents/MacOS/Google<span class=se>\ </span>Chrome <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --remote-debugging-port<span class=o>=</span><span class=m>9222</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --user-data-dir<span class=o>=</span><span class=s2>&#34;</span><span class=nv>$HOME</span><span class=s2>/.config/rednote-toolkit/chrome-cdp-profile&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --no-first-run <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --no-default-browser-check
</span></span></code></pre></td></tr></table></div></div><p><code>--user-data-dir</code> 指向非默认目录，Chrome 就允许开调试端口了。代价是新 Profile 没有原来的 cookies，不过后面可以通过代码注入。</p><h3 id=坑-2chrome-实例合并导致调试端口不生效>坑 2：Chrome 实例合并导致调试端口不生效<a hidden class=anchor aria-hidden=true href=#坑-2chrome-实例合并导致调试端口不生效>#</a></h3><p><strong>现象</strong></p><p>按坑 1 的方案启动 Chrome，没报错。<code>ps aux | grep Chrome</code> 也能看到进程带着 <code>--remote-debugging-port=9222</code> 参数。但是</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>lsof -i :9222
</span></span><span class=line><span class=cl><span class=c1># 没有输出，端口没被监听</span>
</span></span></code></pre></td></tr></table></div></div><p>Patchright 连接失败。</p><p><strong>原因</strong></p><p>Chrome 在 macOS 上是单实例应用。系统上已经有一个 Chrome 在运行的话（哪怕只是后台残留进程），新的启动命令不会真的创建新进程。它把窗口请求「合并」到已有进程里，<code>--remote-debugging-port=9222</code> 参数直接被扔掉了。</p><p>这个坑最容易忽略。macOS 上关闭所有窗口不等于退出应用。你觉得 Chrome 关了，其实它还在 Dock 栏挂着。</p><p><strong>解决</strong></p><p>启动前确保 Chrome 完全退出。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Cmd+Q 退出 Chrome，或者命令行杀进程</span>
</span></span><span class=line><span class=cl>pkill -f <span class=s2>&#34;Google Chrome&#34;</span>
</span></span><span class=line><span class=cl>sleep <span class=m>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 然后再启动</span>
</span></span><span class=line><span class=cl>/Applications/Google<span class=se>\ </span>Chrome.app/Contents/MacOS/Google<span class=se>\ </span>Chrome <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --remote-debugging-port<span class=o>=</span><span class=m>9222</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --user-data-dir<span class=o>=</span><span class=s2>&#34;</span><span class=nv>$HOME</span><span class=s2>/.config/rednote-toolkit/chrome-cdp-profile&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --no-first-run <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --no-default-browser-check
</span></span></code></pre></td></tr></table></div></div><p>脚本里我加了检测逻辑。启动后用 <code>lsof</code> 确认端口在监听，不在的话提示用户先退出 Chrome。</p><h3 id=坑-3patchright-的-http-发现机制返回-400>坑 3：Patchright 的 HTTP 发现机制返回 400<a hidden class=anchor aria-hidden=true href=#坑-3patchright-的-http-发现机制返回-400>#</a></h3><p><strong>现象</strong></p><p>Chrome 启动了，端口也确认在监听。用 Patchright 连接。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>browser</span> <span class=o>=</span> <span class=k>await</span> <span class=n>pw</span><span class=o>.</span><span class=n>chromium</span><span class=o>.</span><span class=n>connect_over_cdp</span><span class=p>(</span><span class=s2>&#34;http://localhost:9222&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>报错 <code>Unexpected status 400</code>。</p><p>但 curl 请求完全正常。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl http://localhost:9222/json/version
</span></span><span class=line><span class=cl><span class=c1># 返回正常 JSON，包含 webSocketDebuggerUrl</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>原因</strong></p><p>Patchright 内部做 HTTP 发现时，请求路径是 <code>/json/version/</code>，注意尾部多了一个斜杠。Chrome 144 对带尾部斜杠的 URL 返回 400。不带斜杠的 <code>/json/version</code> 正常返回 200。</p><p>Patchright 1.58 + Chrome 144 的兼容性问题。</p><p><strong>解决</strong></p><p>绕过 Patchright 的 HTTP 发现。手动请求 Chrome 的发现端点，提取 WebSocket URL，直连。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span><span class=lnt id=hl-8-18><a class=lnlinks href=#hl-8-18>18</a>
</span><span class=lnt id=hl-8-19><a class=lnlinks href=#hl-8-19>19</a>
</span><span class=lnt id=hl-8-20><a class=lnlinks href=#hl-8-20>20</a>
</span><span class=lnt id=hl-8-21><a class=lnlinks href=#hl-8-21>21</a>
</span><span class=lnt id=hl-8-22><a class=lnlinks href=#hl-8-22>22</a>
</span><span class=lnt id=hl-8-23><a class=lnlinks href=#hl-8-23>23</a>
</span><span class=lnt id=hl-8-24><a class=lnlinks href=#hl-8-24>24</a>
</span><span class=lnt id=hl-8-25><a class=lnlinks href=#hl-8-25>25</a>
</span><span class=lnt id=hl-8-26><a class=lnlinks href=#hl-8-26>26</a>
</span><span class=lnt id=hl-8-27><a class=lnlinks href=#hl-8-27>27</a>
</span><span class=lnt id=hl-8-28><a class=lnlinks href=#hl-8-28>28</a>
</span><span class=lnt id=hl-8-29><a class=lnlinks href=#hl-8-29>29</a>
</span><span class=lnt id=hl-8-30><a class=lnlinks href=#hl-8-30>30</a>
</span><span class=lnt id=hl-8-31><a class=lnlinks href=#hl-8-31>31</a>
</span><span class=lnt id=hl-8-32><a class=lnlinks href=#hl-8-32>32</a>
</span><span class=lnt id=hl-8-33><a class=lnlinks href=#hl-8-33>33</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>http.client</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>json</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>urllib.parse</span> <span class=kn>import</span> <span class=n>urlparse</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>resolve_cdp_ws_url</span><span class=p>(</span><span class=n>endpoint</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>str</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;将 HTTP 端点解析为 WebSocket URL&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>endpoint</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=s2>&#34;ws://&#34;</span><span class=p>)</span> <span class=ow>or</span> <span class=n>endpoint</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=s2>&#34;wss://&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>endpoint</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>parsed</span> <span class=o>=</span> <span class=n>urlparse</span><span class=p>(</span><span class=n>endpoint</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>host</span> <span class=o>=</span> <span class=n>parsed</span><span class=o>.</span><span class=n>hostname</span> <span class=ow>or</span> <span class=s2>&#34;127.0.0.1&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>port</span> <span class=o>=</span> <span class=n>parsed</span><span class=o>.</span><span class=n>port</span> <span class=ow>or</span> <span class=mi>9222</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>conn</span> <span class=o>=</span> <span class=n>http</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>HTTPConnection</span><span class=p>(</span><span class=n>host</span><span class=p>,</span> <span class=n>port</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>request</span><span class=p>(</span><span class=s2>&#34;GET&#34;</span><span class=p>,</span> <span class=s2>&#34;/json/version&#34;</span><span class=p>)</span>  <span class=c1># 没有尾部斜杠</span>
</span></span><span class=line><span class=cl>        <span class=n>resp</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>getresponse</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>resp</span><span class=o>.</span><span class=n>status</span> <span class=o>==</span> <span class=mi>200</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>data</span> <span class=o>=</span> <span class=n>json</span><span class=o>.</span><span class=n>loads</span><span class=p>(</span><span class=n>resp</span><span class=o>.</span><span class=n>read</span><span class=p>())</span>
</span></span><span class=line><span class=cl>            <span class=n>ws_url</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&#34;webSocketDebuggerUrl&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>ws_url</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>conn</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>ws_url</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>Exception</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>endpoint</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用</span>
</span></span><span class=line><span class=cl><span class=n>ws_url</span> <span class=o>=</span> <span class=n>resolve_cdp_ws_url</span><span class=p>(</span><span class=s2>&#34;http://localhost:9222&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>browser</span> <span class=o>=</span> <span class=k>await</span> <span class=n>pw</span><span class=o>.</span><span class=n>chromium</span><span class=o>.</span><span class=n>connect_over_cdp</span><span class=p>(</span><span class=n>ws_url</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>用 <code>http.client</code> 请求 <code>/json/version</code>，从 JSON 里取出 <code>webSocketDebuggerUrl</code>（形如 <code>ws://127.0.0.1:9222/devtools/browser/xxx</code>），传给 <code>connect_over_cdp()</code>。</p><h3 id=坑-4urllibrequest-请求-localhost-返回-502>坑 4：urllib.request 请求 localhost 返回 502<a hidden class=anchor aria-hidden=true href=#坑-4urllibrequest-请求-localhost-返回-502>#</a></h3><p><strong>现象</strong></p><p>写坑 3 的解决方案时，我最初用 <code>urllib.request.urlopen()</code> 请求 <code>/json/version</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>urllib.request</span>
</span></span><span class=line><span class=cl><span class=n>resp</span> <span class=o>=</span> <span class=n>urllib</span><span class=o>.</span><span class=n>request</span><span class=o>.</span><span class=n>urlopen</span><span class=p>(</span><span class=s2>&#34;http://localhost:9222/json/version&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># urllib.error.HTTPError: HTTP Error 502: Bad Gateway</span>
</span></span></code></pre></td></tr></table></div></div><p>502？Bad Gateway？localhost 又没有网关。</p><p>同一时间 <code>curl</code> 正常，<code>http.client</code> 也正常。单独 <code>urllib</code> 不行。</p><p><strong>原因</strong></p><p>我 Mac 上装了 ClashX，开了系统代理。</p><p><code>urllib.request</code> 会读系统代理设置。发现系统配了 HTTP 代理，就把所有请求（包括 localhost）转发给代理服务器。代理收到指向 <code>localhost:9222</code> 的请求，连的是代理服务器自己的 localhost。那上面当然没有 Chrome 在 9222 端口监听，所以 502。</p><p><code>http.client.HTTPConnection</code> 是底层 HTTP 客户端，不读系统代理，直接建 TCP 连接。<code>curl</code> 默认也不走系统代理。</p><p><strong>解决</strong></p><p>用 <code>http.client</code> 代替 <code>urllib.request</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 不要用这个</span>
</span></span><span class=line><span class=cl><span class=c1># urllib.request.urlopen(&#34;http://localhost:9222/json/version&#34;)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 用这个</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>http.client</span>
</span></span><span class=line><span class=cl><span class=n>conn</span> <span class=o>=</span> <span class=n>http</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>HTTPConnection</span><span class=p>(</span><span class=s2>&#34;127.0.0.1&#34;</span><span class=p>,</span> <span class=mi>9222</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>conn</span><span class=o>.</span><span class=n>request</span><span class=p>(</span><span class=s2>&#34;GET&#34;</span><span class=p>,</span> <span class=s2>&#34;/json/version&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>resp</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>getresponse</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=n>resp</span><span class=o>.</span><span class=n>read</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>conn</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p>后来我养成了习惯。在 macOS 上调试 localhost 通信，同一个 URL 用 <code>curl</code> 能通但 Python 不通，先查代理。</p><h3 id=坑-5cdp-模式下-new_context-导致-err_connection_closed>坑 5：CDP 模式下 <code>new_context()</code> 导致 ERR_CONNECTION_CLOSED<a hidden class=anchor aria-hidden=true href=#坑-5cdp-模式下-new_context-导致-err_connection_closed>#</a></h3><p><strong>现象</strong></p><p>连上 Chrome 后，按 Playwright 的常规用法创建新的 BrowserContext。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>browser</span> <span class=o>=</span> <span class=k>await</span> <span class=n>pw</span><span class=o>.</span><span class=n>chromium</span><span class=o>.</span><span class=n>connect_over_cdp</span><span class=p>(</span><span class=n>ws_url</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>context</span> <span class=o>=</span> <span class=k>await</span> <span class=n>browser</span><span class=o>.</span><span class=n>new_context</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>page</span> <span class=o>=</span> <span class=k>await</span> <span class=n>context</span><span class=o>.</span><span class=n>new_page</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>await</span> <span class=n>page</span><span class=o>.</span><span class=n>goto</span><span class=p>(</span><span class=s2>&#34;https://creator.xiaohongshu.com&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>所有 HTTPS 请求失败，控制台全是 <code>ERR_CONNECTION_CLOSED</code>。页面空白。</p><p>但不创建新 context，直接用 Chrome 已有的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>browser</span> <span class=o>=</span> <span class=k>await</span> <span class=n>pw</span><span class=o>.</span><span class=n>chromium</span><span class=o>.</span><span class=n>connect_over_cdp</span><span class=p>(</span><span class=n>ws_url</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>context</span> <span class=o>=</span> <span class=n>browser</span><span class=o>.</span><span class=n>contexts</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>  <span class=c1># Chrome 已有的默认 context</span>
</span></span><span class=line><span class=cl><span class=n>page</span> <span class=o>=</span> <span class=k>await</span> <span class=n>context</span><span class=o>.</span><span class=n>new_page</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>await</span> <span class=n>page</span><span class=o>.</span><span class=n>goto</span><span class=p>(</span><span class=s2>&#34;https://creator.xiaohongshu.com&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>一切正常。</p><p><strong>原因</strong></p><p>这里有个认知误区。</p><p><code>launch()</code> 模式下 Playwright 完全控制浏览器生命周期，<code>new_context()</code> 创建的 BrowserContext 有完整的网络栈配置。CDP 模式下不是这样。<code>new_context()</code> 创建的是一个隔离的 context，有独立的网络栈。</p><p>问题出在「独立的网络栈」。新 context 缺少 Chrome 原始 context 的 DNS 配置、TLS 会话缓存、证书验证策略。HTTPS 连接建不起来。</p><p>说白了，CDP 连接不等于完全透明地操控用户浏览器。<code>new_context()</code> 会引入隔离层，而这个隔离层缺关键的网络配置。</p><p><strong>解决</strong></p><p>不建新 context。用 Chrome 已有的默认 context，通过 <code>add_cookies()</code> 注入 cookies。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>json</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>browser</span> <span class=o>=</span> <span class=k>await</span> <span class=n>pw</span><span class=o>.</span><span class=n>chromium</span><span class=o>.</span><span class=n>connect_over_cdp</span><span class=p>(</span><span class=n>ws_url</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ctx</span> <span class=o>=</span> <span class=n>browser</span><span class=o>.</span><span class=n>contexts</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>  <span class=c1># 使用已有 context</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 注入 cookies</span>
</span></span><span class=line><span class=cl><span class=n>storage_state_path</span> <span class=o>=</span> <span class=s2>&#34;storage_state.json&#34;</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>storage_state_path</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>state</span> <span class=o>=</span> <span class=n>json</span><span class=o>.</span><span class=n>load</span><span class=p>(</span><span class=n>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>await</span> <span class=n>ctx</span><span class=o>.</span><span class=n>add_cookies</span><span class=p>(</span><span class=n>state</span><span class=p>[</span><span class=s2>&#34;cookies&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>page</span> <span class=o>=</span> <span class=k>await</span> <span class=n>ctx</span><span class=o>.</span><span class=n>new_page</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>await</span> <span class=n>page</span><span class=o>.</span><span class=n>goto</span><span class=p>(</span><span class=s2>&#34;https://creator.xiaohongshu.com&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>好处是 DNS、TLS、代理设置全部继承自 Chrome 原始配置。缺点是不能用 BrowserContext 隔离多个会话。需要多账号的话，得启动多个 Chrome 实例。</p><h3 id=坑-6cdp-模式下-add_init_script-导致-err_connection_closed>坑 6：CDP 模式下 <code>add_init_script()</code> 导致 ERR_CONNECTION_CLOSED<a hidden class=anchor aria-hidden=true href=#坑-6cdp-模式下-add_init_script-导致-err_connection_closed>#</a></h3><p><strong>现象</strong></p><p>为了双重保险，我加了一行 JS 注入覆盖 <code>navigator.webdriver</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3>3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4>4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5>5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ctx</span> <span class=o>=</span> <span class=n>browser</span><span class=o>.</span><span class=n>contexts</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>await</span> <span class=n>ctx</span><span class=o>.</span><span class=n>add_init_script</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    Object.defineProperty(navigator, &#39;webdriver&#39;, { get: () =&gt; undefined });
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>page</span> <span class=o>=</span> <span class=k>await</span> <span class=n>ctx</span><span class=o>.</span><span class=n>new_page</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>await</span> <span class=n>page</span><span class=o>.</span><span class=n>goto</span><span class=p>(</span><span class=s2>&#34;https://creator.xiaohongshu.com&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>又是 <code>ERR_CONNECTION_CLOSED</code>。和坑 5 一模一样。</p><p>去掉 <code>add_init_script()</code> 那一行，恢复正常。</p><p><strong>原因</strong></p><p>这是整个调试过程中最难定位的 bug。</p><p><code>add_init_script()</code> 不报任何错误。静静地执行，返回成功。但它改了 context 的页面初始化流程。CDP 模式下，对已有 context 调用这个方法会和 Chrome 原始初始化流程冲突，后续新页面的网络栈被悄悄破坏了。</p><p>具体来说，<code>add_init_script()</code> 通过 CDP 的 <code>Page.addScriptToEvaluateOnNewDocument</code> 命令实现。<code>launch()</code> 模式下 Playwright 完全控制这个流程，没问题。CDP 模式连接到已有 context，这个命令可能和 Chrome 自身的初始化脚本冲突。</p><p><strong>解决</strong></p><p>CDP 模式下跳过 <code>add_init_script()</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4>4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5>5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6>6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7>7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>if</span> <span class=ow>not</span> <span class=n>cdp_endpoint</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 非 CDP 模式，手动覆盖 webdriver</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>ctx</span><span class=o>.</span><span class=n>add_init_script</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        Object.defineProperty(navigator, &#39;webdriver&#39;, {
</span></span></span><span class=line><span class=cl><span class=s2>            get: () =&gt; undefined
</span></span></span><span class=line><span class=cl><span class=s2>        });
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># CDP 模式下不需要。连接的 Chrome 本身没有 --enable-automation，navigator.webdriver 天然正常</span>
</span></span></code></pre></td></tr></table></div></div><p>CDP 模式连接的是用户自己启动的 Chrome，没有 <code>--enable-automation</code> 参数，<code>navigator.webdriver</code> 天然正常，不需要 JS 注入去覆盖。</p><p>定位这个 bug 的过程中，AI 尝试了多种方法，最后靠逐行注释代码做二分找到根因。先注释一半，看正不正常。正常就说明问题在被注释的那一半里。再二分，直到缩小到一行。看日志、猜测、搜 StackOverflow 都没用。</p><h3 id=坑-7cdp-模式不应覆盖-user-agent>坑 7：CDP 模式不应覆盖 User-Agent<a hidden class=anchor aria-hidden=true href=#坑-7cdp-模式不应覆盖-user-agent>#</a></h3><p><strong>现象</strong></p><p>为了进一步隐藏自动化痕迹，我传了自定义 User-Agent。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2>2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3>3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>page</span> <span class=o>=</span> <span class=k>await</span> <span class=n>ctx</span><span class=o>.</span><span class=n>new_page</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>await</span> <span class=n>page</span><span class=o>.</span><span class=n>set_extra_http_headers</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;User-Agent&#34;</span><span class=p>:</span> <span class=s2>&#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) ...&#34;</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div><p>又出网络异常。有些请求正常，有些返回奇怪的错误。</p><p><strong>原因</strong></p><p>CDP 连接的是用户真实的 Chrome。这个 Chrome 有自己的 UA，而且 UA 和浏览器的其他指纹（<code>navigator.userAgentData</code>、Client Hints 等）一致。</p><p>手动覆盖 UA，HTTP 请求头里的 UA 变了，但 JS 层面通过 <code>navigator.userAgent</code> 拿到的可能没变（或者变了但和 Client Hints 不一致）。风控一对比，HTTP 头和 JS 返回值不一致，反而更容易判定自动化。</p><p>覆盖 UA 还可能影响 TLS 协商。某些 CDN 会根据 UA 返回不同内容。</p><p><strong>解决</strong></p><p>CDP 模式下不碰 User-Agent。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2>2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3>3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>if</span> <span class=ow>not</span> <span class=n>cdp_endpoint</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 非 CDP 模式，用预设 UA</span>
</span></span><span class=line><span class=cl>    <span class=n>context_options</span><span class=p>[</span><span class=s2>&#34;user_agent&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>CUSTOM_USER_AGENT</span>
</span></span><span class=line><span class=cl><span class=c1># CDP 模式下用 Chrome 自带的 UA</span>
</span></span></code></pre></td></tr></table></div></div><p>既然在用真实的 Chrome，就不要画蛇添足。Chrome 自己的 UA 就是最好的 UA。</p><h2 id=踩完之后回头看>踩完之后回头看<a hidden class=anchor aria-hidden=true href=#踩完之后回头看>#</a></h2><p>这 7 个坑背后有一些共通的东西。记下来，省得下次再踩。</p><h3 id=风控和反风控争的是真实性>风控和反风控，争的是「真实性」<a hidden class=anchor aria-hidden=true href=#风控和反风控争的是真实性>#</a></h3><p>平台检测的核心问题就一个：这是不是真人在用真浏览器？</p><p>所以最好的反检测不是「伪装成真的」，而是「本来就是真的」。CDP 模式连接真实 Chrome 就是这个思路。不伪装 UA，不伪装指纹，不伪装浏览历史，因为它们本来就是真的。</p><p>操作层面也一样。脚本里每次点击、每次输入都加随机延迟。不是固定 <code>sleep(1)</code>，而是 <code>sleep(random.uniform(0.5, 2.0))</code>。节奏要像真人，有快有慢，偶尔「犹豫」一下。</p><p>坑 7 也说明了这一点。覆盖 UA 导致指纹不一致，比不覆盖更容易被抓。过度伪装适得其反。</p><h3 id=浏览器比你想的复杂>浏览器比你想的复杂<a hidden class=anchor aria-hidden=true href=#浏览器比你想的复杂>#</a></h3><p>我之前对浏览器的认知停留在「发 HTTP 请求、渲染 HTML」。踩了坑 5 和坑 6 才意识到不是这么回事。</p><p>浏览器实例背后有一整套网络栈。DNS 解析器、TLS 会话管理器、证书验证链、代理配置、HTTP/2 连接池、HSTS 缓存。BrowserContext 不只是 cookies 的隔离容器，它隔离的是这整套网络栈。</p><p>CDP 模式下 <code>new_context()</code> 等于创建了一套新的、不完整的网络栈。<code>add_init_script()</code> 改了页面初始化流程，可能和原始 context 的初始化冲突。这些副作用在 <code>launch()</code> 模式下不存在（Playwright 完全控制环境），CDP 模式下就暴露出来了。</p><h3 id=代理是隐形杀手>代理是隐形杀手<a hidden class=anchor aria-hidden=true href=#代理是隐形杀手>#</a></h3><p>macOS 上 ClashX、Surge、V2Ray 这些工具设的系统代理，会影响 Python 的 <code>urllib.request</code>。你的代码访问 <code>localhost</code> 时，请求可能被莫名转发到代理服务器。</p><p>同一个 URL 用 <code>curl</code> 能通但 Python 不通，先怀疑代理。</p><p>两个选择：<code>http.client.HTTPConnection</code> 直连，不读系统代理。或者代码里设 <code>os.environ["no_proxy"] = "localhost,127.0.0.1"</code>。我选了前者，更确定。</p><h3 id=悄悄失败的-bug-用二分法>「悄悄失败」的 bug 用二分法<a hidden class=anchor aria-hidden=true href=#悄悄失败的-bug-用二分法>#</a></h3><p>坑 6 是典型。函数调用不报错，返回值正常，但后续网络连接被偷偷破坏了。</p><p>这类 bug 不出现在日志里，不抛异常，不触发断点。你看到的只是结果不对，不知道哪里导致的。</p><p>我试过看日志、猜原因、搜 StackOverflow，都没用。最后靠二分法。注释掉一半代码，跑一遍，看正不正常。正常就说明问题在被注释的那一半。再二分。每次只改一个变量。慢，但保证能找到。</p><h3 id=版本兼容性别想当然>版本兼容性别想当然<a hidden class=anchor aria-hidden=true href=#版本兼容性别想当然>#</a></h3><p>坑 1 是 Chrome 136 的安全策略变更。坑 3 是 Patchright 1.58 + Chrome 144 的 HTTP 发现不兼容。这些工具的行为和文档描述的（或者你以为的）不一样。</p><p>Chrome 平均 4 周发一个大版本，每个版本都可能改行为。Patchright 作为 Playwright 的 fork，更新节奏不一定跟得上。</p><p>官方方法不工作时别死磕。看版本号，搜 Changelog。兼容性问题要么降版本，要么绕过去。坑 3 我选了绕。Patchright 的 HTTP 发现不好使？自己写一个。手动用 <code>http.client</code> 请求 <code>/json/version</code>，拿到 WebSocket URL 直连。多了十几行代码，问题解决。</p><h2 id=最终代码>最终代码<a hidden class=anchor aria-hidden=true href=#最终代码>#</a></h2><p>把所有解决方案组合起来，核心连接逻辑大致长这样。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14>14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15>15</a>
</span><span class=lnt id=hl-18-16><a class=lnlinks href=#hl-18-16>16</a>
</span><span class=lnt id=hl-18-17><a class=lnlinks href=#hl-18-17>17</a>
</span><span class=lnt id=hl-18-18><a class=lnlinks href=#hl-18-18>18</a>
</span><span class=lnt id=hl-18-19><a class=lnlinks href=#hl-18-19>19</a>
</span><span class=lnt id=hl-18-20><a class=lnlinks href=#hl-18-20>20</a>
</span><span class=lnt id=hl-18-21><a class=lnlinks href=#hl-18-21>21</a>
</span><span class=lnt id=hl-18-22><a class=lnlinks href=#hl-18-22>22</a>
</span><span class=lnt id=hl-18-23><a class=lnlinks href=#hl-18-23>23</a>
</span><span class=lnt id=hl-18-24><a class=lnlinks href=#hl-18-24>24</a>
</span><span class=lnt id=hl-18-25><a class=lnlinks href=#hl-18-25>25</a>
</span><span class=lnt id=hl-18-26><a class=lnlinks href=#hl-18-26>26</a>
</span><span class=lnt id=hl-18-27><a class=lnlinks href=#hl-18-27>27</a>
</span><span class=lnt id=hl-18-28><a class=lnlinks href=#hl-18-28>28</a>
</span><span class=lnt id=hl-18-29><a class=lnlinks href=#hl-18-29>29</a>
</span><span class=lnt id=hl-18-30><a class=lnlinks href=#hl-18-30>30</a>
</span><span class=lnt id=hl-18-31><a class=lnlinks href=#hl-18-31>31</a>
</span><span class=lnt id=hl-18-32><a class=lnlinks href=#hl-18-32>32</a>
</span><span class=lnt id=hl-18-33><a class=lnlinks href=#hl-18-33>33</a>
</span><span class=lnt id=hl-18-34><a class=lnlinks href=#hl-18-34>34</a>
</span><span class=lnt id=hl-18-35><a class=lnlinks href=#hl-18-35>35</a>
</span><span class=lnt id=hl-18-36><a class=lnlinks href=#hl-18-36>36</a>
</span><span class=lnt id=hl-18-37><a class=lnlinks href=#hl-18-37>37</a>
</span><span class=lnt id=hl-18-38><a class=lnlinks href=#hl-18-38>38</a>
</span><span class=lnt id=hl-18-39><a class=lnlinks href=#hl-18-39>39</a>
</span><span class=lnt id=hl-18-40><a class=lnlinks href=#hl-18-40>40</a>
</span><span class=lnt id=hl-18-41><a class=lnlinks href=#hl-18-41>41</a>
</span><span class=lnt id=hl-18-42><a class=lnlinks href=#hl-18-42>42</a>
</span><span class=lnt id=hl-18-43><a class=lnlinks href=#hl-18-43>43</a>
</span><span class=lnt id=hl-18-44><a class=lnlinks href=#hl-18-44>44</a>
</span><span class=lnt id=hl-18-45><a class=lnlinks href=#hl-18-45>45</a>
</span><span class=lnt id=hl-18-46><a class=lnlinks href=#hl-18-46>46</a>
</span><span class=lnt id=hl-18-47><a class=lnlinks href=#hl-18-47>47</a>
</span><span class=lnt id=hl-18-48><a class=lnlinks href=#hl-18-48>48</a>
</span><span class=lnt id=hl-18-49><a class=lnlinks href=#hl-18-49>49</a>
</span><span class=lnt id=hl-18-50><a class=lnlinks href=#hl-18-50>50</a>
</span><span class=lnt id=hl-18-51><a class=lnlinks href=#hl-18-51>51</a>
</span><span class=lnt id=hl-18-52><a class=lnlinks href=#hl-18-52>52</a>
</span><span class=lnt id=hl-18-53><a class=lnlinks href=#hl-18-53>53</a>
</span><span class=lnt id=hl-18-54><a class=lnlinks href=#hl-18-54>54</a>
</span><span class=lnt id=hl-18-55><a class=lnlinks href=#hl-18-55>55</a>
</span><span class=lnt id=hl-18-56><a class=lnlinks href=#hl-18-56>56</a>
</span><span class=lnt id=hl-18-57><a class=lnlinks href=#hl-18-57>57</a>
</span><span class=lnt id=hl-18-58><a class=lnlinks href=#hl-18-58>58</a>
</span><span class=lnt id=hl-18-59><a class=lnlinks href=#hl-18-59>59</a>
</span><span class=lnt id=hl-18-60><a class=lnlinks href=#hl-18-60>60</a>
</span><span class=lnt id=hl-18-61><a class=lnlinks href=#hl-18-61>61</a>
</span><span class=lnt id=hl-18-62><a class=lnlinks href=#hl-18-62>62</a>
</span><span class=lnt id=hl-18-63><a class=lnlinks href=#hl-18-63>63</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>http.client</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>json</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>urllib.parse</span> <span class=kn>import</span> <span class=n>urlparse</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>patchright.async_api</span> <span class=kn>import</span> <span class=n>async_playwright</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>resolve_cdp_ws_url</span><span class=p>(</span><span class=n>endpoint</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>str</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;手动解析 CDP WebSocket URL，绕过 Patchright 的 HTTP 发现 bug&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>endpoint</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=s2>&#34;ws://&#34;</span><span class=p>)</span> <span class=ow>or</span> <span class=n>endpoint</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=s2>&#34;wss://&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>endpoint</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>parsed</span> <span class=o>=</span> <span class=n>urlparse</span><span class=p>(</span><span class=n>endpoint</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>host</span> <span class=o>=</span> <span class=n>parsed</span><span class=o>.</span><span class=n>hostname</span> <span class=ow>or</span> <span class=s2>&#34;127.0.0.1&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>port</span> <span class=o>=</span> <span class=n>parsed</span><span class=o>.</span><span class=n>port</span> <span class=ow>or</span> <span class=mi>9222</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span> <span class=o>=</span> <span class=n>http</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>HTTPConnection</span><span class=p>(</span><span class=n>host</span><span class=p>,</span> <span class=n>port</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>request</span><span class=p>(</span><span class=s2>&#34;GET&#34;</span><span class=p>,</span> <span class=s2>&#34;/json/version&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>resp</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>getresponse</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>resp</span><span class=o>.</span><span class=n>status</span> <span class=o>==</span> <span class=mi>200</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>data</span> <span class=o>=</span> <span class=n>json</span><span class=o>.</span><span class=n>loads</span><span class=p>(</span><span class=n>resp</span><span class=o>.</span><span class=n>read</span><span class=p>())</span>
</span></span><span class=line><span class=cl>            <span class=n>ws_url</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&#34;webSocketDebuggerUrl&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>ws_url</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>conn</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>ws_url</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>Exception</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>endpoint</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>create_browser_context</span><span class=p>(</span><span class=n>cdp_endpoint</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>pw</span> <span class=o>=</span> <span class=k>await</span> <span class=n>async_playwright</span><span class=p>()</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>cdp_endpoint</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># CDP 模式：连接已有的 Chrome</span>
</span></span><span class=line><span class=cl>        <span class=n>ws_url</span> <span class=o>=</span> <span class=n>resolve_cdp_ws_url</span><span class=p>(</span><span class=n>cdp_endpoint</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>browser</span> <span class=o>=</span> <span class=k>await</span> <span class=n>pw</span><span class=o>.</span><span class=n>chromium</span><span class=o>.</span><span class=n>connect_over_cdp</span><span class=p>(</span><span class=n>ws_url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>ctx</span> <span class=o>=</span> <span class=n>browser</span><span class=o>.</span><span class=n>contexts</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>  <span class=c1># 用已有 context，不要 new_context()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 注入 cookies，不用 add_init_script</span>
</span></span><span class=line><span class=cl>        <span class=n>storage_state_path</span> <span class=o>=</span> <span class=s2>&#34;storage_state.json&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>storage_state_path</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>state</span> <span class=o>=</span> <span class=n>json</span><span class=o>.</span><span class=n>load</span><span class=p>(</span><span class=n>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>await</span> <span class=n>ctx</span><span class=o>.</span><span class=n>add_cookies</span><span class=p>(</span><span class=n>state</span><span class=p>[</span><span class=s2>&#34;cookies&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=ne>FileNotFoundError</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>pass</span>  <span class=c1># 首次运行没有保存的状态</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># CDP 模式不覆盖 UA，不注入 init script</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 非 CDP 模式：Patchright 自己启动浏览器</span>
</span></span><span class=line><span class=cl>        <span class=n>browser</span> <span class=o>=</span> <span class=k>await</span> <span class=n>pw</span><span class=o>.</span><span class=n>chromium</span><span class=o>.</span><span class=n>launch</span><span class=p>(</span><span class=n>headless</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>ctx</span> <span class=o>=</span> <span class=k>await</span> <span class=n>browser</span><span class=o>.</span><span class=n>new_context</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>user_agent</span><span class=o>=</span><span class=s2>&#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) ...&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 非 CDP 模式可以安全使用 add_init_script</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=n>ctx</span><span class=o>.</span><span class=n>add_init_script</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>            Object.defineProperty(navigator, &#39;webdriver&#39;, {
</span></span></span><span class=line><span class=cl><span class=s2>                get: () =&gt; undefined
</span></span></span><span class=line><span class=cl><span class=s2>            });
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>browser</span><span class=p>,</span> <span class=n>ctx</span><span class=p>,</span> <span class=n>pw</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=写在最后>写在最后<a hidden class=anchor aria-hidden=true href=#写在最后>#</a></h2><p>整个调试过程前后花了大概 2-3 个小时。</p><p>工作模式是这样的：我把需求描述给 AI，AI 在「探索 → 生成代码 → 验证」的循环里自主推进。它去尝试各种方案，遇到报错就分析原因，生成修复代码，再验证。我主要负责三方面：一是作为验收员，确认 AI 提出的方案是否合理；二是学习风控和反风控的背景知识，理解平台检测的原理；三是作为测试员，在关键环节做人工验证，比如登录账号看是否触发风控。</p><p>大部分问题 AI 自己能闭环解决。比如 Patchright 的 HTTP 发现机制返回 400，它自己查到是 URL 尾部斜杠的问题，写出绕过代码。比如 Chrome 实例合并导致调试端口不生效，它自己推理出是 macOS 单实例机制的原因。我需要介入的情况不多，主要是确认方向正确，以及验证最终效果。</p><p>浏览器自动化反检测这件事，技术门槛其实不高。不需要逆向工程，不需要破解加密算法。理解 CDP 协议的基本原理，知道 <code>launch()</code> 和 <code>connect_over_cdp()</code> 的区别，知道 CDP 模式下哪些 API 不能用，差不多了。</p><p>如果你也在做类似的事情，希望这 7 个坑能省你一些时间。</p><p>最后说一句合规性。我用这套方案是把同一篇原创内容分发到多个平台，省掉重复的手动操作。不是拿来刷量灌水的。工具无所谓好坏，关键看你拿它做什么。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://miss-you.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%8C%96/>浏览器自动化</a></li><li><a href=https://miss-you.github.io/tags/cdp/>CDP</a></li><li><a href=https://miss-you.github.io/tags/%E5%8F%8D%E6%A3%80%E6%B5%8B/>反检测</a></li><li><a href=https://miss-you.github.io/tags/patchright/>Patchright</a></li><li><a href=https://miss-you.github.io/tags/%E5%B0%8F%E7%BA%A2%E4%B9%A6/>小红书</a></li><li><a href=https://miss-you.github.io/tags/python/>Python</a></li></ul><nav class=paginav><a class=prev href=https://miss-you.github.io/posts/20260214-busy-poor-vs-leveraged-wealth/><span class=title>« 上一页</span><br><span>为什么有些人越忙越穷，有些人越闲越富</span>
</a><a class=next href=https://miss-you.github.io/posts/20260113-the-chaser-dilemma/><span class=title>下一页 »</span><br><span>追赶者困境</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战 on x" href="https://x.com/intent/tweet/?text=%e5%bd%93%e6%b5%8f%e8%a7%88%e5%99%a8%e8%87%aa%e5%8a%a8%e5%8c%96%e9%81%87%e4%b8%8a%e5%b9%b3%e5%8f%b0%e9%a3%8e%e6%8e%a7%ef%bc%9a%e4%b8%80%e6%ac%a1%e5%b0%8f%e7%ba%a2%e4%b9%a6%e5%8f%91%e5%b8%83%e5%b7%a5%e5%85%b7%e7%9a%84%e5%8f%8d%e6%a3%80%e6%b5%8b%e5%ae%9e%e6%88%98&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260213-browser-automation-anti-detection%2f&amp;hashtags=%e6%b5%8f%e8%a7%88%e5%99%a8%e8%87%aa%e5%8a%a8%e5%8c%96%2cCDP%2c%e5%8f%8d%e6%a3%80%e6%b5%8b%2cPatchright%2c%e5%b0%8f%e7%ba%a2%e4%b9%a6%2cPython"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260213-browser-automation-anti-detection%2f&amp;title=%e5%bd%93%e6%b5%8f%e8%a7%88%e5%99%a8%e8%87%aa%e5%8a%a8%e5%8c%96%e9%81%87%e4%b8%8a%e5%b9%b3%e5%8f%b0%e9%a3%8e%e6%8e%a7%ef%bc%9a%e4%b8%80%e6%ac%a1%e5%b0%8f%e7%ba%a2%e4%b9%a6%e5%8f%91%e5%b8%83%e5%b7%a5%e5%85%b7%e7%9a%84%e5%8f%8d%e6%a3%80%e6%b5%8b%e5%ae%9e%e6%88%98&amp;summary=%e5%bd%93%e6%b5%8f%e8%a7%88%e5%99%a8%e8%87%aa%e5%8a%a8%e5%8c%96%e9%81%87%e4%b8%8a%e5%b9%b3%e5%8f%b0%e9%a3%8e%e6%8e%a7%ef%bc%9a%e4%b8%80%e6%ac%a1%e5%b0%8f%e7%ba%a2%e4%b9%a6%e5%8f%91%e5%b8%83%e5%b7%a5%e5%85%b7%e7%9a%84%e5%8f%8d%e6%a3%80%e6%b5%8b%e5%ae%9e%e6%88%98&amp;source=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260213-browser-automation-anti-detection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260213-browser-automation-anti-detection%2f&title=%e5%bd%93%e6%b5%8f%e8%a7%88%e5%99%a8%e8%87%aa%e5%8a%a8%e5%8c%96%e9%81%87%e4%b8%8a%e5%b9%b3%e5%8f%b0%e9%a3%8e%e6%8e%a7%ef%bc%9a%e4%b8%80%e6%ac%a1%e5%b0%8f%e7%ba%a2%e4%b9%a6%e5%8f%91%e5%b8%83%e5%b7%a5%e5%85%b7%e7%9a%84%e5%8f%8d%e6%a3%80%e6%b5%8b%e5%ae%9e%e6%88%98"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260213-browser-automation-anti-detection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战 on whatsapp" href="https://api.whatsapp.com/send?text=%e5%bd%93%e6%b5%8f%e8%a7%88%e5%99%a8%e8%87%aa%e5%8a%a8%e5%8c%96%e9%81%87%e4%b8%8a%e5%b9%b3%e5%8f%b0%e9%a3%8e%e6%8e%a7%ef%bc%9a%e4%b8%80%e6%ac%a1%e5%b0%8f%e7%ba%a2%e4%b9%a6%e5%8f%91%e5%b8%83%e5%b7%a5%e5%85%b7%e7%9a%84%e5%8f%8d%e6%a3%80%e6%b5%8b%e5%ae%9e%e6%88%98%20-%20https%3a%2f%2fmiss-you.github.io%2fposts%2f20260213-browser-automation-anti-detection%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战 on telegram" href="https://telegram.me/share/url?text=%e5%bd%93%e6%b5%8f%e8%a7%88%e5%99%a8%e8%87%aa%e5%8a%a8%e5%8c%96%e9%81%87%e4%b8%8a%e5%b9%b3%e5%8f%b0%e9%a3%8e%e6%8e%a7%ef%bc%9a%e4%b8%80%e6%ac%a1%e5%b0%8f%e7%ba%a2%e4%b9%a6%e5%8f%91%e5%b8%83%e5%b7%a5%e5%85%b7%e7%9a%84%e5%8f%8d%e6%a3%80%e6%b5%8b%e5%ae%9e%e6%88%98&amp;url=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260213-browser-automation-anti-detection%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 当浏览器自动化遇上平台风控：一次小红书发布工具的反检测实战 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e5%bd%93%e6%b5%8f%e8%a7%88%e5%99%a8%e8%87%aa%e5%8a%a8%e5%8c%96%e9%81%87%e4%b8%8a%e5%b9%b3%e5%8f%b0%e9%a3%8e%e6%8e%a7%ef%bc%9a%e4%b8%80%e6%ac%a1%e5%b0%8f%e7%ba%a2%e4%b9%a6%e5%8f%91%e5%b8%83%e5%b7%a5%e5%85%b7%e7%9a%84%e5%8f%8d%e6%a3%80%e6%b5%8b%e5%ae%9e%e6%88%98&u=https%3a%2f%2fmiss-you.github.io%2fposts%2f20260213-browser-automation-anti-detection%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://miss-you.github.io/>Yousa Driven Development | YDD</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  
  
  const isDarkMode = () => {
    return document.body.classList.contains('dark');
  };
  
  
  const mermaidKeywords = [
    'graph ', 'graph TB', 'graph TD', 'graph LR', 'graph RL', 'graph BT',
    'flowchart ', 'flowchart TB', 'flowchart TD', 'flowchart LR', 'flowchart RL', 'flowchart BT',
    'sequenceDiagram', 'classDiagram', 'stateDiagram', 'stateDiagram-v2',
    'erDiagram', 'journey', 'gantt', 'pie', 'requirementDiagram',
    'gitGraph', 'mindmap', 'timeline', 'sankey'
  ];
  
  const isMermaidCode = (code) => {
    const trimmed = code.trim();
    return mermaidKeywords.some(keyword => trimmed.startsWith(keyword));
  };
  
  
  const getColors = () => {
    if (isDarkMode()) {
      return {
        
        bg: '#1d1e20',
        surface: '#2d2e30',
        border: '#444',
        text: '#dadaeb',
        secondary: '#9c9d9e',
        line: '#9c9d9e',
        
        accent1: '#5a7a96',  
        accent2: '#6b8e6b',  
        accent3: '#b8a87c',  
      };
    }
    
    return {
      bg: '#f4f3ee',        
      surface: '#faf9f5',   
      border: '#2c2c2c',    
      text: '#1f1f1f',      
      secondary: '#6c6c6c', 
      line: '#4a4a4a',      
      
      accent1: '#8fb8d4',   
      accent2: '#a8c6a8',   
      accent3: '#d4c59a',   
    };
  };
  
  const initMermaid = () => {
    const c = getColors();
    
    mermaid.initialize({
      startOnLoad: false,
      theme: 'base',
      themeVariables: {
        
        fontFamily: '"Noto Serif SC", Georgia, serif',
        fontSize: '16px',           
        
        
        background: c.bg,
        mainBkg: c.surface,
        
        
        primaryColor: c.surface,
        primaryTextColor: c.text,
        primaryBorderColor: c.border,
        
        
        secondaryColor: c.accent1,
        tertiaryColor: c.accent2,
        
        
        lineColor: c.line,
        nodeBorder: c.border,
        clusterBkg: c.bg,
        clusterBorder: c.border,
        
        
        textColor: c.text,
        titleColor: c.text,
        nodeTextColor: c.text,
        labelColor: c.text,
        
        
        edgeLabelBackground: c.bg,
        
        
        actorBorder: c.border,
        actorBkg: c.surface,
        actorTextColor: c.text,
        actorLineColor: c.border,
        signalColor: c.line,
        signalTextColor: c.text,
        
        
        stateBorder: c.border,
        stateBkg: c.surface,
        
        
        cScale0: c.surface,
        cScale1: c.accent1,
        cScale2: c.accent2,
        cScale3: c.accent3,
        cScale4: c.surface,
        cScale5: c.accent1,
      },
      
      
      flowchart: {
        useMaxWidth: true,
        htmlLabels: true,
        curve: 'basis',
        padding: 20,
        nodeSpacing: 50,
        rankSpacing: 60,
      },
      
      
      sequence: {
        useMaxWidth: true,
        diagramMarginX: 50,
        diagramMarginY: 20,
        actorMargin: 60,
        width: 160,
        height: 70,
        boxMargin: 15,
        boxTextMargin: 8,
        noteMargin: 15,
        messageMargin: 40,
        mirrorActors: true,
        bottomMarginAdj: 1,
        rightAngles: false,
        showSequenceNumbers: false,
        
        actorFontSize: '16px',
        noteFontSize: '15px',
        messageFontSize: '15px',
      },
      
      
      state: {
        useMaxWidth: true,
        padding: 15,
        fontSize: '16px',
      },
      
      
      class: {
        useMaxWidth: true,
        fontSize: '15px',
      },
      
      
      er: {
        useMaxWidth: true,
        fontSize: '15px',
      },
      
      
      gantt: {
        useMaxWidth: true,
        fontSize: '14px',
      },
      
      
      look: 'handDrawn',
    });
  };
  
  const renderMermaidDiagrams = async () => {
    const allCodeBlocks = document.querySelectorAll('pre code');
    const mermaidBlocks = [];
    
    allCodeBlocks.forEach(block => {
      const code = block.textContent;
      if (isMermaidCode(code)) {
        mermaidBlocks.push(block);
      }
    });
    
    if (mermaidBlocks.length === 0) return;
    
    initMermaid();
    const c = getColors();
    
    for (const block of mermaidBlocks) {
      const pre = block.parentElement;
      const code = block.textContent.trim();
      
      
      const wrapper = document.createElement('div');
      wrapper.className = 'mermaid-diagram';
      wrapper.style.cssText = `
        margin: 2em 0;
        padding: 24px;
        background: ${c.bg};
        border: 1px solid ${c.border}30;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        overflow-x: auto;
      `;
      
      
      const container = document.createElement('div');
      container.style.cssText = `
        display: flex;
        justify-content: center;
        min-width: fit-content;
      `;
      
      const mermaidDiv = document.createElement('div');
      mermaidDiv.className = 'mermaid';
      mermaidDiv.textContent = code;
      container.appendChild(mermaidDiv);
      wrapper.appendChild(container);
      
      pre.parentNode.replaceChild(wrapper, pre);
      
      try {
        await mermaid.run({ querySelector: '.mermaid' });
      } catch (error) {
        console.error('Mermaid error:', error);
      }
    }
  };
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', renderMermaidDiagrams);
  } else {
    renderMermaidDiagrams();
  }
  
  
  let timeout;
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === 'class') {
        clearTimeout(timeout);
        timeout = setTimeout(() => location.reload(), 300);
      }
    });
  });
  observer.observe(document.body, { attributes: true });
</script><style>.mermaid-diagram{font-family:noto serif sc,Georgia,serif}.mermaid-diagram .mermaid{display:flex;justify-content:center}.mermaid-diagram svg{max-width:100% !important;height:auto !important;font-family:noto serif sc,Georgia,serif !important}.mermaid-diagram svg text,.mermaid-diagram svg .label,.mermaid-diagram svg .nodeLabel,.mermaid-diagram svg .edgeLabel,.mermaid-diagram svg .messageText,.mermaid-diagram svg .actor text,.mermaid-diagram svg .participant text{fill:#1f1f1f !important;font-family:noto serif sc,Georgia,serif !important;font-size:15px !important;font-weight:500 !important}.dark .mermaid-diagram svg text,.dark .mermaid-diagram svg .label,.dark .mermaid-diagram svg .nodeLabel,.dark .mermaid-diagram svg .edgeLabel,.dark .mermaid-diagram svg .messageText,.dark .mermaid-diagram svg .actor text,.dark .mermaid-diagram svg .participant text{fill:#dadaeb !important}.mermaid-diagram svg .sequenceDiagram text{font-size:16px !important}.mermaid-diagram svg .actor{font-size:16px !important}.mermaid-diagram svg .messageText{font-size:15px !important}.mermaid-diagram svg .node rect,.mermaid-diagram svg .node circle,.mermaid-diagram svg .node ellipse,.mermaid-diagram svg .node polygon{stroke-width:2px !important}.mermaid-diagram svg{filter:drop-shadow(0 1px 3px rgba(0,0,0,8%))}.dark .mermaid-diagram{background:#1d1e20 !important;border-color:#444 !important;box-shadow:0 2px 8px rgba(0,0,0,.2) !important}@media(max-width:768px){.mermaid-diagram{padding:16px !important;margin:1.5em 0 !important}.mermaid-diagram svg text{font-size:14px !important}}.mermaid-diagram{opacity:0;animation:fadeIn .4s ease-out forwards}@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}</style><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>